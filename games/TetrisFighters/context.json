{
  "messages": [
    {
      "role": "user",
      "content": "a game where you have two ongoing tetris games and have to play both of them and not die or you die in both, left side played with wsad, right side played with up down left right\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dual Tetris - Play Both or Lose Both</title>\n<style>\n  /* Reset */\n  * {\n    box-sizing: border-box;\n  }\n  body {\n    background: #111;\n    color: #eee;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    user-select: none;\n    margin: 0;\n    padding: 0;\n    display:flex;\n    min-height:100vh;\n    justify-content: center;\n    align-items: center;\n  }\n  h1 {\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    gap: 40px;\n  }\n  .tetris-game {\n    background: #222;\n    padding: 10px;\n    border-radius: 8px;\n    box-shadow: 0 0 15px #0ff ease-in-out;\n  }\n\n  canvas {\n    background-color: #111;\n    display: block;\n    margin: 0 auto;\n    image-rendering: pixelated;\n    border: 2px solid #0ff;\n  }\n  #leftGame canvas {\n    border-color: #0f0;\n  }\n  #rightGame canvas {\n    border-color: #0af;\n  }\n\n  .title {\n    font-weight: bold;\n    text-align: center;\n    margin-bottom: 6px;\n    font-size: 1.2rem;\n    color: #0ff;\n  }\n\n  .instructions {\n    font-size: 0.8rem;\n    color: #666;\n    margin-top: 8px;\n    text-align: center;\n    line-height: 1.2;\n    max-width: 240px;\n  }\n  #gameOverMsg {\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: rgba(20, 20, 20, 0.95);\n    padding: 30px 40px;\n    border-radius: 12px;\n    box-shadow: 0 0 20px #f00;\n    font-size: 2rem;\n    text-align: center;\n    z-index: 2000;\n    color: #f00;\n    user-select:none;\n  }\n  #restartBtn {\n    margin-top: 18px;\n    background-color: #f00;\n    color: #111;\n    border: none;\n    font-size: 1rem;\n    padding: 10px 20px;\n    border-radius: 6px;\n    cursor: pointer;\n  }\n  #restartBtn:hover {\n    background-color: #b30000;\n  }\n</style>\n</head>\n<body>\n\n<div id=\"container\">\n  <div class=\"tetris-game\" id=\"leftGame\">\n    <div class=\"title\">Left Tetris<br><small>(WSAD Controls)</small></div>\n    <canvas width=\"240\" height=\"400\"></canvas>\n    <div class=\"instructions\">\n      <b>Controls:</b><br>\n      W - Rotate<br>\n      A - Move Left<br>\n      S - Soft Drop<br>\n      D - Move Right\n    </div>\n  </div>\n  <div class=\"tetris-game\" id=\"rightGame\">\n    <div class=\"title\">Right Tetris<br><small>(Arrow Keys Controls)</small></div>\n    <canvas width=\"240\" height=\"400\"></canvas>\n    <div class=\"instructions\">\n      <b>Controls:</b><br>\n      ↑ - Rotate<br>\n      ← - Move Left<br>\n      ↓ - Soft Drop<br>\n      → - Move Right\n    </div>\n  </div>\n</div>\n\n<div id=\"gameOverMsg\" style=\"display:none;\">\n  <div id=\"gameOverText\"></div>\n  <button id=\"restartBtn\">Restart</button>\n</div>\n\n<script>\n(() => {\n  // Constants\n  const COLS = 10;\n  const ROWS = 20;\n  const BLOCK_SIZE = 20;\n  const DROP_INTERVAL = 800;\n  const SOFT_DROP_INTERVAL = 40;\n\n  // Tetromino shapes and colors\n  const SHAPES = {\n    I: [\n      [[0,1], [1,1], [2,1], [3,1]],\n      [[2,0], [2,1], [2,2], [2,3]],\n      [[0,2], [1,2], [2,2], [3,2]],\n      [[1,0], [1,1], [1,2], [1,3]]\n    ],\n    J: [\n      [[0,0],[0,1],[1,1],[2,1]],\n      [[1,0],[2,0],[1,1],[1,2]],\n      [[0,1],[1,1],[2,1],[2,2]],\n      [[1,0],[1,1],[0,2],[1,2]]\n    ],\n    L: [\n      [[2,0],[0,1],[1,1],[2,1]],\n      [[1,0],[1,1],[1,2],[2,2]],\n      [[0,1],[1,1],[2,1],[0,2]],\n      [[0,0],[1,0],[1,1],[1,2]]\n    ],\n    O: [\n      [[1,0],[2,0],[1,1],[2,1]],\n      [[1,0],[2,0],[1,1],[2,1]],\n      [[1,0],[2,0],[1,1],[2,1]],\n      [[1,0],[2,0],[1,1],[2,1]]\n    ],\n    S: [\n      [[1,0],[2,0],[0,1],[1,1]],\n      [[1,0],[1,1],[2,1],[2,2]],\n      [[1,1],[2,1],[0,2],[1,2]],\n      [[0,0],[0,1],[1,1],[1,2]]\n    ],\n    T: [\n      [[1,0],[0,1],[1,1],[2,1]],\n      [[1,0],[1,1],[2,1],[1,2]],\n      [[0,1],[1,1],[2,1],[1,2]],\n      [[1,0],[0,1],[1,1],[1,2]]\n    ],\n    Z: [\n      [[0,0],[1,0],[1,1],[2,1]],\n      [[2,0],[1,1],[2,1],[1,2]],\n      [[0,1],[1,1],[1,2],[2,2]],\n      [[1,0],[0,1],[1,1],[0,2]]\n    ]\n  };\n\n  const COLORS = {\n    I: '#00ffff',\n    J: '#0000ff',\n    L: '#ff7f00',\n    O: '#ffff00',\n    S: '#00ff00',\n    T: '#800080',\n    Z: '#ff0000'\n  };\n\n  // Utilities\n  function createMatrix(w, h) {\n    const matrix = [];\n    while(h--) {\n      matrix.push(new Array(w).fill(null));\n    }\n    return matrix;\n  }\n\n  // Tetromino Class\n  class Tetromino {\n    constructor(type) {\n      this.type = type;\n      this.color = COLORS[type];\n      this.shapeIndex = 0;\n      this.blocks = SHAPES[type];\n      this.position = { x: 3, y: 0 }; // spawn position\n    }\n    get coords() {\n      return this.blocks[this.shapeIndex];\n    }\n    rotate(dir = 1) {\n      this.shapeIndex = (this.shapeIndex + dir + 4) % 4;\n    }\n  }\n\n  // Game Class\n  class TetrisGame {\n    constructor(canvas, controls, name) {\n      this.name = name;\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n      this.ctx.scale(BLOCK_SIZE, BLOCK_SIZE);\n      this.grid = createMatrix(COLS, ROWS);\n      this.score = 0;\n      this.level = 1;\n      this.lines = 0;\n      this.dropCounter = 0;\n      this.dropInterval = DROP_INTERVAL;\n      this.lastTime = 0;\n      this.gameOver = false;\n\n      this.controls = controls;\n\n      this.currentPiece = this.randomTetromino();\n\n      this.nextPiece = this.randomTetromino();\n\n      // Bind input handler\n      this.keyStates = new Set();\n\n      this.inputMap = controls;\n\n      this.softDropping = false;\n\n      this.init();\n    }\n\n    init() {\n      this.grid = createMatrix(COLS, ROWS);\n      this.score = 0;\n      this.level = 1;\n      this.lines = 0;\n      this.dropCounter = 0;\n      this.dropInterval = DROP_INTERVAL;\n      this.gameOver = false;\n      this.currentPiece = this.randomTetromino();\n      this.nextPiece = this.randomTetromino();\n      this.softDropping = false;\n    }\n\n    randomTetromino() {\n      const types = Object.keys(SHAPES);\n      const randType = types[Math.floor(Math.random() * types.length)];\n      return new Tetromino(randType);\n    }\n\n    collide(grid, piece) {\n      for (const [x, y] of piece.coords) {\n        const px = piece.position.x + x;\n        const py = piece.position.y + y;\n        if (px < 0 || px >= COLS || py >= ROWS) return true;\n        if (py < 0) continue; // above visible field allowed\n        if (grid[py][px] !== null) return true;\n      }\n      return false;\n    }\n\n    merge(grid, piece) {\n      for (const [x, y] of piece.coords) {\n        const px = piece.position.x + x;\n        const py = piece.position.y + y;\n        if(py>=0)\n          grid[py][px] = piece.color;\n      }\n    }\n\n    clearLines() {\n      let linesCleared = 0;\n      outer: for (let y=ROWS-1; y>=0; y--) {\n        for (let x=0; x<COLS; x++) {\n          if (this.grid[y][x] === null) {\n            continue outer;\n          }\n        }\n        // line full - remove it\n        const row = this.grid.splice(y,1)[0].fill(null);\n        this.grid.unshift(row);\n        y++;\n        linesCleared++;\n      }\n\n      if(linesCleared > 0) {\n        // Score: Standard tetris scoring per lines cleared at once\n        const lineScores = [0, 40, 100, 300, 1200];\n        this.score += lineScores[linesCleared] * this.level;\n\n        this.lines += linesCleared;\n\n        // Level up every 10 lines\n        if (this.lines >= this.level * 10) {\n          this.level++;\n          this.dropInterval = Math.max(100, DROP_INTERVAL - (this.level-1)*70);\n        }\n      }\n    }\n\n    rotate(dir = 1) {\n      const piece = this.currentPiece;\n      piece.rotate(dir);\n      // Wall kick attempts\n      const pos = piece.position.x;\n      let offset = 1;\n      while (this.collide(this.grid, piece)) {\n        piece.position.x += offset;\n        offset = -(offset + (offset > 0 ? 1 : -1));\n        if (offset > piece.coords.length) {\n          piece.rotate(-dir);\n          piece.position.x = pos;\n          return;\n        }\n      }\n    }\n\n    drop() {\n      this.currentPiece.position.y++;\n      if (this.collide(this.grid, this.currentPiece)) {\n        this.currentPiece.position.y--;\n        // merge piece into the grid before switching\n        this.merge(this.grid, this.currentPiece);\n        this.clearLines();\n        this.currentPiece = this.nextPiece;\n        this.nextPiece = this.randomTetromino();\n        if(this.collide(this.grid, this.currentPiece)) {\n          // Game over\n          this.gameOver = true;\n        }\n      }\n      this.dropCounter = 0;\n    }\n\n    move(dir) {\n      this.currentPiece.position.x += dir;\n      if(this.collide(this.grid, this.currentPiece)) {\n        this.currentPiece.position.x -= dir;\n      }\n    }\n\n    softDrop(on) {\n      this.softDropping = on;\n    }\n\n    update(deltaTime) {\n      if(this.gameOver) return;\n\n      const interval = this.softDropping ? SOFT_DROP_INTERVAL : this.dropInterval;\n\n      this.dropCounter += deltaTime;\n      if(this.dropCounter > interval) {\n        this.drop();\n        this.dropCounter = 0;\n      }\n    }\n\n    drawBlock(x, y, color) {\n      this.ctx.fillStyle = color;\n      this.ctx.fillRect(x, y, 1, 1);\n      this.ctx.strokeStyle = '#0008';\n      this.ctx.lineWidth = 0.08;\n      this.ctx.strokeRect(x + 0.02, y + 0.02, 0.96, 0.96);\n    }\n\n    clear() {\n      this.ctx.fillStyle = '#111';\n      this.ctx.fillRect(0, 0, COLS, ROWS);\n    }\n\n    draw() {\n      this.clear();\n\n      // Draw grid\n      for (let y=0; y<ROWS; y++) {\n        for (let x=0; x<COLS; x++) {\n          const cell = this.grid[y][x];\n          if(cell !== null) {\n            this.drawBlock(x, y, cell);\n          }\n        }\n      }\n\n      // Draw current piece\n      const piece = this.currentPiece;\n      for (const [x, y] of piece.coords) {\n        const px = piece.position.x + x;\n        const py = piece.position.y + y;\n        if(py < 0) continue; // above visible \n        this.drawBlock(px, py, piece.color);\n      }\n    }\n  }\n\n  // Set up left and right games\n  const leftCanvas = document.querySelector('#leftGame canvas');\n  const rightCanvas = document.querySelector('#rightGame canvas');\n\n  // Controls mapping for left and right\n  // Values are functions to run on the specific game instance\n  const leftControls = {\n    'KeyW': 'rotate',\n    'KeyA': 'left',\n    'KeyS': 'softDrop',\n    'KeyD': 'right',\n  };\n\n  const rightControls = {\n    'ArrowUp': 'rotate',\n    'ArrowLeft': 'left',\n    'ArrowDown': 'softDrop',\n    'ArrowRight': 'right',\n  };\n\n  const leftGame = new TetrisGame(leftCanvas, leftControls, 'Left');\n  const rightGame = new TetrisGame(rightCanvas, rightControls, 'Right');\n\n  // Input handling\n  // Maintain sets of keys currently pressed for soft drop \n  const activeKeys = { left: new Set(), right: new Set() };\n\n  function handleKeyDown(e) {\n    if(e.repeat) return; // prevent repeat\n\n    const leftAction = leftGame.controls[e.code];\n    if(leftAction) {\n      e.preventDefault();\n      if(leftAction === 'rotate') {\n        if(!leftGame.gameOver) leftGame.rotate(1);\n      } else if(leftAction === 'left') {\n        if(!leftGame.gameOver) leftGame.move(-1);\n      } else if(leftAction === 'right') {\n        if(!leftGame.gameOver) leftGame.move(1);\n      } else if(leftAction === 'softDrop') {\n        if(!leftGame.gameOver) leftGame.softDrop(true);\n        activeKeys.left.add(e.code);\n      }\n    }\n\n    const rightAction = rightGame.controls[e.code];\n    if(rightAction) {\n      e.preventDefault();\n      if(rightAction === 'rotate') {\n        if(!rightGame.gameOver) rightGame.rotate(1);\n      } else if(rightAction === 'left') {\n        if(!rightGame.gameOver) rightGame.move(-1);\n      } else if(rightAction === 'right') {\n        if(!rightGame.gameOver) rightGame.move(1);\n      } else if(rightAction === 'softDrop') {\n        if(!rightGame.gameOver) rightGame.softDrop(true);\n        activeKeys.right.add(e.code);\n      }\n    }\n  }\n\n  function handleKeyUp(e) {\n    const leftAction = leftGame.controls[e.code];\n    if(leftAction === 'softDrop') {\n      activeKeys.left.delete(e.code);\n      if(activeKeys.left.size === 0) {\n        leftGame.softDrop(false);\n      }\n    }\n    const rightAction = rightGame.controls[e.code];\n    if(rightAction === 'softDrop') {\n      activeKeys.right.delete(e.code);\n      if(activeKeys.right.size === 0) {\n        rightGame.softDrop(false);\n      }\n    }\n  }\n\n  window.addEventListener('keydown', handleKeyDown);\n  window.addEventListener('keyup', handleKeyUp);\n\n  // Game loop\n  let lastTime = 0;\n  function update(time=0) {\n    const deltaTime = time - lastTime;\n    lastTime = time;\n\n    leftGame.update(deltaTime);\n    rightGame.update(deltaTime);\n\n    leftGame.draw();\n    rightGame.draw();\n\n    // Check game over condition - if either died => both lose\n    if(leftGame.gameOver || rightGame.gameOver) {\n      showGameOver();\n      return;\n    }\n\n    requestAnimationFrame(update);\n  }\n\n  // Game Over screen\n  const gameOverMsg = document.getElementById('gameOverMsg');\n  const gameOverText = document.getElementById('gameOverText');\n  const restartBtn = document.getElementById('restartBtn');\n\n  function showGameOver() {\n    let msg = '';\n    if(leftGame.gameOver && rightGame.gameOver) {\n      msg = 'Both games lost!';\n    } else if(leftGame.gameOver) {\n      msg = 'Left game lost! Both lose!';\n    } else if(rightGame.gameOver) {\n      msg = 'Right game lost! Both lose!';\n    } else {\n      msg = 'Game Over!';\n    }\n    gameOverText.textContent = msg;\n    gameOverMsg.style.display = 'block';\n  }\n\n  restartBtn.addEventListener('click', () => {\n    gameOverMsg.style.display = 'none';\n    leftGame.init();\n    rightGame.init();\n    lastTime = 0;\n    requestAnimationFrame(update);\n  });\n\n  // Start the game loop\n  requestAnimationFrame(update);\n})();\n</script>\n\n</body>\n</html>\n```"
    }
  ]
}