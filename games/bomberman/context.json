{
  "messages": [
    {
      "role": "user",
      "content": "write a small bomberman clone where you place bombs to eliminate enemies. spawn 4 enemies in a randomly generated maze per level. have 10 levels.\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Mini Bomberman Clone</title>\n<style>\n  * {\n    box-sizing: border-box;\n    margin: 0; padding: 0;\n  }\n  body {\n    background: #222;\n    color: #eee;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    user-select: none;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 10px;\n  }\n  h1 {\n    margin-bottom: 10px;\n  }\n  #game {\n    position: relative;\n    margin-top: 10px;\n  }\n  canvas {\n    background: #111;\n    image-rendering: pixelated;\n    border: 2px solid #555;\n  }\n  #info {\n    margin-top: 10px;\n    font-size: 14px;\n  }\n  #messages {\n    margin-top: 8px;\n    min-height: 20px;\n    height: 20px;\n    font-weight: bold;\n    color: #f44;\n  }\n  #footer {\n    margin-top: 20px;\n    font-size: 12px;\n    color: #666;\n  }\n</style>\n</head>\n<body>\n<h1>Mini Bomberman Clone</h1>\n<div id=\"game\">\n  <canvas id=\"canvas\" width=\"352\" height=\"352\"></canvas>\n</div>\n<div id=\"info\">\n  <div>Level: <span id=\"level\">1</span> &nbsp;&nbsp; Lives: <span id=\"lives\">3</span> &nbsp;&nbsp; Bombs: <span id=\"bombCount\">1</span></div>\n  <div>Use arrow keys or WASD to move, Space to place bomb</div>\n</div>\n<div id=\"messages\"></div>\n<div id=\"footer\">Made with JavaScript in a single HTML file</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n\n  // Constants\n  const TILE_SIZE = 32;\n  const MAP_COLS = 11;\n  const MAP_ROWS = 11;\n\n  // Tiles\n  const TILE_EMPTY = 0;\n  const TILE_WALL = 1;\n  const TILE_BLOCK = 2; // destructible block\n  const TILE_BOMB = 3; // placed bomb (we'll keep bomb info elsewhere too)\n  const TILE_FIRE = 4;\n\n  // Directions for movement & explosions\n  const DIRS = [\n    { x: 0, y: -1 }, // up\n    { x: 0, y: 1 },  // down\n    { x: -1, y: 0 }, // left\n    { x: 1, y: 0 },  // right\n  ];\n\n  // Game state variables\n  let map = [];\n  let player = {\n    x: 1,\n    y: 1,\n    lives: 3,\n    bombCount: 1,\n    bombPower: 2,\n    alive: true,\n  };\n  let enemies = [];\n  let bombs = [];\n  let fires = [];\n  let level = 1;\n  const MAX_LEVEL = 10;\n  let gameOver = false;\n  let win = false;\n\n  // Timing & controls\n  let keysDown = {};\n  let moveCooldown = 0; // to regulate player speed\n  const MOVE_COOLDOWN_TIME = 120; // ms between moves\n\n  // Enemy AI speed\n  const ENEMY_MOVE_INTERVAL = 800; // ms\n  let enemyMoveTimer = 0;\n\n  // Bomb timing\n  const BOMB_FUSE = 2000; // 2 seconds fuse\n  const FIRE_DURATION = 500; // fire remains half sec\n\n  const levelElem = document.getElementById('level');\n  const livesElem = document.getElementById('lives');\n  const bombCountElem = document.getElementById('bombCount');\n  const messagesElem = document.getElementById('messages');\n\n  // Images or colors for tiles and entities\n  // We'll do simple shapes/colors/patterns for everything\n\n  // Generate a maze-like map for each level\n  // Maze generation:\n  // We'll create a grid with perimeter walls, plus fixed walls in a pattern,\n  // then scatter destructible blocks randomly except near spawn.\n\n  function generateMap() {\n    // Initialize empty map\n    let newMap = new Array(MAP_ROWS);\n    for (let y = 0; y < MAP_ROWS; y++) {\n      newMap[y] = new Array(MAP_COLS).fill(TILE_EMPTY);\n    }\n\n    // Border walls\n    for(let x=0; x<MAP_COLS; x++) {\n      newMap[0][x] = TILE_WALL;\n      newMap[MAP_ROWS-1][x] = TILE_WALL;\n    }\n    for(let y=0; y<MAP_ROWS; y++) {\n      newMap[y][0] = TILE_WALL;\n      newMap[y][MAP_COLS-1] = TILE_WALL;\n    }\n\n    // Place inner fixed walls in a grid pattern (even coords)\n    for (let y = 2; y < MAP_ROWS - 2; y += 2) {\n      for (let x = 2; x < MAP_COLS - 2; x += 2) {\n        newMap[y][x] = TILE_WALL;\n      }\n    }\n\n    // Place destructible blocks randomly\n    const blockCount = 35; // adjustable number of blocks\n\n    // We'll avoid spawn positions around player and initial enemy zones\n\n    const safeZone = new Set([\n      '1,1','1,2','2,1',\n      'MAP_ROWS -2, MAP_COLS -2' // bottom right corner roughly for enemy spawn safety\n    ]);\n\n    function isSafeToPlaceBlock(x,y) {\n      // Avoid player starting area (1,1), (1,2), (2,1)\n      if ((x <= 2 && y <= 2) || (x >= MAP_COLS-3 && y >= MAP_ROWS-3)) return false;\n      // Avoid walls\n      if (newMap[y][x] !== TILE_EMPTY) return false;\n      return true;\n    }\n\n    let placed = 0;\n    while (placed < blockCount) {\n      let x = 1 + Math.floor(Math.random() * (MAP_COLS - 2));\n      let y = 1 + Math.floor(Math.random() * (MAP_ROWS - 2));\n      if (isSafeToPlaceBlock(x,y)) {\n        newMap[y][x] = TILE_BLOCK;\n        placed++;\n      }\n    }\n\n    return newMap;\n  }\n\n  // Spawn enemies in random empty positions away from player\n  function spawnEnemies() {\n    enemies = [];\n    // We want 4 enemies per level\n    let tries = 0;\n    while (enemies.length < 4 && tries < 1000) {\n      tries++;\n      let x = 1 + Math.floor(Math.random() * (MAP_COLS - 2));\n      let y = 1 + Math.floor(Math.random() * (MAP_ROWS - 2));\n      if ((x === player.x && y === player.y) || (map[y][x] !== TILE_EMPTY)) continue;\n      // Avoid placing too close to player start\n      if (Math.abs(x - player.x) + Math.abs(y - player.y) < 4) continue;\n      // Also avoid enemies overlapping each other\n      if (enemies.some(e => e.x === x && e.y === y)) continue;\n      enemies.push({ x, y, alive: true, moveCooldown: 0, dir: {x:0,y:0} });\n    }\n  }\n\n  // Reset / start new level\n  function startLevel(lv) {\n    level = lv;\n    levelElem.textContent = level;\n    player.x = 1; player.y = 1;\n    player.alive = true;\n    player.bombCount = 1;\n    bombs = [];\n    fires = [];\n    gameOver = false;\n    win = false;\n    messagesElem.textContent = '';\n    map = generateMap();\n    spawnEnemies();\n    livesElem.textContent = player.lives;\n    bombCountElem.textContent = player.bombCount;\n  }\n\n  function posToPixel(x, y) {\n    return { px: x * TILE_SIZE, py: y * TILE_SIZE };\n  }\n\n  // Draw everything\n  function draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw map\n    for(let y=0; y < MAP_ROWS; y++) {\n      for(let x=0; x < MAP_COLS; x++) {\n        const tile = map[y][x];\n        const {px, py} = posToPixel(x,y);\n\n        switch(tile) {\n          case TILE_EMPTY:\n            ctx.fillStyle = '#222';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n            break;\n          case TILE_WALL:\n            ctx.fillStyle = '#555';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n            // Draw wall pattern\n            ctx.strokeStyle = '#888';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(px+6, py+6, TILE_SIZE-12, TILE_SIZE-12);\n            break;\n          case TILE_BLOCK:\n            ctx.fillStyle = '#a0522d';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n            ctx.strokeStyle = '#6b3e1a';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(px+3, py+3, TILE_SIZE-6, TILE_SIZE-6);\n            break;\n          case TILE_FIRE:\n            ctx.fillStyle = '#ff6a00';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n            // small flicker effect\n            ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';\n            ctx.beginPath();\n            ctx.arc(px + TILE_SIZE/2 + (Math.sin(Date.now()/80 + (x+y)*100)*4), py + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);\n            ctx.fill();\n            break;\n        }\n      }\n    }\n\n    // Draw bombs\n    bombs.forEach(bomb => {\n      if (!bomb.exploding) {\n        const {px, py} = posToPixel(bomb.x, bomb.y);\n        ctx.fillStyle = '#000';\n        ctx.beginPath();\n        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);\n        ctx.fill();\n        // highlight bomb fuse progress\n        const fusePercent = (bomb.fuseEnd - Date.now()) / BOMB_FUSE;\n        ctx.fillStyle = `rgba(255,0,0,${fusePercent < 0 ? 0 : fusePercent})`;\n        ctx.beginPath();\n        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3 * fusePercent, 0, Math.PI*2);\n        ctx.fill();\n      }\n    });\n\n    // Draw fires (over map)\n    // (Already drawn on tile FIRE color)\n\n    // Draw enemies\n    enemies.forEach(enemy => {\n      if (!enemy.alive) return;\n      const {px, py} = posToPixel(enemy.x, enemy.y);\n      ctx.fillStyle = '#f00';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3, TILE_SIZE/2.4, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.fillStyle = '#600';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2, py + TILE_SIZE/2.8, TILE_SIZE/4, TILE_SIZE/6, 0, 0, Math.PI*2);\n      ctx.fill();\n      // eyes\n      ctx.fillStyle = 'white';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2 - 5, py + TILE_SIZE/2 - 5, 4, 5, 0, 0, Math.PI*2);\n      ctx.ellipse(px + TILE_SIZE/2 + 5, py + TILE_SIZE/2 - 5, 4, 5, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.fillStyle = '#900';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2 - 5, py + TILE_SIZE/2 - 5, 2.5, 3, 0, 0, Math.PI*2);\n      ctx.ellipse(px + TILE_SIZE/2 + 5, py + TILE_SIZE/2 - 5, 2.5, 3, 0, 0, Math.PI*2);\n      ctx.fill();\n    });\n\n    // Draw player\n    if (player.alive) {\n      const {px, py} = posToPixel(player.x, player.y);\n      ctx.fillStyle = '#0af';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3.5, TILE_SIZE/2.2, 0, 0, Math.PI*2);\n      ctx.fill();\n      // eyes\n      ctx.fillStyle = '#ccf';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 - 5, 4, 5, 0, 0, Math.PI*2);\n      ctx.ellipse(px + TILE_SIZE/2 + 6, py + TILE_SIZE/2 - 5, 4, 5, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.ellipse(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 - 5, 1.8, 2.5, 0, 0, Math.PI*2);\n      ctx.ellipse(px + TILE_SIZE/2 + 6, py + TILE_SIZE/2 - 5, 1.8, 2.5, 0, 0, Math.PI*2);\n      ctx.fill();\n      // mouth\n      ctx.strokeStyle = '#046';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 + 6);\n      ctx.lineTo(px + TILE_SIZE/2 + 6, py + TILE_SIZE/2 + 6);\n      ctx.stroke();\n    }\n  }\n\n  // Check if a tile can be moved into\n  function canWalk(x, y) {\n    if (x < 0 || y < 0 || x >= MAP_COLS || y >= MAP_ROWS) return false;\n    if (map[y][x] === TILE_WALL) return false;\n    if (map[y][x] === TILE_BLOCK) return false;\n    // Bombs block movement\n    if (bombs.some(b => b.x === x && b.y === y && !b.exploding)) return false;\n    return true;\n  }\n\n  // Player move function, with cooldown\n  function tryMovePlayer(dx, dy) {\n    const nx = player.x + dx;\n    const ny = player.y + dy;\n    if (canWalk(nx, ny)) {\n      player.x = nx;\n      player.y = ny;\n    }\n  }\n\n  // Place bomb at player position if possible\n  function placeBomb() {\n    // max simultaneous bombs = player.bombCount\n    const activeBombs = bombs.filter(b => !b.exploding);\n    if (activeBombs.length >= player.bombCount) return;\n\n    // Check no existing bomb in same tile\n    if (bombs.some(b => b.x === player.x && b.y === player.y && !b.exploding)) return;\n\n    bombs.push({\n      x: player.x,\n      y: player.y,\n      fuseEnd: Date.now() + BOMB_FUSE,\n      exploding: false,\n      exploded: false,\n    });\n  }\n\n  // Explode bomb: produce fire and damage tiles/enemies/player\n  function explodeBomb(bomb) {\n    if (bomb.exploding) return;\n    bomb.exploding = true;\n\n    const explosionCoords = [];\n    explosionCoords.push({x: bomb.x, y: bomb.y});\n    // Explosion radius horizontally and vertically with player.bombPower range\n    for(let dir of DIRS) {\n      for(let p=1; p<=player.bombPower; p++) {\n        let tx = bomb.x + dir.x * p;\n        let ty = bomb.y + dir.y * p;\n        if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) break;\n        if (map[ty][tx] === TILE_WALL) break;\n        explosionCoords.push({x: tx, y: ty});\n        // Stop at first block encountered, break wall if destructible\n        if (map[ty][tx] === TILE_BLOCK) break;\n      }\n    }\n\n    // Create fire for FIRE_DURATION at calculated coords\n    explosionCoords.forEach(pos => {\n      fires.push({ x: pos.x, y: pos.y, expire: Date.now() + FIRE_DURATION });\n    });\n\n    // Destroy destructible blocks (turn into empty)\n    explosionCoords.forEach(({x,y})=>{\n      if (map[y][x] === TILE_BLOCK) {\n        map[y][x] = TILE_EMPTY;\n      }\n    });\n\n    // Damage enemies & player if in explosion\n    enemies.forEach(enemy => {\n      if (!enemy.alive) return;\n      if (explosionCoords.some(c => c.x === enemy.x && c.y === enemy.y)) {\n        enemy.alive = false;\n      }\n    });\n\n    if (player.alive && explosionCoords.some(c => c.x === player.x && c.y === player.y)) {\n      player.alive = false;\n      player.lives--;\n      livesElem.textContent = player.lives;\n      if (player.lives <= 0) {\n        gameOver = true;\n        messagesElem.textContent = \"GAME OVER - Press R to Restart\";\n      } else {\n        messagesElem.textContent = \"You lost a life! Respawning...\";\n        // Respawn player after short delay\n        setTimeout(() => {\n          player.alive = true;\n          player.x = 1;\n          player.y = 1;\n          messagesElem.textContent = '';\n        }, 1500);\n      }\n    }\n\n    bomb.exploded = true;\n    setTimeout(() => {\n      // Remove bomb after explosion\n      bombs = bombs.filter(b => b !== bomb);\n    }, FIRE_DURATION);\n  }\n\n  // Update fires - remove expired\n  function updateFires() {\n    const now = Date.now();\n    fires = fires.filter(f => f.expire > now);\n  }\n\n  // Update bombs - check for fuse expiration\n  function updateBombs() {\n    const now = Date.now();\n    bombs.forEach(bomb => {\n      if (!bomb.exploding && bomb.fuseEnd <= now) {\n        explodeBomb(bomb);\n      }\n    });\n  }\n\n  // Enemy AI pathfinding and movement:\n  // Very basic: random directions that do not collide with walls or bombs\n  // If enemy gets stuck, it tries another direction in next tick\n\n  function enemyCanMove(x,y) {\n    if (x < 0 || y < 0 || x >= MAP_COLS || y >= MAP_ROWS) return false;\n    if (map[y][x] === TILE_WALL) return false;\n    if (map[y][x] === TILE_BLOCK) return false;\n    if (bombs.some(b => b.x === x && b.y === y && !b.exploding)) return false;\n    // Also can't move onto other enemies\n    if (enemies.some(e => e.x === x && e.y === y && e.alive)) return false;\n    // Player doesn't block enemy movement (for challenge)\n    return true;\n  }\n\n  function updateEnemies(dt) {\n    enemyMoveTimer += dt;\n    if (enemyMoveTimer < ENEMY_MOVE_INTERVAL) return;\n    enemyMoveTimer = 0;\n\n    enemies.forEach(enemy => {\n      if (!enemy.alive) return;\n      // Pick direction if dir is 0 or blocked\n      let nx = enemy.x + enemy.dir.x;\n      let ny = enemy.y + enemy.dir.y;\n      if (!enemyCanMove(nx, ny)) {\n        // Pick new random direction\n        const possibleDirs = DIRS.filter(d => enemyCanMove(enemy.x + d.x, enemy.y + d.y));\n        if (possibleDirs.length > 0) {\n          enemy.dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];\n          enemy.x += enemy.dir.x;\n          enemy.y += enemy.dir.y;\n        } else {\n          enemy.dir = {x: 0, y: 0}; // stuck\n        }\n      } else {\n        enemy.x += enemy.dir.x;\n        enemy.y += enemy.dir.y;\n      }\n    });\n  }\n\n  // Check collisions between player and enemies\n  function checkPlayerEnemyCollision() {\n    if (!player.alive) return;\n    enemies.forEach(enemy => {\n      if (!enemy.alive) return;\n      if (enemy.x === player.x && enemy.y === player.y) {\n        player.alive = false;\n        player.lives--;\n        livesElem.textContent = player.lives;\n        if (player.lives <= 0) {\n          gameOver = true;\n          messagesElem.textContent = \"GAME OVER - Press R to Restart\";\n        } else {\n          messagesElem.textContent = \"You lost a life! Respawning...\";\n          setTimeout(()=>{\n            player.alive = true;\n            player.x = 1;\n            player.y = 1;\n            messagesElem.textContent = '';\n          },1500);\n        }\n      }\n    });\n  }\n\n  // Check if level is cleared (all enemies dead)\n  function checkLevelComplete() {\n    if (enemies.every(e => !e.alive)) {\n      if (level >= MAX_LEVEL) {\n        win = true;\n        messagesElem.textContent = \"YOU WIN! Press R to Restart\";\n      } else {\n        messagesElem.textContent = \"Level Cleared! Next Level in 2s...\";\n        setTimeout(() => {\n          messagesElem.textContent = \"\";\n          startLevel(level + 1);\n        }, 2000);\n      }\n    }\n  }\n\n\n  // Main loop and time keeping\n  let lastTime = 0;\n  function loop(timestamp=0) {\n    if(!lastTime) lastTime = timestamp;\n    const delta = timestamp - lastTime;\n    lastTime = timestamp;\n\n    if (!gameOver && !win) {\n      moveCooldown -= delta;\n      if (moveCooldown < 0) moveCooldown = 0;\n\n      // Handle player input for movement\n      if (moveCooldown === 0 && player.alive) {\n        if (keysDown['ArrowUp'] || keysDown['w']) { tryMovePlayer(0, -1); moveCooldown = MOVE_COOLDOWN_TIME; }\n        else if (keysDown['ArrowDown'] || keysDown['s']) { tryMovePlayer(0, 1); moveCooldown = MOVE_COOLDOWN_TIME; }\n        else if (keysDown['ArrowLeft'] || keysDown['a']) { tryMovePlayer(-1, 0); moveCooldown = MOVE_COOLDOWN_TIME; }\n        else if (keysDown['ArrowRight'] || keysDown['d']) { tryMovePlayer(1, 0); moveCooldown = MOVE_COOLDOWN_TIME; }\n      }\n\n      updateBombs();\n      updateFires();\n      updateEnemies(delta);\n      checkPlayerEnemyCollision();\n      checkLevelComplete();\n\n      bombCountElem.textContent = player.bombCount;\n      livesElem.textContent = player.lives;\n    }\n\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Keyboard event handlers\n  window.addEventListener('keydown', e => {\n    if (gameOver || win) {\n      if (e.key === 'r' || e.key === 'R') {\n        player.lives = 3;\n        startLevel(1);\n        gameOver = false;\n        win = false;\n        messagesElem.textContent = '';\n      }\n      return;\n    }\n    keysDown[e.key] = true;\n\n    if (e.key === ' ' || e.key === 'Spacebar') {\n      placeBomb();\n      e.preventDefault();\n    }\n  });\n  window.addEventListener('keyup', e => {\n    delete keysDown[e.key];\n  });\n\n  startLevel(1);\n  requestAnimationFrame(loop);\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}