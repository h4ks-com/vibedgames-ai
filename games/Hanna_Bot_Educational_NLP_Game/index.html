<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hanna Bot Educational NLP Game - Enhanced</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1020;
      --panel: #1e1f2a;
      --text: #eae8ff;
      --muted: #b4b0d6;
      --accent: #7c9cff;
      --bot: #2e2b4a;
      --user: #2a6b3b;
      --border: #3b3b56;
      --chip: #2b2b4a;
      --green: #6ce36c;
      --pink: #ff79b1;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI"; background: radial-gradient(circle at 20% 0%, #1a1746 0%, #0b1020 60%), #0b1020; color: var(--text); }
    h1 { font-size: 1.2rem; margin: 0; font-weight: 700; }
    .app { display: grid; grid-template-columns: 340px 1fr; height: 100vh; gap: 12px; padding: 12px; position: relative; z-index: 1; }
    @media (max-width: 860px) { .app { grid-template-columns: 1fr; height: auto; } }

    .panel { background: rgba(30,31,42,0.95); border: 1px solid var(--border); border-radius: 14px; padding: 12px; box-shadow: 0 6px 16px rgba(0,0,0,0.25); }
    .sidebar { display: flex; flex-direction: column; gap: 12px; }
    .section { padding-bottom: 8px; border-bottom: 1px dashed #2a2a49; }
    .section:last-child { border-bottom: none; padding-bottom: 0; }
    .section h3 { font-size: 0.92rem; color: var(--muted); margin: 0 0 6px; }
    .stat, .questLine { font-size: 0.92rem; color: #fff; }
    .tag { display: inline-block; padding: 4px 8px; border-radius: 999px; background: var(--chip); font-size: 12px; margin-right: 6px; }

    .btn { background: linear-gradient(135deg, #5f8cff 0%, #4a7dff 60%, #2f6bff 100%); color: #fff; border: none; border-radius: 999px; padding: 9px 14px; cursor: pointer; font-weight: 700; }
    .btn.secondary { background: #1b1c2b; color: #dbe0ff; border: 1px solid #2f2f63; }
    .btn.small { padding: 6px 10px; font-size: 12px; }

    .chat { display: flex; flex-direction: column; height: calc(100vh - 24px); overflow: hidden; position: relative; }
    .chatHeader { display: flex; align-items: center; gap: 8px; padding: 10px; border-radius: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(235,238,255,0.8)); border: 1px solid var(--border); }
    .avatar { width: 28px; height: 28px; background: #4a90e2; border-radius: 6px; }
    .chatArea { display: flex; flex-direction: column; height: calc(100% - 72px); margin-top: 8px; padding: 6px; gap: 8px; overflow: hidden; }
    #messages { overflow-y: auto; padding: 10px; border: 1px solid var(--border); border-radius: 8px; min-height: 60px; background: #0b1220; }

    .message { display: flex; gap: 8px; margin: 8px 0; max-width: 78%; }
    .message.user { justify-content: flex-end; }
    .bubble { padding: 10px 14px; border-radius: 14px; line-height: 1.4; background: #1f2a50; border: 1px solid #2b3a8f; color: #e9eaff;
      opacity: 0; transform: translateY(6px); transition: all 0.25s ease;
    }
    .bubble.visible { opacity: 1; transform: translateY(0); }
    .message.user .bubble { background: linear-gradient(135deg, #1d5f2a, #2d8f2c); border: 1px solid #3a9a2a; color: #eaffea; }

    .inputBar { display: flex; gap: 8px; padding: 8px; border: 1px solid var(--border); border-radius: 8px; background: #111428; align-items: center; }
    #userInput { flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 14px; background: #0b1020; color: #e6e7ff; }
    #sendBtn { padding: 10px 14px; border-radius: 6px; border: none; background: #6a89ff; color: #fff; font-weight: 700; cursor: pointer; }

    /* Settings modal */
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.55); z-index: 1000; }
    .modal.open { display: flex; }
    .modalCard { width: min(640px, 92%); background: #1a1b2e; border-radius: 12px; padding: 16px; border: 1px solid #3a3a70; box-shadow: 0 8px 28px rgba(0,0,0,0.5); }
    .modalCard h2 { margin: 0 0 10px; font-size: 1.1rem; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 8px 0; border-bottom: 1px dotted #333; }
    .row:last-child { border-bottom: none; }
    .label { font-size: 14px; color: #e8eaff; }
    .value { font-size: 14px; }

    /* Background and particle effects */
    canvas#bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; display: block; }
    .confetti { position: fixed; pointer-events: none; z-index: 1001; }

    @keyframes floaty {
      from { transform: translateY(0); }
      to { transform: translateY(-6px); }
    }
    .floaty { animation: floaty 0.6s ease-in-out infinite; }

    /* Animations toggle */
    body.no-anim .bubble { transition: none; animation: none; opacity: 1; transform: none; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div class="app" id="app">
    <aside class="panel sidebar" aria-label="Sidebar">
      <div class="section">
        <div class="title" id="currentQuestTitle" style="font-weight:700; font-size:1rem; color:#e8eaff;">Current Quest</div>
        <div class="stat" id="questDesc" style="color:#cbd3ff; opacity:.95;"></div>
      </div>
      <div class="section">
        <h3>Progress</h3>
        <div id="progressInfo" class="stat" style="color:#d9e0ff;"></div>
        <div style="margin-top:6px;">
          <span class="tag" id="unlockStatus">Unlock status</span>
        </div>
      </div>
      <div class="section" aria-label="Controls">
        <button class="btn" id="settingsBtn" title="Open Settings">Settings</button>
        <button class="btn secondary" id="resetBtn" style="margin-left:8px;" title="Reset Progress">Reset Progress</button>
      </div>
      <div class="hint" style="margin-top:6px; color:#cbd3ff;">
        Tip: Ask Hanna about NLP concepts or complete tasks to earn points. Short bursts, big learning!
      </div>
    </aside>

    <section class="panel chat" aria-label="Chat with Hanna Bot" style="min-width:0;">
      <div class="chatHeader">
        <div class="avatar" aria-label="Hanna Avatar"></div>
        <div>
          <strong>Hanna Bot</strong>
          <div style="font-size:12px; color:var(--muted);">Educational NLP companion</div>
        </div>
      </div>
      <div class="chatArea" id="chatArea">
        <div id="messages" aria-live="polite"></div>
        <div class="inputBar">
          <input id="userInput" placeholder="Ask Hanna a question or answer the current task..." autocomplete="off" />
          <button id="sendBtn" class="btn" title="Send">Send</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal" aria-hidden="true" role="dialog" aria-label="Settings">
    <div class="modalCard">
      <h2>Settings</h2>
      <div class="section" style="border-bottom:1px solid #333; padding-bottom:12px;">
        <div class="row">
          <span class="label">Background Animations</span>
          <input type="checkbox" id="optBackground" />
        </div>
        <div class="row">
          <span class="label">Message Animations</span>
          <input type="checkbox" id="optMessages" checked />
        </div>
        <div class="row">
          <span class="label">Show Hints</span>
          <input type="checkbox" id="optHints" checked />
        </div>
        <div class="row">
          <span class="label">Sound on events</span>
          <input type="checkbox" id="optSound" checked />
        </div>
        <div class="row">
          <span class="label">Difficulty</span>
          <select id="optDifficulty" aria-label="Difficulty">
            <option value="Easy">Easy</option>
            <option value="Medium" selected>Medium</option>
            <option value="Hard">Hard</option>
          </select>
        </div>
      </div>
      <div style="text-align:right; padding-top:8px;">
        <button class="btn" id="closeSettings">Close</button>
      </div>
    </div>
  </div>

  <script>
    // Data model: Quests and tasks
    const SCENARIOS = [
      {
        id: 'tokenization',
        title: 'Tokenization Basics',
        description: 'Learn how tokenization splits text into tokens such as words or punctuation.',
        tasks: [
          { id: 't1', type: 'tokens', instruction: "Task 1: Tokenize the sentence 'Hanna Bot explains NLP' into words separated by spaces. List the tokens in order.", expectedTokens: ['Hanna','Bot','explains','NLP'], points: 10 },
          { id: 't2', type: 'keywords', instruction: "Task 2: What is tokenization in NLP? Provide a brief definition using terms like 'split', 'text', and 'tokens'.", expectedKeywords: ['split','text','tokens'], points: 10 }
        ]
      },
      {
        id: 'sentiment',
        title: 'Sentiment Basics',
        description: 'Learn how sentiment is detected in text.',
        tasks: [
          { id: 's1', type: 'options', instruction: "Task 1: Identify sentiment of 'I love learning NLP'. Respond with 'positive' or 'negative'.", expectedOptions: ['positive','negative'], points: 10 },
          { id: 's2', type: 'explanation', instruction: "Task 2: What is a sentiment score? Explain briefly.", expectedKeywords: ['score','sentiment'], points: 10 }
        ]
      }
    ];

    const STATE_KEY = 'hanna_state_v2';
    const SETTINGS_KEY = 'hanna_settings_v2';
    let state = {
      activeQuestIndex: 0,
      questProgress: {},
      totalScore: 0,
    };
    let settings = {
      animations: true,
      sound: true,
      hints: true,
      difficulty: 'Medium',
      background: true
    };

    // DOM elements
    const messagesEl = document.getElementById('messages');
    const userInputEl = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const resetBtn = document.getElementById('resetBtn');
    const currentQuestTitleEl = document.getElementById('currentQuestTitle');
    const questDescEl = document.getElementById('questDesc');
    const progressInfoEl = document.getElementById('progressInfo');
    const unlockStatusEl = document.getElementById('unlockStatus');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeSettings = document.getElementById('closeSettings');
    const optBackground = document.getElementById('optBackground');
    const optMessages = document.getElementById('optMessages');
    const optHints = document.getElementById('optHints');
    const optSound = document.getElementById('optSound');
    const optDifficulty = document.getElementById('optDifficulty');
    const bgCanvas = document.getElementById('bg');
    let bgCtx;
    let stars = [];
    let lastTime = 0;
    let rafId = 0;
    let confettiLayer = null;

    // Helpers
    function loadState() {
      try {
        const raw = localStorage.getItem(STATE_KEY);
        if (raw) state = JSON.parse(raw);
      } catch (e) { /* ignore */ }
      // ensure keys exist
      SCENARIOS.forEach(q => {
        if (!state.questProgress[q.id]) {
          state.questProgress[q.id] = { currentTaskIndex: 0, completed: false, score: 0, completedTasks: [] };
        }
      });
      saveState();
    }
    function saveState() {
      localStorage.setItem(STATE_KEY, JSON.stringify(state));
    }
    function resetState() {
      localStorage.removeItem(STATE_KEY);
      state = {
        activeQuestIndex: 0,
        questProgress: {},
        totalScore: 0
      };
      SCENARIOS.forEach(q => {
        state.questProgress[q.id] = { currentTaskIndex: 0, completed: false, score: 0, completedTasks: [] };
      });
      saveState();
      // refresh UI
      renderHeader();
      renderProgress();
      messagesEl.innerHTML = '';
      bootstrapIntro();
    }

    // Settings persistence
    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (raw) settings = JSON.parse(raw);
      } catch (e) { /* ignore */ }
      // apply
      optBackground.checked = !!settings.background;
      optMessages.checked = !!settings.animations; // reuse same toggle for simplicity, but separate if desired
      optHints.checked = !!settings.hints;
      optSound.checked = !!settings.sound;
      optDifficulty.value = settings.difficulty;
      applySettingsUI();
    }
    function saveSettings() {
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }
    function applySettingsUI() {
      if (settings.background && bgCanvas) { startStarfield(); } else { stopStarfield(); }
      if (settings.animations) { document.body.classList.remove('no-anim'); } else { document.body.classList.add('no-anim'); }
      if (!settings.sound) { stopAllSounds(); }
      // difficulty affects later scoring
    }

    // Starfield background
    function initCanvas() {
      bgCtx = bgCanvas.getContext('2d');
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    function resizeCanvas() {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
    }
    function startStarfield() {
      if (stars.length > 0) return;
      const count = Math.min(240, Math.floor(window.innerWidth / 6));
      for (let i=0;i<count;i++) {
        stars.push({
          x: Math.random()*window.innerWidth,
          y: Math.random()*window.innerHeight,
          z: Math.random()*1 + 0.5,
          speed: Math.random()*0.6 + 0.2,
          color: `hsla(${Math.floor(Math.random()*360)}, 80%, 70%, ${0.8 + Math.random()*0.2})`
        });
      }
      if (!rafId) animateStars();
    }
    function stopStarfield() {
      stars = [];
      if (rafId) cancelAnimationFrame(rafId);
      rafId = 0;
      if (bgCtx) bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
    }
    function animateStars(ts) {
      if (!lastTime) lastTime = ts;
      const dt = Math.min(32, ts - lastTime);
      lastTime = ts;
      const w = window.innerWidth, h = window.innerHeight;
      bgCtx.clearRect(0,0,w,h);
      for (let s of stars) {
        s.y += s.speed;
        if (s.y > h) { s.y = 0; s.x = Math.random()*w; }
        const r = Math.max(1, Math.floor(1.5 * s.z));
        bgCtx.fillStyle = s.color;
        bgCtx.fillRect(s.x, s.y, r, r);
      }
      rafId = requestAnimationFrame(animateStars);
    }

    // Confetti
    function createConfetti(x, y) {
      if (!confettiLayer) {
        confettiLayer = document.createElement('div');
        confettiLayer.className = 'confetti';
        document.body.appendChild(confettiLayer);
      }
      const colors = ['#ffd34a', '#ff6b6b', '#6b87ff', '#7dffa0', '#f472e5', '#38bdf8'];
      const count = 60;
      for (let i=0; i<count; i++) {
        const piece = document.createElement('div');
        piece.style.position = 'absolute';
        piece.style.left = (x + (Math.random()*40 - 20)) + 'px';
        piece.style.top = (y) + 'px';
        piece.style.width = (6 + Math.random()*6) + 'px';
        piece.style.height = (8 + Math.random()*8) + 'px';
        piece.style.background = colors[Math.floor(Math.random()*colors.length)];
        piece.style.transform = `rotate(${Math.random()*360}deg)`;
        piece.style.borderRadius = '2px';
        piece.style.pointerEvents = 'none';
        piece.style.opacity = '1';
        // motion via CSS variable
        const dx = (Math.random()*200 - 100);
        const dy = (120 + Math.random()*120);
        piece.style.setProperty('--dx', dx+'px');
        piece.style.setProperty('--dy', dy+'px');
        piece.style.setProperty('--rot', (Math.random()*360) + 'deg');
        piece.style.transition = 'transform 2s ease-out, opacity 2s ease-out';
        confettiLayer.appendChild(piece);
        requestAnimationFrame(() => {
          piece.style.transform = `translate(${dx}px, ${dy}px) rotate(${Math.random()*720}deg)`;
          piece.style.opacity = '0';
        });
        // cleanup
        setTimeout(() => {
          try { confettiLayer.removeChild(piece); } catch (e) {}
        }, 2100);
      }
      // cleanup layer if empty after a moment
      setTimeout(() => {
        if (confettiLayer && confettiLayer.childElementCount === 0) {
          confettiLayer.remove();
          confettiLayer = null;
        }
      }, 2500);
    }

    // Audio (Web Audio API)
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (AudioCtx) audioCtx = new AudioCtx();
      }
      return !!audioCtx;
    }
    function playTone(freq=440, duration=0.15, type='sine') {
      if (!settings.sound || !ensureAudio()) return;
      const ctx = audioCtx;
      if (!ctx) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.connect(g);
      g.connect(ctx.destination);
      const now = ctx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
    }
    function stopAllSounds() {
      if (audioCtx && audioCtx.state !== 'closed') {
        // naive pause
        audioCtx.suspend();
      }
    }

    // Helpers to tokenize and evaluate
    function tokenize(text) {
      return text.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/).filter(Boolean);
    }
    function evaluateTask(task, userInput) {
      if (!task) return false;
      const input = userInput.trim();
      if (task.expectedTokens) {
        const inputL = tokenize(input);
        const expectedLower = task.expectedTokens.map(t => t.toLowerCase());
        const ok = expectedLower.every(exp => inputL.includes(exp));
        return ok;
      }
      if (task.expectedKeywords) {
        const lower = input.toLowerCase();
        return task.expectedKeywords.every(kw => lower.includes(kw.toLowerCase()));
      }
      if (task.expectedOptions) {
        const lower = input.toLowerCase().trim();
        return task.expectedOptions.map(o => o.toLowerCase()).includes(lower);
      }
      return false;
    }
    function explainNLPTopic(text) {
      const t = text.toLowerCase();
      if (t.includes('tokenization')) {
        return "Tokenization splits text into meaningful units called tokens (e.g., words, punctuation). Example: 'Hello, world!' → ['Hello', ',', 'world', '!'] or ['Hello','world'] depending on rules.";
      }
      if (t.includes('sentiment') || t.includes('emotion')) {
        return "Sentiment analysis detects attitude (positive/negative/neutral). A sentiment score quantifies this attitude on a scale.";
      }
      if (t.includes('token')) {
        return "A token is a unit of text used in NLP (usually a word or punctuation). Tokenization splits text into tokens.";
      }
      return "NLP helps computers understand human language. Ask me to explain a term with a simple example.";
    }

    // UI render
    function renderHeader() {
      const q = SCENARIOS[state.activeQuestIndex];
      currentQuestTitleEl.textContent = q ? q.title : 'All Quests Complete';
      questDescEl.textContent = q ? q.description : 'You have completed all quests. Great job!';
    }
    function renderProgress() {
      const q = SCENARIOS[state.activeQuestIndex];
      const progress = q ? state.questProgress[q.id] : null;
      if (q && progress) {
        const total = q.tasks.length;
        const current = progress.currentTaskIndex + 1;
        progressInfoEl.textContent = `Task ${current} of ${total} • Score: ${state.totalScore}`;
      } else {
        progressInfoEl.textContent = '';
      }
      const nextIndex = state.activeQuestIndex + 1;
      if (SCENARIOS[nextIndex]) {
        unlockStatusEl.textContent = 'Next quest unlocked: ' + SCENARIOS[nextIndex].title;
      } else {
        unlockStatusEl.textContent = 'All quests unlocked';
      }
    }

    // Message UI
    function addMessage(sender, text) {
      const msg = document.createElement('div');
      msg.className = 'message ' + (sender === 'user' ? 'user' : 'bot');
      const bubble = document.createElement('div');
      bubble.className = 'bubble' + (settings?.animations ? '' : ''); // will handle via class
      bubble.textContent = text;
      msg.appendChild(bubble);
      messagesEl.appendChild(msg);
      // reveal
      if (settings.animations) {
        setTimeout(() => bubble.classList.add('visible'), 20);
      } else {
        bubble.classList.add('visible');
        // ensure immediate visibility
      }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Intro
    function bootstrapIntro() {
      const q = SCENARIOS[state.activeQuestIndex];
      if (!q) {
        addMessage('bot', "You've completed all quests. Thanks for playing Hanna Bot!");
        return;
      }
      const t0 = state.questProgress[q.id]?.currentTaskIndex ?? 0;
      const firstTask = q.tasks[t0];
      if (firstTask) {
        addMessage('bot', firstTask.instruction);
      } else {
        addMessage('bot', "Explore the quest tasks and learn NLP concepts!");
      }
    }

    // Processing
    function processUserInput(input) {
      if (!input || input.trim().length === 0) return;
      addMessage('user', input);
      const q = SCENARIOS[state.activeQuestIndex];
      const progress = q ? state.questProgress[q.id] : null;
      const currentTaskIndex = progress ? progress.currentTaskIndex : 0;
      const currentTask = q?.tasks[currentTaskIndex];

      // Question helper
      const isQuestion = input.trim().endsWith('?') || input.toLowerCase().includes('what') || input.toLowerCase().includes('how') || input.includes('?');
      if (isQuestion) {
        const explanation = explainNLPTopic(input);
        addMessage('bot', explanation);
        if (settings.sound) playTone(520, 0.25, 'triangle');
        saveState();
        return;
      }

      if (currentTask) {
        const ok = evaluateTask(currentTask, input);
        if (ok) {
          // determine difficulty multiplier
          const diff = settings.difficulty;
          const mul = diff === 'Easy' ? 1.0 : diff === 'Medium' ? 1.25 : 1.5;
          const earned = Math.max(5, Math.round((currentTask.points ?? 5) * mul));
          state.totalScore += earned;
          progress.score = (progress.score ?? 0) + earned;
          progress.completedTasks = progress.completedTasks || [];
          progress.completedTasks.push(currentTask.id);
          // success text + next task or quest completion
          addMessage('bot', `Excellent! You earned ${earned} points for ${currentTask.id}.`);
          if (settings.sound) playTone(880, 0.15, 'sine');
          const nextIndex = (progress.currentTaskIndex ?? 0) + 1;
          if (q && nextIndex < q.tasks.length) {
            progress.currentTaskIndex = nextIndex;
            setTimeout(() => addMessage('bot', q.tasks[nextIndex].instruction), 200);
          } else {
            // Quest complete
            progress.completed = true;
            addMessage('bot', `Great job! You completed the quest: ${q.title}.`);
            // Confetti
            if (settings.background) createConfetti(window.innerWidth/2, 120);
            // Unlock next quest
            if (state.activeQuestIndex < SCENARIOS.length - 1) {
              state.activeQuestIndex += 1;
              const next = SCENARIOS[state.activeQuestIndex];
              addMessage('bot', `New quest unlocked: ${next.title}. ${next.description}`);
              if (!state.questProgress[next.id]) {
                state.questProgress[next.id] = { currentTaskIndex: 0, completed: false, score: 0, completedTasks: [] };
              }
              const firstTask = next.tasks[0];
              if (firstTask) addMessage('bot', `Task for ${next.title}: ${firstTask.instruction}`);
            } else {
              addMessage('bot', "You have completed all available quests. Thanks for playing!");
            }
          }
        } else {
          const hint = settings.hints ? generateHintForTask(currentTask) : "Incorrect. Try again or ask for a hint by asking a NLP question.";
          addMessage('bot', hint);
        }
      } else {
        addMessage('bot', "You're not on a current task. Try starting the next quest or ask about NLP concepts to learn more.");
      }
      saveState();
    }

    function generateHintForTask(task) {
      if (task.expectedTokens) {
        return "Hint: List tokens in the sentence in order, separated by spaces. Try: 'Hanna Bot explains NLP' → tokens: ['Hanna','Bot','explains','NLP']";
      }
      if (task.expectedKeywords) {
        return "Hint: Include the keywords such as: " + task.expectedKeywords.join(', ');
      }
      if (task.expectedOptions) {
        return "Hint: Answer one of the options: " + task.expectedOptions.map(o => `'${o}'`).join(', ');
      }
      return "Hint: Focus on the core NLP concept in this task.";
    }

    function pathUpdateAfterTaskSuccess() {
      // placeholder for future expansion
    }

    // Event listeners
    sendBtn.addEventListener('click', () => {
      const text = userInputEl.value;
      userInputEl.value = '';
      processUserInput(text);
      setTimeout(() => { messagesEl.scrollTop = messagesEl.scrollHeight; }, 50);
    });
    userInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendBtn.click();
      }
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('Reset all progress? This will start over.')) {
        resetState();
        // Reset UI
        messagesEl.innerHTML = '';
        bootstrapIntro();
        renderHeader();
        renderProgress();
      }
    });

    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('open');
      settingsModal.setAttribute('aria-hidden', 'false');
    });
    closeSettings.addEventListener('click', () => {
      settingsModal.classList.remove('open');
      settingsModal.setAttribute('aria-hidden', 'true');
      // save after changes
      saveSettings();
    });
    // Settings inputs
    optBackground.addEventListener('change', () => {
      settings.background = optBackground.checked;
      applySettingsUI();
      saveSettings();
    });
    optMessages.addEventListener('change', () => {
      settings.animations = optMessages.checked;
      applySettingsUI();
      saveSettings();
    });
    optHints.addEventListener('change', () => {
      settings.hints = optHints.checked;
      saveSettings();
    });
    optSound.addEventListener('change', () => {
      settings.sound = optSound.checked;
      if (settings.sound) ensureAudio();
      saveSettings();
    });
    optDifficulty.addEventListener('change', () => {
      settings.difficulty = optDifficulty.value;
      saveSettings();
    });

    // Init
    function initialize() {
      // canvas
      initCanvas();
      loadSettings();
      if (settings.background) startStarfield();
      loadState();
      renderHeader();
      renderProgress();
      bootstrapIntro();
      // start audio context suspended until user interacts
      if (settings.sound && typeof (AudioContext || webkitAudioContext) !== 'undefined') {
        ensureAudio();
      }
      // ensure confetti layer
      confettiLayer = null;
    }

    // Start
    window.addEventListener('load', initialize);

    // Utilities
    function renderHeader() {
      const q = SCENARIOS[state.activeQuestIndex];
      currentQuestTitleEl.textContent = q ? q.title : 'All Quests Complete';
      questDescEl.textContent = q ? q.description : 'You have completed all quests. Great job!';
    }
    function renderProgress() {
      const q = SCENARIOS[state.activeQuestIndex];
      const prog = q ? state.questProgress[q.id] : null;
      if (q && prog) {
        const total = q.tasks.length;
        const current = (prog.currentTaskIndex ?? 0) + 1;
        progressInfoEl.textContent = `Task ${current} of ${total} • Score: ${state.totalScore}`;
      } else {
        progressInfoEl.textContent = '';
      }
      const nextIndex = state.activeQuestIndex + 1;
      if (SCENARIOS[nextIndex]) unlockStatusEl.textContent = 'Next quest unlocked: ' + SCENARIOS[nextIndex].title;
      else unlockStatusEl.textContent = 'All quests unlocked';
    }

    // Intro on first load
    function bootstrap() {
      renderHeader();
      renderProgress();
      bootstrapIntro();
    }

    function bootstrapIntroOnce() {
      // placeholder in case of re-entry
    }

    // Make sure to re-run after settings load
    function ensureReady() { /* reserved */ }

  </script>
</body>
</html>