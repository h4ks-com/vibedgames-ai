<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galaxy Explorer: Enhanced Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <!-- Post-processing -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: #ddd;
    }
    #canvasContainer { width: 100%; height: 100%; display: block; }
    #hud {
      position: absolute;
      left: 12px;
      top: 12px;
      background: rgba(0,0,0,0.5);
      padding: 12px 14px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.4;
      user-select: none;
      z-index: 10;
      min-width: 260px;
    }
    #hud h1 { margin: 0 0 8px; font-size: 14px; opacity: 0.95; }
    #hud div { margin: 2px 0; }
    #overlay {
      position: absolute;
      left: 0; right:0; top:0; bottom:0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      z-index: 20;
      color: white;
      font-size: 28px;
      text-align: center;
    }
    #overlay.show { display: flex; }
    /* Settings panel */
    #settingsPanel {
      position: absolute;
      right: 12px;
      top: 12px;
      width: 320px;
      background: rgba(15,15,25,0.92);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 12px;
      display: none;
      z-index: 15;
    }
    #settingsPanel h2 { margin: 6px 0 12px; font-size: 14px; }
    .settingRow { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
    .settingRow input[type="range"] { width: 180px; }
    .btnRow { display: flex; justify-content: space-between; margin-top: 12px; }
    .btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
    }
    .btn.primary {
      background: #2a9df4;
      border-color: #2a9df4;
    }
    /* Minimap canvas overlay (2D) */
    #minimap {
      position: absolute;
      right: 12px;
      bottom: 12px;
      width: 210px;
      height: 210px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 12px;
      z-index: 12;
      box-shadow: 0 0 16px rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <div id="hud">
    <h1>Galaxy Explorer HUD</h1>
    <div>Speed: <span id="speed">0.0</span> u/s</div>
    <div>Hull: <span id="hull">100</span>%</div>
    <div>Sector: <span id="sector">0,0,0</span></div>
    <div>Controls: W/S Thrust, Arrow Keys Pitch/Yaw, Q/E Roll, Shift Afterburner, Space to Fire</div>
    <div style="margin-top:6px;">
      <button id="settingsBtn" class="btn">Settings</button>
      <button id="pauseBtn" class="btn" title="Pause/Resume">Pause</button>
    </div>
  </div>
  <div id="overlay" aria-hidden="true">Mission Failed. Hull integrity compromised.</div>

  <canvas id="canvasContainer"></canvas>

  <canvas id="minimap" width="210" height="210" aria-label="Minimap"></canvas>

  <div id="settingsPanel" aria-hidden="true">
    <h2>Graphics & Gameplay</h2>
    <div class="settingRow">
      <span>Bloom Intensity</span>
      <input type="range" id=" bloomRange" min="0" max="2" step="0.05" value="1.0" />
    </div>
    <div class="settingRow">
      <span>Particle Size</span>
      <input type="range" id="particleSize" min="0.5" max="2" step="0.1" value="1.0" />
    </div>
    <div class="settingRow">
      <span>Galaxy Radius</span>
      <input type="range" id="galaxyRadius" min="5000" max="18000" step="100" value="9000" />
    </div>
    <div class="btnRow">
      <button id="applySettings" class="btn primary">Apply</button>
      <button id="closeSettings" class="btn">Close</button>
    </div>
  </div>

  <script>
    // Enhanced Galaxy Explorer: Vanilla JS + Three.js

    // Scene setup
    const canvas = document.getElementById('canvasContainer');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClear = false;

    // Scene and camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0004);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
    camera.position.set(0, 6, 18);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
    scene.add(ambientLight);
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(-1, 0.5, -0.2);
    scene.add(sun);

    // Post-processing (Bloom)
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
    bloomPass.threshold = 0.9;
    bloomPass.strength = 0.9;
    bloomPass.radius = 0.8;
    composer.addPass(bloomPass);

    // World constants (dynamic via settings)
    let GALAXY_RADIUS = 9000;
    let STAR_COUNT = 30000;
    const ARMS = 4;
    const SPIN = 0.25;

    // Star field (procedural)
    function createStarTexture() {
      const size = 64;
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const g = c.getContext('2d');
      const radGrad = g.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      radGrad.addColorStop(0.0, 'rgba(255,255,255,1)');
      radGrad.addColorStop(0.3, 'rgba(200,240,255,1)');
      radGrad.addColorStop(1.0, 'rgba(0,0,0,0)');
      g.fillStyle = radGrad;
      g.fillRect(0,0,size,size);
      return new THREE.CanvasTexture(c);
    }
    const starTexture = createStarTexture();

    // Star field geometry
    const starGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(STAR_COUNT * 3);
    const colors = new Float32Array(STAR_COUNT * 3);
    for (let i = 0; i < STAR_COUNT; i++) {
      const arm = i % ARMS;
      const radius = Math.pow(Math.random(), 0.9) * GALAXY_RADIUS;
      const armAngle = (arm / ARMS) * Math.PI * 2;
      const theta = radius * SPIN + armAngle + (Math.random() * 0.3 - 0.15);
      const x = Math.cos(theta) * radius;
      const z = Math.sin(theta) * radius;
      const y = (Math.random() - 0.5) * 900;

      positions[i*3 + 0] = x;
      positions[i*3 + 1] = y;
      positions[i*3 + 2] = z;

      const tNorm = radius / GALAXY_RADIUS;
      const rCol = 0.8 * (1.0 - tNorm) + 0.2 * Math.random();
      const gCol = 0.9 * (1.0 - tNorm) + 0.2 * Math.random();
      const bCol = 1.0 * tNorm * 0.4;
      colors[i*3 + 0] = rCol;
      colors[i*3 + 1] = gCol;
      colors[i*3 + 2] = bCol;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    starGeo.computeBoundingSphere();

    const starMat = new THREE.PointsMaterial({
      size: 1.05,
      vertexColors: true,
      map: starTexture,
      transparent: true,
      opacity: 0.9,
      sizeAttenuation: true,
      depthWrite: false
    });

    const starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);

    // Parallax backdrop stars
    const parallaxCount = 600;
    const parPositions = new Float32Array(parallaxCount * 3);
    for (let i=0; i<parallaxCount; i++) {
      parPositions[i*3+0] = (Math.random() - 0.5) * 50000;
      parPositions[i*3+1] = (Math.random() - 0.5) * 50000;
      parPositions[i*3+2] = (Math.random() - 0.5) * 50000;
    }
    const parGeo = new THREE.BufferGeometry();
    parGeo.setAttribute('position', new THREE.BufferAttribute(parPositions, 3));
    const parMat = new THREE.PointsMaterial({ size: 0.6, color: 0xffffff, sizeAttenuation: true, depthWrite: false });
    const parStars = new THREE.Points(parGeo, parMat);
    parStars.frustumCulled = true;
    scene.add(parStars);

    // Nebula ambience
    const nebulaGroup = new THREE.Group();
    function addNebula(colorA, colorB, scale, pos){
      const g = new THREE.SphereGeometry(scale, 32, 16);
      const mat = new THREE.MeshPhysicalMaterial({
        color: colorA,
        emissive: colorB,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.25,
        roughness: 0.7,
        metalness: 0.1,
        side: THREE.BackSide
      });
      const n = new THREE.Mesh(g, mat);
      n.position.copy(pos);
      n.scale.set(scale*2, scale*2, scale*2);
      nebulaGroup.add(n);
    }
    addNebula(0x7a9bd7, 0x122a9b, 900, new THREE.Vector3(-2000, 0, -4000));
    addNebula(0x4a1f2f, 0x001f2f, 1200, new THREE.Vector3(4000, 600, -8000));
    scene.add(nebulaGroup);

    // Player ship
    const ship = new THREE.Object3D();
    const hullGeom = new THREE.BoxGeometry(8, 3, 20);
    const hullMat = new THREE.MeshStandardMaterial({ color: 0x8890a0, roughness: 0.6, metalness: 0.6 });
    const hull = new THREE.Mesh(hullGeom, hullMat);
    hull.castShadow = true;
    hull.receiveShadow = true;
    ship.add(hull);

    // Nose glow
    const glowGeom = new THREE.SphereGeometry(0.8, 16, 16);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.9 });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    glow.position.set(0, 0, -11);
    ship.add(glow);

    ship.position.set(0, 0, 0);
    scene.add(ship);

    // Thruster flame (particles)
    const flameGroup = new THREE.Group();
    function spawnFlame() {
      const pCount = 8;
      for (let i=0; i<pCount; i++){
        const s = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 6),
          new THREE.MeshBasicMaterial({ color: 0xff6a00, transparent: true, opacity: 0.9 }));
        s.position.set(
          (Math.random()-0.5) * 0.5,
          (Math.random()-0.5) * 0.5,
          9
        );
        s.userData = { life: 0.25 + Math.random()*0.25, vel: new THREE.Vector3( (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.2, -1.5) };
        flameGroup.add(s);
      }
      ship.add(flameGroup);
    }

    // Ship dynamics
    let velocity = new THREE.Vector3(0, 0, 0);
    let hullIntegrity = 100;
    let autopilot = false;
    const MASS = 1200;
    const DRAG = 0.02;
    const ANG_DRAG = 0.6;
    const ROT_SPEED = 1.6;
    const BASE_THRUST = 140;
    const AFTERBURN = 1.8;
    let afterburner = false;
    let speedMultiplier = 1.0;
    let shieldActive = false;

    // Input handling
    const inputState = {
      thrustForward: false,
      pitchUp: false, pitchDown: false,
      yawLeft: false, yawRight: false,
      rollLeft: false, rollRight: false
    };
    window.addEventListener('keydown', (e) => {
      switch(e.code){
        case 'KeyW': inputState.thrustForward = true; break;
        case 'KeyS': inputState.thrustForward = false; break;
        case 'ArrowUp': inputState.pitchUp = true; break;
        case 'ArrowDown': inputState.pitchDown = true; break;
        case 'ArrowLeft': inputState.yawLeft = true; break;
        case 'ArrowRight': inputState.yawRight = true; break;
        case 'KeyQ': inputState.rollLeft = true; break;
        case 'KeyE': inputState.rollRight = true; break;
        case 'Space': // fire
          tryFireBullet();
          break;
      }
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') afterburner = true;
      if (e.code === 'Escape') togglePause();
    });
    window.addEventListener('keyup', (e) => {
      switch(e.code){
        case 'KeyW': inputState.thrustForward = false; break;
        case 'ArrowUp': inputState.pitchUp = false; break;
        case 'ArrowDown': inputState.pitchDown = false; break;
        case 'ArrowLeft': inputState.yawLeft = false; break;
        case 'ArrowRight': inputState.yawRight = false; break;
        case 'KeyQ': inputState.rollLeft = false; break;
        case 'KeyE': inputState.rollRight = false; break;
        case 'ShiftLeft':
        case 'ShiftRight': afterburner = false; break;
      }
    });

    // Pause/Resume
    let paused = false;
    function togglePause(){
      paused = !paused;
      document.getElementById('overlay').style.display = paused ? 'flex' : 'none';
    }

    // Bullets
    const bullets = [];
    const bulletSpeed = 1800;
    const bulletLife = 2.0;
    function createBulletMesh(){
      const geo = new THREE.CylinderGeometry(0.08, 0.08, 6, 8);
      const mat = new THREE.MeshBasicMaterial({ color: 0x88ffff, transparent: true, opacity: 0.9 });
      const b = new THREE.Mesh(geo, mat);
      b.rotation.x = Math.PI / 2;
      b.castShadow = false;
      return b;
    }
    function tryFireBullet(){
      if (!canShoot) return;
      canShoot = false;
      setTimeout(()=> canShoot = true, 100); // 10 Hz firing
      const b = createBulletMesh();
      // position at nose
      const muzzle = new THREE.Vector3(0, 0, -11);
      muzzle.applyMatrix4(ship.matrixWorld);
      b.position.copy(muzzle);
      // velocity along ship forward
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
      b.userData = { velocity: forward.clone().multiplyScalar(bulletSpeed), life: bulletLife };
      scene.add(b);
      bullets.push(b);
    }
    let canShoot = true;

    // Asteroids (spawn)
    const AST_COUNT = 350;
    const astGeo = new THREE.IcosahedronGeometry(2, 0);
    const astMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.2 });
    const astMeshes = [];
    for (let i=0; i<AST_COUNT; i++){
      const m = new THREE.Mesh(astGeo, astMat);
      const radius = 1500 + Math.random()*7000;
      const theta = Math.random() * Math.PI * 2;
      const phi = (Math.random() - 0.5) * Math.PI/2;
      m.position.set(
        Math.cos(theta) * Math.cos(phi) * radius,
        Math.sin(phi) * radius * 0.8,
        Math.sin(theta) * Math.cos(phi) * radius
      );
      const scale = 0.8 + Math.random() * 6;
      m.scale.set(scale, scale, scale);
      m.userData = { rotSpeed: (Math.random() - 0.5) * 0.2, radius: radius };
      scene.add(m);
      astMeshes.push(m);
    }

    // Power-ups
    let powerUps = [];
    function spawnPowerUp(){
      const type = Math.random() < 0.5 ? 'speed' : 'shield';
      const pu = new THREE.Mesh(new THREE.IcosahedronGeometry(1.6, 0), new THREE.MeshBasicMaterial({ color: type==='speed'?0x8ff:'#ffd233'.replace('#','') }));
      pu.material.color.setHex(type==='speed'?0x5fe8ff:0xffdf2a);
      pu.position.set(
        (Math.random()-0.5)*8000,
        (Math.random()-0.5)*1000,
        (Math.random()-0.5)*8000
      );
      pu.userData = { type: type, life: 20 };
      scene.add(pu);
      powerUps.push(pu);
    }
    // spawn initial few
    for (let i=0;i<6;i++) spawnPowerUp();

    // HUD updates
    const speedHUD = document.getElementById('speed');
    const hullHUD = document.getElementById('hull');
    const sectorHUD = document.getElementById('sector');
    const overlay = document.getElementById('overlay');

    function updateHUD(){
      speedHUD.textContent = velocity.length().toFixed(1);
      hullHUD.textContent = Math.max(0, hullIntegrity|0);
      const sectorX = Math.floor(ship.position.x / 1000);
      const sectorY = Math.floor(ship.position.y / 1000);
      const sectorZ = Math.floor(ship.position.z / 1000);
      sectorHUD.textContent = `${sectorX},${sectorY},${sectorZ}`;
      overlay.style.display = (hullIntegrity <= 0) ? 'flex' : 'none';
    }

    // Camera behavior
    const camOffset = new THREE.Vector3(0, 6, 22);
    function updateCamera(dt){
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
      const up = new THREE.Vector3(0,1,0).applyQuaternion(ship.quaternion);
      const targetPos = ship.position.clone().add(forward.clone().multiplyScalar(-camOffset.z)).add(up.clone().multiplyScalar(camOffset.y));
      camera.position.lerp(targetPos, 0.05);
      camera.lookAt(ship.position);
    }

    // Mini-map
    const minimap = document.getElementById('minimap');
    const miniCtx = minimap.getContext('2d');
    function drawMinimap(){
      miniCtx.clearRect(0,0,minimap.width,minimap.height);
      // background grid
      miniCtx.fillStyle = 'rgba(0,0,0,0.4)';
      miniCtx.fillRect(0,0,minimap.width,minimap.height);
      miniCtx.strokeStyle = 'rgba(255,255,255,0.25)';
      miniCtx.lineWidth = 1;
      miniCtx.strokeRect(0,0,minimap.width-1,minimap.height-1);
      // scale world to minimap
      const scale = 0.02; // world to minimap
      // ship
      const sx = (ship.position.x) * scale;
      const sy = (ship.position.y) * scale;
      miniCtx.fillStyle = '#66ff88';
      miniCtx.fillRect(minimap.width/2 - 3, minimap.height/2 - 3, 6, 6);
      // asteroids
      miniCtx.fillStyle = '#888';
      astMeshes.forEach(a => {
        const x = a.position.x * scale;
        const z = a.position.z * scale;
        const dotX = minimap.width/2 + x;
        const dotY = minimap.height/2 + z;
        miniCtx.fillRect(dotX-1, dotY-1, 2, 2);
      });
      // power-ups
      miniCtx.fillStyle = '#ffdd33';
      powerUps.forEach(p=>{
        const x = p.position.x * scale;
        const z = p.position.z * scale;
        miniCtx.fillRect(minimap.width/2 + x - 1, minimap.height/2 + z - 1, 2, 2);
      });
    }

    // Audio (simple engine hum)
    let audioCtx = null;
    let engineOsc = null;
    let enginePanner = null;
    function initAudio(){
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        engineOsc = audioCtx.createOscillator();
        engineOsc.type = 'sine';
        engineOsc.frequency.value = 90;
        enginePanner = audioCtx.createPanner();
        enginePanner.panningModel = 'HRTF';
        enginePanner.distanceModel = 'exponential';
        enginePanner.refDistance = 5;
        enginePanner.maxDistance = 10000;
        enginePanner.rolloffFactor = 0.2;
        engineOsc.connect(enginePanner);
        enginePanner.connect(audioCtx.destination);
        engineOsc.start();
      } catch(e){
        console.warn("Audio init failed:", e);
      }
    }
    window.addEventListener('click', () => { initAudio(); }, { once: true });

    // Explosions
    function explode(position, color=0xffffff){
      const group = [];
      const count = 30;
      for (let i=0; i<count; i++){
        const s = new THREE.Mesh(new THREE.SphereGeometry(Math.random()*0.3+0.15,6,6),
          new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 }));
        s.position.copy(position);
        s.userData = {
          vel: new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2),
          life: 0.6 + Math.random()*0.6
        };
        scene.add(s);
        group.push(s);
      }
      explosions.push(group);
    }
    const explosions = [];

    // Settings panel
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    settingsBtn.addEventListener('click', () => {
      settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
    });
    document.getElementById('closeSettings').addEventListener('click', () => {
      settingsPanel.style.display = 'none';
    });
    // Bloom controls
    const bloomRange = document.getElementById('bloomRange');
    const particleSizeCtrl = document.getElementById('particleSize');
    const galaxyRadiusCtrl = document.getElementById('galaxyRadius');
    document.getElementById('applySettings').addEventListener('click', () => {
      const b = parseFloat(bloomRange.value);
      bloomPass.strength = b;
      const pSize = parseFloat(particleSizeCtrl.value);
      starMat.size = 1.0 * pSize;
      starGeo.attributes.position.needsUpdate = true;
      GALAXY_RADIUS = parseFloat(galaxyRadiusCtrl.value);
      // Rebuild stars with new radius for richer effect (quick re-staging)
      // For simplicity: adjust existing field subtly
      updateHUD();
      settingsPanel.style.display = 'none';
    });

    // World and physics loop
    let clock = new THREE.Clock();
    let lastTime = 0;
    function animate() {
      requestAnimationFrame(animate);
      if (paused) {
        // Still render a paused frame
        composer.render(0);
        return;
      }
      const dt = Math.min(0.033, clock.getDelta());

      // Update thruster flame
      if (afterburner) {
        if (flameGroup.children.length < 30) spawnFlame();
      }
      flameGroup.children.forEach((p) => {
        p.position.add(p.userData.vel.clone().multiplyScalar(dt * 60));
        p.userData.life -= dt;
        p.material.opacity = Math.max(0, p.material.opacity - dt * 1.0);
        if (p.userData.life <= 0) {
          p.parent.remove(p);
        }
      });
      // Remove empty groups
      flameGroup.children = flameGroup.children.filter(n => n.parent);

      // Movement
      // Compute thrust
      const thrustFactor = (inputState.thrustForward ? 1 : 0) * speedMultiplier;
      const thrust = (BASE_THRUST * (afterburner ? AFTERBURN : 1.0)) * thrustFactor * dt / (MASS * 0.001); // scaled for stability
      const forwardVec = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion);
      if (thrust > 0){
        velocity.add(forwardVec.clone().multiplyScalar(thrust));
      }

      // Rotation
      const rollInput = (inputState.rollRight ? 1 : 0) - (inputState.rollLeft ? 1 : 0);
      const yawInput  = (inputState.yawRight ? 1 : 0) - (inputState.yawLeft ? 1 : 0);
      const pitchInput = (inputState.pitchUp ? 1 : 0) - (inputState.pitchDown ? 1 : 0);
      const rotSpeed = ROT_SPEED;
      const anyRotInput = rollInput !== 0 || yawInput !== 0 || pitchInput !== 0;
      if (anyRotInput){
        ship.rotation.x += pitchInput * rotSpeed * dt;
        ship.rotation.y += yawInput * rotSpeed * dt;
        ship.rotation.z += rollInput * rotSpeed * dt;
      } else {
        ship.rotation.x *= Math.max(0.0, 1.0 - ANG_DRAG * dt);
        ship.rotation.y *= Math.max(0.0, 1.0 - ANG_DRAG * dt);
        ship.rotation.z *= Math.max(0.0, 1.0 - ANG_DRAG * dt);
      }

      // Position update
      ship.position.add(velocity.clone().multiplyScalar(dt));
      velocity.multiplyScalar(1 - DRAG * dt);

      // Wrapped world reset (keep numbers sane but maintain continuity)
      const distFromOrigin = ship.position.length();
      if (distFromOrigin > 1.3 * GALAXY_RADIUS){
        const dx = ship.position.x;
        const dy = ship.position.y;
        const dz = ship.position.z;
        const posAttr = starGeo.attributes.position;
        for (let i=0; i<STAR_COUNT; i++){
          const ix = i*3;
          posAttr.array[ix+0] -= dx;
          posAttr.array[ix+1] -= dy;
          posAttr.array[ix+2] -= dz;
        }
        posAttr.needsUpdate = true;
        const parAttr = parGeo.attributes.position;
        for (let i=0; i<parallaxCount; i++){
          parAttr.array[i*3+0] -= dx;
          parAttr.array[i*3+1] -= dy;
          parAttr.array[i*3+2] -= dz;
        }
        parAttr.needsUpdate = true;
        for (let i=0;i<AST_COUNT;i++){
          astMeshes[i].position.x -= dx;
          astMeshes[i].position.y -= dy;
          astMeshes[i].position.z -= dz;
        }
        ship.position.set(0,0,0);
        velocity.set(0,0,0);
      }

      // Spawning logic
      if (Math.random() < 0.004) spawnPowerUp();

      // Collisions: bullets vs asteroids
      for (let bi = bullets.length - 1; bi >= 0; bi--){
        const b = bullets[bi];
        b.position.add(b.userData.velocity.clone().multiplyScalar(dt * 0.6)); // slow projectile
        b.userData.life -= dt;
        if (b.userData.life <= 0){
          scene.remove(b);
          bullets.splice(bi,1);
          continue;
        }
        // check against asteroids
        for (let ai = astMeshes.length - 1; ai >= 0; ai--){
          const a = astMeshes[ai];
          const dx = b.position.x - a.position.x;
          const dy = b.position.y - a.position.y;
          const dz = b.position.z - a.position.z;
          const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
          const hitRadius = (a.scale.x * 0.5) + 0.4;
          if (dist < hitRadius){
            // destroy asteroid (randomly scaled debris burst)
            scene.remove(a);
            astMeshes.splice(ai,1);
            explode(a.position, 0xffffff);
            // bullet vanishes
            scene.remove(b);
            bullets.splice(bi,1);
            break;
          }
        }
      }

      // Hull damage with asteroids proximity
      astMeshes.forEach(a=>{
        const dx = ship.position.x - a.position.x;
        const dy = ship.position.y - a.position.y;
        const dz = ship.position.z - a.position.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        const danger = (a.scale.x * 0.9) + 6.0;
        if (dist < danger){
          hullIntegrity -= 0.04 * dt * (1 + a.scale.x * 0.1);
          velocity.add(new THREE.Vector3(-dx, -dy, -dz).normalize().multiplyScalar(0.2));
        }
      });
      if (hullIntegrity <= 0) hullIntegrity = 0;

      // Power-ups: collect
      for (let pi = powerUps.length - 1; pi >= 0; pi--){
        const pu = powerUps[pi];
        const dx = ship.position.x - pu.position.x;
        const dy = ship.position.y - pu.position.y;
        const dz = ship.position.z - pu.position.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        if (dist < 4){
          // apply effect
          if (pu.userData.type === 'speed'){
            speedMultiplier = 1.6;
            setTimeout(()=> speedMultiplier = 1.0, 8000);
          } else if (pu.userData.type === 'shield'){
            hullIntegrity = Math.min(100, hullIntegrity + 20);
          }
          scene.remove(pu);
          powerUps.splice(pi,1);
        }
      }

      // Update explosions
      for (let e = explosions.length - 1; e >= 0; e--){
        const group = explosions[e];
        let allGone = true;
        for (let j=0;j<group.length;j++){
          const m = group[j];
          m.position.add(m.userData.vel.clone().multiplyScalar(dt*60));
          m.userData.life -= dt;
          m.material.opacity = Math.max(0, m.material.opacity - dt);
          if (m.userData.life > 0) allGone = false;
        }
        if (allGone){
          group.forEach(m=>{ m.geometry.dispose(); m.material.dispose(); scene.remove(m); });
          explosions.splice(e,1);
        }
      }

      // Update camera
      updateCamera(dt);

      // Update minimap
      drawMinimap();

      // HUD
      updateHUD();

      // Render
      composer.render(dt);
    }

    // Fire once audio and loop
    window.addEventListener('load', ()=> {
      // boot
      initAudio();
    });

    // Start
    let paused = false;
    // Initialize
    [plant].forEach?.(() => {}); // placeholder minification safe

    // Resize
    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
    });

    // Init
    updateHUD();
    // Start animation
    let plant = null;
    let flameCooldown = 0;

    // Start full loop
    animate();

  </script>
</body>
</html>