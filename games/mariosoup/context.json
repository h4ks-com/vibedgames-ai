{
  "messages": [
    {
      "role": "user",
      "content": "A SuperMario level builder\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Super Mario Level Builder</title>\n<style>\n  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\n\n  * {\n    box-sizing: border-box;\n  }\n\n  body {\n    margin: 0;\n    background: #5c94fc;\n    font-family: 'Press Start 2P', cursive, monospace;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    color: #fff;\n  }\n\n  h1 {\n    margin: 0.5em 0;\n    text-align: center;\n    text-shadow: 2px 2px 0 #0008;\n  }\n\n  #app {\n    display: flex;\n    flex: 1 1 auto;\n    overflow: hidden;\n    user-select: none;\n  }\n\n  #palette {\n    width: 120px;\n    background: #324b8a;\n    border-right: 3px solid #192b50;\n    padding: 0.5em;\n    display: flex;\n    flex-direction: column;\n    gap: 0.75em;\n  }\n\n  #palette h2 {\n    font-size: 0.7rem;\n    margin: 0 0 0.5em 0;\n    text-align: center;\n  }\n\n  .tile {\n    cursor: pointer;\n    border: 3px solid transparent;\n    border-radius: 6px;\n    background: #7eb6ff;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 50px;\n    transition: border-color 0.2s;\n    user-select: none;\n  }\n  .tile.selected {\n    border-color: yellow;\n    box-shadow: 0 0 8px 2px yellow;\n  }\n\n  .tile canvas {\n    pointer-events: none;\n  }\n\n  #boardContainer {\n    flex: 1 1 auto;\n    background: #8adcff;\n    padding: 10px;\n    overflow: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  #board {\n    image-rendering: pixelated;\n    background: linear-gradient(0deg, #3aa60b 0%, #3aa60b 70%, #484848 70%, #484848 100%);\n    border: 3px solid #183000;\n    display: grid;\n    grid-template-columns: repeat(20, 32px);\n    grid-template-rows: repeat(15, 32px);\n    gap: 0;\n    user-select: none;\n  }\n\n  .cell {\n    width: 32px;\n    height: 32px;\n    background: transparent;\n    border: 1px solid #00000020;\n    position: relative;\n    cursor: pointer;\n  }\n\n  .cell:hover {\n    outline: 2px solid #fff9;\n  }\n\n  #controls {\n    background: #192b50;\n    padding: 0.6em;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 10px;\n    flex-wrap: wrap;\n  }\n\n  button {\n    cursor: pointer;\n    border: none;\n    background: #3a5bbf;\n    color: white;\n    font-family: 'Press Start 2P', monospace;\n    font-size: 0.65rem;\n    padding: 0.7em 1em;\n    border-radius: 8px;\n    box-shadow: 0 3px 0 #2c468b;\n    transition: background-color 0.2s;\n  }\n\n  button:hover {\n    background: #5882e6;\n  }\n\n  button:active {\n    box-shadow: inset 0 3px 0 #2c468b;\n  }\n\n  #exportArea {\n    width: 100%;\n    height: 80px;\n    margin-top: 0.5em;\n    font-family: monospace;\n    font-size: 0.7rem;\n    resize: none;\n    border-radius: 6px;\n    border: 2px solid #888;\n    padding: 0.5em;\n    background: #222e5b;\n    color: #a8b9e5;\n  }\n\n  @media (max-width: 600px) {\n    #app {\n      flex-direction: column;\n    }\n    #palette {\n      width: 100%;\n      display: grid;\n      grid-template-columns: repeat(5, 1fr);\n      gap: 0.5em;\n      padding: 0.5em 0.5em 0.5em 0.5em;\n      border-right: none;\n      border-bottom: 3px solid #192b50;\n    }\n    #palette h2 {\n      grid-column: 1 / -1;\n      text-align: left;\n      margin-left: 0.5em;\n    }\n    #boardContainer {\n      flex: 1 1 auto;\n      padding: 0.5em;\n      height: 350px;\n      overflow: auto;\n    }\n    #board {\n      grid-template-columns: repeat(20, 24px);\n      grid-template-rows: repeat(15, 24px);\n      width: max-content;\n      height: max-content;\n    }\n    .cell {\n      width: 24px;\n      height: 24px;\n    }\n  }\n</style>\n</head>\n<body>\n  <h1>Super Mario Level Builder</h1>\n  <div id=\"app\">\n    <nav id=\"palette\" aria-label=\"Tile Palette\">\n      <h2>Tiles</h2>\n      <!-- Tiles inserted by JS -->\n    </nav>\n    <main id=\"boardContainer\" aria-label=\"Level Board\">\n      <div id=\"board\" role=\"grid\" aria-rowcount=\"15\" aria-colcount=\"20\" tabindex=\"0\">\n        <!-- Cells inserted by JS -->\n      </div>\n    </main>\n  </div>\n  <section id=\"controls\">\n    <button id=\"clearBtn\" title=\"Clear Level\">Clear</button>\n    <button id=\"fillGroundBtn\" title=\"Fill Bottom Ground\">Fill Ground</button>\n    <button id=\"undoBtn\" title=\"Undo\">Undo</button>\n    <button id=\"redoBtn\" title=\"Redo\">Redo</button>\n    <button id=\"exportBtn\" title=\"Export Level JSON\">Export JSON</button>\n    <button id=\"importBtn\" title=\"Import Level JSON\">Import JSON</button>\n    <input type=\"file\" id=\"fileInput\" accept=\"application/json\" style=\"display:none\" />\n  </section>\n  <textarea id=\"exportArea\" readonly placeholder=\"Exported level JSON appears here...\"></textarea>\n\n<script>\n(() => {\n  // Constants\n  const ROWS = 15;\n  const COLS = 20;\n  const CELL_SIZE = 32;\n\n  // Tile definitions\n  // Each tile has an \"id\" and a \"draw\" function that paints onto a canvas given context and size.\n  const TILE_DEFS = [\n    {\n      id: 'empty',\n      name: 'Empty',\n      draw: (ctx, size) => {\n        ctx.clearRect(0, 0, size, size);\n        // Optional: draw a transparent grid or nothing\n      }\n    },\n    {\n      id: 'ground',\n      name: 'Ground',\n      draw: (ctx, size) => {\n        ctx.fillStyle = '#8B4513'; // brown block\n        ctx.fillRect(0, 0, size, size);\n        // Draw texture pattern\n        ctx.fillStyle = '#6F3E03';\n        for(let y=4; y<size; y+=6){\n          for(let x=0; x<size; x+=4){\n            ctx.fillRect(x, y, 2, 2);\n          }\n        }\n        // Dark edges\n        ctx.strokeStyle = '#562e02';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(1, 1, size-2, size-2);\n      }\n    },\n    {\n      id: 'block',\n      name: 'Brick Block',\n      draw: (ctx, size) => {\n        ctx.fillStyle = '#c1440e';\n        ctx.fillRect(0, 0, size, size);\n        ctx.strokeStyle = '#6b2b03';\n        ctx.lineWidth = 3;\n        ctx.strokeRect(2, 2, size - 4, size - 4);\n        ctx.strokeStyle = '#a0420e';\n        ctx.lineWidth = 1;\n        for(let i=5; i<size; i+=6){\n          ctx.beginPath();\n          ctx.moveTo(i, 2);\n          ctx.lineTo(i, size-2);\n          ctx.moveTo(2, i);\n          ctx.lineTo(size-2, i);\n          ctx.stroke();\n        }\n      }\n    },\n    {\n      id: 'question',\n      name: 'Question Block',\n      draw: (ctx, size) => {\n        ctx.fillStyle = '#ffd33a';\n        ctx.fillRect(0, 0, size, size);\n        ctx.strokeStyle = '#b2a523';\n        ctx.lineWidth = 3;\n        ctx.strokeRect(1, 1, size - 2, size - 2);\n        // question mark\n        ctx.fillStyle = '#7d6200';\n        ctx.font = `${size * 0.7}px monospace`;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        ctx.fillText('?', size / 2, size / 2+2);\n      }\n    },\n    {\n      id: 'pipeTop',\n      name: 'Pipe Top',\n      draw: (ctx, size) => {\n        // Green pipe top shape, pill-shaped\n        let w = size;\n        let h = size;\n        ctx.fillStyle = '#2ecc40'; // pipe green\n        ctx.strokeStyle = '#176619';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.ellipse(w/2, h/2, w/2 - 4, h/4 - 1, 0, 0, Math.PI*2);\n        ctx.fill();\n        ctx.stroke();\n\n        // Pipe body bottom half - just a darker band to help visually\n        ctx.fillStyle = '#268c33';\n        ctx.fillRect(w*0.15, h*0.7, w*0.7, h*0.3);\n        ctx.strokeRect(w*0.15, h*0.7, w*0.7, h*0.3);\n      }\n    },\n    {\n      id: 'pipeBody',\n      name: 'Pipe Body',\n      draw: (ctx, size) => {\n        ctx.fillStyle = '#27ae34';\n        ctx.fillRect(0, 0, size, size);\n        ctx.strokeStyle = '#176619';\n        ctx.lineWidth = 3;\n        ctx.strokeRect(1, 1, size - 2, size - 2);\n        // Horizontal lines for pipe detail\n        ctx.strokeStyle = '#1d4e14';\n        ctx.lineWidth = 1.5;\n        for(let y = 6; y < size; y += 8){\n          ctx.beginPath();\n          ctx.moveTo(4, y);\n          ctx.lineTo(size - 4, y);\n          ctx.stroke();\n        }\n      }\n    },\n    {\n      id: 'coin',\n      name: 'Coin',\n      draw: (ctx, size) => {\n        ctx.clearRect(0, 0, size, size);\n        let centerX = size / 2;\n        let centerY = size / 2;\n        let radius = size * 0.4;\n        let grad = ctx.createRadialGradient(centerX, centerY, radius*0.3, centerX, centerY, radius);\n        grad.addColorStop(0, '#fff3a4');\n        grad.addColorStop(1, '#f2b500');\n        ctx.fillStyle = grad;\n        ctx.beginPath();\n        ctx.ellipse(centerX, centerY, radius * 0.6, radius, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.strokeStyle = '#c18c00';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    },\n    {\n      id: 'mushroom',\n      name: 'Mushroom',\n      draw: (ctx, size) => {\n        ctx.clearRect(0, 0, size, size);\n        let centerX = size / 2;\n        let centerY = size / 2.5;\n        // Cap red\n        ctx.fillStyle = '#d22f27';\n        ctx.beginPath();\n        ctx.ellipse(centerX, centerY, size*0.4, size*0.35, 0, 0, Math.PI, true);\n        ctx.fill();\n        // White spots\n        ctx.fillStyle = '#fff';\n        let spots = [\n          {x: centerX - 10, y: centerY - 5, r: 5},\n          {x: centerX, y: centerY - 10, r: 6},\n          {x: centerX + 8, y: centerY - 5, r: 4},\n        ];\n        spots.forEach(s => {\n          ctx.beginPath();\n          ctx.ellipse(s.x, s.y, s.r, s.r*0.6, 0, 0, 2*Math.PI);\n          ctx.fill();\n        });\n\n        // Stem\n        ctx.fillStyle = '#fff5e0';\n        ctx.beginPath();\n        ctx.moveTo(centerX - size*0.2, centerY);\n        ctx.lineTo(centerX + size*0.2, centerY);\n        ctx.lineTo(centerX + size*0.15, size);\n        ctx.lineTo(centerX - size*0.15, size);\n        ctx.closePath();\n        ctx.fill();\n        ctx.strokeStyle = '#d1d1d1';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n\n        // Eyes\n        ctx.fillStyle = '#000';\n        ctx.beginPath();\n        ctx.ellipse(centerX - 5, centerY + 15, 3, 5, 0, 0, 2*Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(centerX + 5, centerY + 15, 3, 5, 0, 0, 2*Math.PI);\n        ctx.fill();\n      }\n    },\n    {\n      id: 'goomba',\n      name: 'Goomba',\n      draw: (ctx, size) => {\n        ctx.clearRect(0, 0, size, size);\n        let centerX = size / 2;\n        let baseY = size * 0.75;\n        // Body oval\n        ctx.fillStyle = '#a0522d';\n        ctx.beginPath();\n        ctx.ellipse(centerX, baseY - 5, size * 0.37, size * 0.5, 0, 0, 2 * Math.PI);\n        ctx.fill();\n\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.ellipse(centerX - 7, baseY - 25, 7, 9, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(centerX + 7, baseY - 25, 7, 9, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = '#000';\n        ctx.beginPath();\n        ctx.ellipse(centerX - 7, baseY - 25, 3, 5, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(centerX + 7, baseY - 25, 3, 5, 0, 0, 2 * Math.PI);\n        ctx.fill();\n\n        // Mouth\n        ctx.strokeStyle = '#581f10';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(centerX - 10, baseY - 5);\n        ctx.quadraticCurveTo(centerX, baseY + 15, centerX + 10, baseY - 5);\n        ctx.stroke();\n\n        // Eyebrows\n        ctx.strokeStyle = '#3e1a0e';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.moveTo(centerX - 14, baseY - 35);\n        ctx.lineTo(centerX - 4, baseY - 29);\n        ctx.moveTo(centerX + 14, baseY - 35);\n        ctx.lineTo(centerX + 4, baseY - 29);\n        ctx.stroke();\n      }\n    },\n    {\n      id: 'flagPole',\n      name: 'Flag Pole',\n      draw: (ctx, size) => {\n        ctx.clearRect(0, 0, size, size);\n        // Pole\n        ctx.fillStyle = '#331a00';\n        ctx.fillRect(size*0.4, 0, size*0.2, size);\n\n        // Flag\n        ctx.fillStyle = '#dc3522';\n        ctx.strokeStyle = '#b22a1a';\n        ctx.lineWidth = 1.5;\n        ctx.beginPath();\n        ctx.moveTo(size*0.6, size*0.15);\n        ctx.lineTo(size*0.95, size*0.1);\n        ctx.lineTo(size*0.95, size*0.3);\n        ctx.lineTo(size*0.6, size*0.35);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n      }\n    },\n  ];\n\n  // State\n  let selectedTileId = 'ground';\n  let boardData = new Array(ROWS * COLS).fill('empty');\n\n  // Undo/Redo stacks\n  let undoStack = [];\n  let redoStack = [];\n\n  // DOM elements\n  const paletteEl = document.getElementById('palette');\n  const boardEl = document.getElementById('board');\n  const exportArea = document.getElementById('exportArea');\n  const clearBtn = document.getElementById('clearBtn');\n  const fillGroundBtn = document.getElementById('fillGroundBtn');\n  const undoBtn = document.getElementById('undoBtn');\n  const redoBtn = document.getElementById('redoBtn');\n  const exportBtn = document.getElementById('exportBtn');\n  const importBtn = document.getElementById('importBtn');\n  const fileInput = document.getElementById('fileInput');\n\n  // Create a tile canvas for palette and cells\n  function createTileCanvas(tileId, size = CELL_SIZE) {\n    const canvas = document.createElement('canvas');\n    canvas.width = size;\n    canvas.height = size;\n    canvas.setAttribute('aria-label', TILE_DEFS.find(t=>t.id===tileId)?.name || tileId);\n    const ctx = canvas.getContext('2d');\n\n    let tileDef = TILE_DEFS.find(t => t.id === tileId);\n    if (!tileDef) return canvas;\n\n    tileDef.draw(ctx, size);\n    return canvas;\n  }\n\n  // Create palette UI\n  function buildPalette() {\n    // Clear existing tiles except h2\n    while (paletteEl.children.length > 1) paletteEl.removeChild(paletteEl.lastChild);\n\n    // Add tiles\n    TILE_DEFS.forEach(tile => {\n      const div = document.createElement('div');\n      div.className = 'tile';\n      div.dataset.tileId = tile.id;\n      div.tabIndex = 0;\n      div.title = tile.name;\n\n      const canvas = createTileCanvas(tile.id);\n      div.appendChild(canvas);\n      paletteEl.appendChild(div);\n\n      div.addEventListener('click', () => {\n        selectTile(tile.id);\n      });\n      div.addEventListener('keydown', e => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          selectTile(tile.id);\n        }\n      });\n    });\n\n    selectTile(selectedTileId);\n  }\n\n  function selectTile(tileId) {\n    selectedTileId = tileId;\n    paletteEl.querySelectorAll('.tile').forEach(tileDiv => {\n      if (tileDiv.dataset.tileId === tileId) {\n        tileDiv.classList.add('selected');\n        tileDiv.setAttribute('aria-pressed', 'true');\n      } else {\n        tileDiv.classList.remove('selected');\n        tileDiv.setAttribute('aria-pressed', 'false');\n      }\n    });\n  }\n\n  // Build board grid\n  function buildBoard() {\n    // Clear board\n    boardEl.innerHTML = '';\n    boardEl.style.gridTemplateColumns = `repeat(${COLS}, ${CELL_SIZE}px)`;\n    boardEl.style.gridTemplateRows = `repeat(${ROWS}, ${CELL_SIZE}px)`;\n\n    for(let r=0; r<ROWS; r++) {\n      for(let c=0; c<COLS; c++) {\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        cell.dataset.row = r;\n        cell.dataset.col = c;\n        cell.setAttribute('role', 'gridcell');\n        cell.tabIndex = -1;\n\n        // fill tile canvas inside cell\n        updateCell(cell, r, c);\n\n        cell.addEventListener('click', () => {\n          setCell(r, c, selectedTileId);\n        });\n\n        cell.addEventListener('keydown', e => {\n          // Allow keyboard editing\n          if (e.key === 'Enter' || e.key === ' ') {\n            setCell(r, c, selectedTileId);\n            e.preventDefault();\n          } else if (e.key === 'ArrowRight') {\n            // Navigate right\n            let nr = r;\n            let nc = c + 1;\n            if (nc >= COLS) {\n              nr = (r + 1) % ROWS;\n              nc = 0;\n            }\n            focusCell(nr, nc);\n            e.preventDefault();\n          } else if (e.key === 'ArrowLeft') {\n            let nr = r;\n            let nc = c - 1;\n            if (nc < 0) {\n              nr = (r - 1 + ROWS) % ROWS;\n              nc = COLS -1;\n            }\n            focusCell(nr, nc);\n            e.preventDefault();\n          } else if (e.key === 'ArrowDown') {\n            let nr = (r + 1) % ROWS;\n            focusCell(nr, c);\n            e.preventDefault();\n          } else if (e.key === 'ArrowUp') {\n            let nr = (r - 1 + ROWS) % ROWS;\n            focusCell(nr, c);\n            e.preventDefault();\n          }\n        });\n\n        boardEl.appendChild(cell);\n      }\n    }\n  }\n  function focusCell(row, col) {\n    const idx = row * COLS + col;\n    const cell = boardEl.children[idx];\n    if (cell) {\n      cell.focus();\n    }\n  }\n  // Update a single cell tile graphics\n  function updateCell(cell, row, col) {\n    let idx = row * COLS + col;\n    let tileId = boardData[idx];\n    // Remove old canvas if any\n    while(cell.firstChild) cell.removeChild(cell.firstChild);\n    if (tileId !== 'empty') {\n      const canvas = createTileCanvas(tileId);\n      cell.appendChild(canvas);\n    } else {\n      // Just empty cell with border\n    }\n  }\n\n  // Set the tile of a cell and push the change for undo\n  function setCell(row, col, tileId) {\n    const idx = row * COLS + col;\n    const oldTile = boardData[idx];\n    if (oldTile !== tileId) {\n      pushUndo([{row, col, oldTile, newTile: tileId}]);\n      boardData[idx] = tileId;\n      const cell = boardEl.children[idx];\n      updateCell(cell, row, col);\n      redoStack.length = 0; // clear redo stack after new action\n    }\n  }\n\n  // Clear entire board and push undo\n  function clearBoard() {\n    const changes = [];\n    for(let i=0; i<boardData.length; i++) {\n      if (boardData[i] !== 'empty') {\n        changes.push({\n          row: Math.floor(i / COLS),\n          col: i % COLS,\n          oldTile: boardData[i],\n          newTile: 'empty'\n        });\n        boardData[i] = 'empty';\n      }\n    }\n    if(changes.length > 0) {\n      pushUndo(changes);\n      renderBoard();\n      redoStack.length = 0;\n    }\n  }\n\n  // Fill bottom row(s) ground blocks and push undo\n  // Usually ground is the bottom 2-3 rows of the level\n  function fillGround() {\n    const changes = [];\n    const rowsToFill = [ROWS-1, ROWS-2];\n    rowsToFill.forEach(r => {\n      for(let c=0; c<COLS; c++) {\n        let idx = r * COLS + c;\n        if (boardData[idx] !== 'ground') {\n          changes.push({row: r, col: c, oldTile: boardData[idx], newTile: 'ground'});\n          boardData[idx] = 'ground';\n        }\n      }\n    });\n    if (changes.length > 0) {\n      pushUndo(changes);\n      renderBoard();\n      redoStack.length = 0;\n    }\n  }\n\n  // Render entire board (update all cells)\n  function renderBoard() {\n    for(let r=0; r<ROWS; r++) {\n      for(let c=0; c<COLS; c++) {\n        let cell = boardEl.children[r * COLS + c];\n        updateCell(cell, r, c);\n      }\n    }\n  }\n\n  // Undo/Redo\n\n  function pushUndo(changes) {\n    undoStack.push(changes);\n    if(undoStack.length > 100) undoStack.shift(); // keep max 100\n    updateUndoRedoButtons();\n  }\n\n  function undo() {\n    if(undoStack.length === 0) return;\n    const changes = undoStack.pop();\n    const redoChanges = [];\n    changes.forEach(({row, col, oldTile, newTile}) => {\n      let idx = row * COLS + col;\n      redoChanges.push({row, col, oldTile: boardData[idx], newTile: oldTile});\n      boardData[idx] = oldTile;\n    });\n    redoStack.push(redoChanges);\n    renderBoard();\n    updateUndoRedoButtons();\n  }\n\n  function redo() {\n    if(redoStack.length === 0) return;\n    const changes = redoStack.pop();\n    const undoChanges = [];\n    changes.forEach(({row, col, oldTile, newTile}) => {\n      let idx = row * COLS + col;\n      undoChanges.push({row, col, oldTile: boardData[idx], newTile: newTile});\n      boardData[idx] = newTile;\n    });\n    undoStack.push(undoChanges);\n    renderBoard();\n    updateUndoRedoButtons();\n  }\n\n  function updateUndoRedoButtons() {\n    undoBtn.disabled = undoStack.length === 0;\n    redoBtn.disabled = redoStack.length === 0;\n  }\n\n  // Export level to JSON string\n  function exportLevel() {\n    const exportObj = {\n      rows: ROWS,\n      cols: COLS,\n      tiles: boardData\n    };\n    return JSON.stringify(exportObj, null, 2);\n  }\n\n  // Import level JSON string\n  function importLevel(jsonStr) {\n    try {\n      const obj = JSON.parse(jsonStr);\n      if (typeof obj !== 'object' || !Array.isArray(obj.tiles)) {\n        alert('Invalid level format.');\n        return false;\n      }\n      if (obj.rows !== ROWS || obj.cols !== COLS) {\n        alert(`Level size mismatch. Expected ${COLS}x${ROWS}.`);\n        return false;\n      }\n      // Validate tiles are known ids\n      for(let t of obj.tiles) {\n        if (!TILE_DEFS.some(tile => tile.id === t)) {\n          alert(`Unknown tile id in level: ${t}`);\n          return false;\n        }\n      }\n      return obj.tiles;\n    } catch(e) {\n      alert('Failed to parse JSON: ' + e.message);\n      return false;\n    }\n  }\n\n  // Set board data and refresh\n  function loadBoard(tiles) {\n    pushUndo(boardData.map((oldTile, i) => {\n      return { row: Math.floor(i / COLS), col: i % COLS, oldTile, newTile: tiles[i] };\n    }));\n    boardData = tiles.slice();\n    renderBoard();\n    redoStack.length = 0;\n    updateUndoRedoButtons();\n  }\n\n  // Initialize app\n  function init() {\n    buildPalette();\n    buildBoard();\n    updateUndoRedoButtons();\n\n    clearBtn.addEventListener('click', () => {\n      clearBoard();\n    });\n    fillGroundBtn.addEventListener('click', () => {\n      fillGround();\n    });\n    undoBtn.addEventListener('click', () => {\n      undo();\n    });\n    redoBtn.addEventListener('click', () => {\n      redo();\n    });\n    exportBtn.addEventListener('click', () => {\n      const json = exportLevel();\n      exportArea.value = json;\n      exportArea.focus();\n      exportArea.select();\n    });\n    importBtn.addEventListener('click', () => {\n      fileInput.click();\n    });\n    fileInput.addEventListener('change', e => {\n      if (fileInput.files.length === 0) return;\n      const file = fileInput.files[0];\n      const reader = new FileReader();\n      reader.onload = () => {\n        let tiles = importLevel(reader.result);\n        if (tiles) {\n          loadBoard(tiles);\n          exportArea.value = \"\";\n        }\n      };\n      reader.readAsText(file);\n      fileInput.value = '';\n    });\n  }\n\n  init();\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}