<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic 4x4 Grid of 3D Lyapunov Fractals</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            background-color: black;
            margin: 0;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 320px); /* Each image is 320px wide */
            grid-gap: 5px;
        }

        canvas {
            border: 1px solid white;
        }
    </style>
</head>

<body>
    <div class="grid" id="fractalGrid"></div>
    <script>
        function generateRandomPalette() {
            const palette = [];
            for (let i = 0; i < 256; i++) {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                palette.push(`rgb(${r}, ${g}, ${b})`);
            }
            return palette;
        }

        function randomCoefficients() {
            return Array.from({ length: 9 }, () => Math.random() * 4 - 2);
        }

        function getRandomIterations(min = 1000, max = 100000) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function calculateLyapunovExponent(coeffsX, coeffsY, coeffsZ) {
            const maxIterations = getRandomIterations(); // Random iterations between 1000 and 100000
            let lyapunovSum = 0;

            for (let n = 0; n < 100; n++) {
                let x = Math.random() * 4 - 2;
                let y = Math.random() * 4 - 2;
                let z = Math.random() * 4 - 2;
                let localSum = 0;

                for (let i = 0; i < maxIterations; i++) {
                    const nextX = coeffsX[0] + coeffsX[1] * x + coeffsX[2] * x * x + coeffsX[3] * x * y + coeffsX[4] * y + coeffsX[5] * y * y + coeffsX[6] * z + coeffsX[7] * z * z + coeffsX[8] * x * z;
                    const nextY = coeffsY[0] + coeffsY[1] * x + coeffsY[2] * x * x + coeffsY[3] * x * y + coeffsY[4] * y + coeffsY[5] * y * y + coeffsY[6] * z + coeffsY[7] * z * z + coeffsY[8] * y * z;
                    const nextZ = coeffsZ[0] + coeffsZ[1] * x + coeffsZ[2] * x * x + coeffsZ[3] * x * y + coeffsZ[4] * y + coeffsZ[5] * y * y + coeffsZ[6] * z + coeffsZ[7] * z * z + coeffsZ[8] * x * y;

                    const derivativeX = coeffsX[1] + 2 * coeffsX[2] * x + coeffsX[3] * y + coeffsX[4] * y + coeffsX[5] * 2 * y + coeffsX[6] * z + coeffsX[8] * z;
                    const derivativeY = coeffsY[1] + 2 * coeffsY[2] * x + coeffsY[3] * y + coeffsY[4] * y + coeffsY[5] * 2 * y + coeffsY[6] * z + coeffsY[8] * z;
                    const derivativeZ = coeffsZ[1] + 2 * coeffsZ[2] * x + coeffsZ[3] * y + coeffsZ[4] * y + coeffsZ[5] * 2 * y + coeffsZ[6] * z + coeffsZ[8] * x;

                    localSum += Math.log(Math.abs(derivativeX * derivativeY * derivativeZ));
                    x = nextX;
                    y = nextY;
                    z = nextZ;
                }
                lyapunovSum += localSum / maxIterations;
            }
            return lyapunovSum / 100;
        }

        function drawFractal(canvas, coeffsX, coeffsY, coeffsZ, palette) {
            const ctx = canvas.getContext('2d');
            const pixels = ctx.createImageData(canvas.width, canvas.height);
            const data = pixels.data;
            const lyapunovExp = calculateLyapunovExponent(coeffsX, coeffsY, coeffsZ);
            const isChaotic = lyapunovExp > 0;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let nx = x / 80 - 2; // Scale for 320px width
                    let ny = y / 40 - 2; // Scale for 200px height
                    let nz = 0; // Fixed z for the 2D projection, can be modified for exploration

                    let nextX = coeffsX[0] + coeffsX[1] * nx + coeffsX[2] * nx * nx + coeffsX[3] * nx * ny + coeffsX[4] * ny + coeffsX[5] * ny * ny + coeffsX[6] * nz + coeffsX[7] * nz * nz + coeffsX[8] * nx * nz;
                    let nextY = coeffsY[0] + coeffsY[1] * nx + coeffsY[2] * nx * nx + coeffsY[3] * nx * ny + coeffsY[4] * ny + coeffsY[5] * ny * ny + coeffsY[6] * nz + coeffsY[7] * nz * nz + coeffsY[8] * ny * nz;
                    let nextZ = coeffsZ[0] + coeffsZ[1] * nx + coeffsZ[2] * nx * nx + coeffsZ[3] * nx * ny + coeffsZ[4] * ny + coeffsZ[5] * ny * ny + coeffsZ[6] * nz + coeffsZ[7] * nz * nz + coeffsZ[8] * nx * ny;

                    const colorIndex = Math.floor((Math.abs(nextX + nextY + nextZ) % 256));
                    const [r, g, b] = palette[colorIndex].match(/\d+/g).map(Number);

                    const pixelIndex = (y * canvas.width + x) * 4;
                    data[pixelIndex] = r;     
                    data[pixelIndex + 1] = g; 
                    data[pixelIndex + 2] = b; 
                    data[pixelIndex + 3] = 255; 
                }
            }

            ctx.putImageData(pixels, 0, 0);
        }

        function createFractalCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = 320; // Width of each small fractal
            canvas.height = 200; // Height of each small fractal
            return canvas;
        }

        function updateFractal(canvas) {
            const coeffsX = randomCoefficients();
            const coeffsY = randomCoefficients();
            const coeffsZ = randomCoefficients();
            const palette = generateRandomPalette();
            drawFractal(canvas, coeffsX, coeffsY, coeffsZ, palette);
        }

        function createGrid() {
            const grid = document.getElementById('fractalGrid');
            grid.innerHTML = ''; // Clear previous contents

            const canvases = [];
            for (let i = 0; i < 16; i++) {
                const fractalCanvas = createFractalCanvas();
                canvases.push(fractalCanvas);
                grid.appendChild(fractalCanvas);
                // Immediately update with a fractal image
                updateFractal(fractalCanvas);
            }
            return canvases;
        }

        function startFractalSwap() {
            const canvases = createGrid();
            setInterval(() => {
                canvases.forEach(canvas => updateFractal(canvas));
            }, 1000); // Update every 1 second
        }

        startFractalSwap();
    </script>
</body>

</html>
