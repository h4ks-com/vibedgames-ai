<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Vibecode Pixel Clash - Expanded</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #0f111a;
      --panel: #1b1f2a;
      --fg: #e6e6e6;
      --accent: #66d9ea;
      --tileGrass: #4caf50;
      --tileWater: #2196f3;
      --tileObstacle: #555;
      --hud: rgba(0,0,0,0.5);
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: radial-gradient(circle at 20% -10%, #1e1e1e 0%, #0f0f12 40%, #0f0f12 100%), var(--bg);
      color: var(--fg);
      user-select: none;
    }
    #app {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 12px;
      height: 100%;
      padding: 12px;
      box-sizing: border-box;
    }
    #gameStage {
      position: relative;
      border: 2px solid #2b2b2b;
      border-radius: 8px;
      background: #111;
      overflow: hidden;
      min-height: 520px;
    }
    canvas#screen {
      width: 100%;
      height: auto;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hud {
      padding: 8px 12px;
      position: absolute;
      left: 8px;
      bottom: 8px;
      background: rgba(0,0,0,0.25);
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.2;
      color: #fff;
      max-width: 320px;
      backdrop-filter: blur(2px);
      border: 1px solid rgba(255,255,255,0.15);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .badge {
      display:inline-block;
      padding:2px 6px;
      border-radius:4px;
      background: rgba(102,217,234,0.2);
      color: #9ae9ff;
      font-size:12px;
    }
    .panel {
      position: relative;
      background: rgba(15, 17, 23, 0.9);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      color: #f0f0f0;
      overflow: auto;
    }
    #sidebar {
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 12px;
      align-content: start;
    }
    h2, h3 { margin: 0 0 8px 0; }
    h2 { font-size: 1.05rem; }
    h3 { font-size: 0.95rem; color:#ddd; margin-top:6px; }
    button {
      background: linear-gradient(#2f3a52, #1f2540);
      color: #fff;
      border: 1px solid #555;
      padding: 9px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }
    button.secondary { background: #2e2e2e; }
    button.danger { background: #5a1e1e; border-color:#7a2a2a; }
    button:focus { outline: 2px solid var(--accent); }
    #patchList { display: grid; grid-template-columns: 1fr; gap: 6px; }
    .patchItem { display:flex; align-items:center; justify-content: space-between;
      padding: 6px; border-radius: 6px; background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .patchItem .name { font-weight: 600; }
    .patchItem .desc { font-size: 12px; color: var(--fg); opacity: 0.8; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .grow { flex: 1 1 auto; }
    #battleUI {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      height: 40%;
      background: linear-gradient(to top, rgba(0,0,0,0.85), rgba(0,0,0,0.55) 60%, rgba(0,0,0,0.0) 100%);
      border-top: 2px solid rgba(255,255,255,0.15);
      display: none;
      padding: 8px;
      box-sizing: border-box;
    }
    #battleFrame {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px; height: 44%;
    }
    .battleBox {
      border-radius: 6px; padding: 8px; background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
    }
    .battleHeader { font-weight: 700; font-size: 14px; margin-bottom: 6px; }
    .hpBar { height: 8px; background: #333; border-radius: 4px; overflow: hidden; }
    .hpFill { height: 100%; background: linear-gradient(90deg, #4cd97b, #27ae60); }
    .moveBtn { padding: 6px 10px; border-radius:6px; margin:4px; min-width: 120px; }
    #battleLog { margin-top:6px; font-size:12px; color:#ddd; height: 40px; overflow:auto; border-top:1px solid rgba(255,255,255,0.15); padding-top:6px; }
    #dialogue {
      position: absolute; left: 12px; bottom: 52%; max-width: 60%; background: rgba(0,0,0,0.7);
      padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
      display: none;
    }
    #dialogue p { margin:0; }
    /* settings toggles */
    .toggleRow { display:flex; justify-content: space-between; align-items:center; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,0.15); }
    .toggleRow:last-child { border-bottom: none; }
    input[type="checkbox"] { transform: translateY(1px); }
    @media (max-width: 1100px) {
      #app { grid-template-columns: 1fr; }
      #battleUI { height: 42%; }
      #battleLog { height: 44px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="gameStage">
      <canvas id="screen" width="640" height="384" aria-label="Game screen" role="img"></canvas>
      <div class="hud" aria-label="Game HUD">
        <span id="hudName" class="badge">Trainer: You</span>
        <span id="hudRoute" class="badge" style="background: rgba(102,217,234,0.25);">Route A1</span>
        <span id="hudLevel" class="badge" style="background: rgba(0,0,0,0); border:1px solid #555; color:#fff;">Lv 5</span>
        <span class="badge" id="hudFrameRate" title="FPS">60fps</span>
        <div style="margin-left: auto; display: flex; gap:6px;">
          <button id="btnSettings" title="Open settings" style="padding:6px 8px;">Settings</button>
        </div>
      </div>

      <div id="battleUI" aria-label="Battle UI" class="panel" style="width: 60%; bottom: 0; left: 0; right: 0;">
        <div id="battleFrame" style="height:100%;">
          <div class="battleBox" id="playerBox" aria-label="Player Pokémon">
            <div class="battleHeader">Your Pokémon</div>
            <div id="playerName">Vibradon</div>
            <div class="hpBar" aria-label="HP bar">
              <div class="hpFill" id="playerHPFill" style="width: 100%;"></div>
            </div>
            <div id="playerStats" style="font-size:12px; color:#ddd; margin-top:4px;">HP 24 / 24</div>
          </div>
          <div class="battleBox" id="opBox" aria-label="Opponent Pokémon">
            <div class="battleHeader">Rival's Pokémon</div>
            <div id="opName">Rivalmon</div>
            <div class="hpBar" aria-label="HP bar">
              <div class="hpFill" id="opHPFill" style="width: 100%; background: linear-gradient(90deg, #ff5555, #aa0000);"></div>
            </div>
            <div id="opStats" style="font-size:12px; color:#ddd; margin-top:4px;">HP 22 / 22</div>
          </div>
        </div>

        <div id="battleActions" class="row" style="align-items:center; justify-content:flex-start;">
          <button class="moveBtn" data-id="tackle">Tackle - 12</button>
          <button class="moveBtn" data-id="spark">Spark - 14</button>
          <button class="moveBtn" data-id="heal">Heal 6</button>
        </div>

        <div id="battleLog" aria-label="Battle log" style="margin-top:6px; font-size:12px; color:#ddd; height: 90px; overflow:auto; border-top:1px solid rgba(255,255,255,0.15); padding-top:6px;">
          Battle started!
        </div>
      </div>

      <div id="dialogue" aria-label="Dialogue">
        <p id="dialogueText"></p>
      </div>

      <canvas id="overlay" width="640" height="384" style="position:absolute; left:0; top:0; pointer-events:none;"></canvas>
    </div>

    <aside id="sidebar" class="panel" aria-label="Vibecode patches and settings" style="height: calc(100% - 0px);">
      <div class="row" style="align-items: center;">
        <h2 style="margin:0; font-size:1rem;">Vibecode Pipeline</h2>
        <span class="badge" style="background:#203a66;">Live patches</span>
      </div>

      <div id="patchPanel" class="panel" style="padding:6px 8px;">
        <h3 style="margin:6px 0 8px 0; font-size: 14px; color:#fff;">Patch Manager</h3>
        <div id="patchList"></div>
        <div class="row" style="margin-top:6px;">
          <button id="applySelected" title="Apply selected patches" style="flex:1;">Apply Selected Patches</button>
          <button id="exportCurrentPatch" title="Export current game data as patch" style="flex:1;" class="secondary">Export Patch</button>
        </div>
      </div>

      <div id="vibecodePanel" class="panel" aria-label="Vibecode patch editor" style="height: 260px;">
        <h3 style="margin:6px 0 8px 0; font-size: 14px;">Patch Editor</h3>
        <textarea id="patchEditor" rows="6" placeholder='{"type":"data-export","payload":{...}}' style="width:100%; height:120px; resize: vertical;"></textarea>
        <div class="row" style="margin-top:6px;">
          <button id="loadPatchBtn" style="flex:1;">Load Patch</button>
          <button id="closeEditorBtn" class="secondary" style="flex:1;">Close</button>
        </div>
      </div>

      <div class="panel" style="text-align:center;">
        <button id="toggleVibecode" style="width:100%;">Open Vibecode Panel</button>
      </div>

      <div class="panel" style="font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;">
        <div>Notes:</div>
        <ul style="margin:6px 0 0 16px;">
          <li>Sprites are placeholders; assets are compliant by design.</li>
          <li>Patch system allows live tweaking and export/import of data.</li>
          <li>Animations are optional in settings for accessibility.</li>
        </ul>
      </div>
      <div class="panel" style="text-align:left;">
        <h3 style="margin:6px 0 6px 0; font-size:14px;">Settings</h3>
        <div class="toggleRow">
          <span>Fancy Particles</span>
          <input type="checkbox" id="settingsParticles" checked>
        </div>
        <div class="toggleRow">
          <span>Move Animations</span>
          <input type="checkbox" id="settingsAnim" checked>
        </div>
        <div class="toggleRow">
          <span>Sound</span>
          <input type="checkbox" id="settingsSound" checked>
        </div>
        <div class="toggleRow">
          <span>Show Grid</span>
          <input type="checkbox" id="settingsGrid" checked>
        </div>
        <div class="row" style="margin-top:8px;">
          <button id="btnResetPatch" class="secondary" style="flex:1;">Reset Patches</button>
          <button id="btnDumpState" style="flex:1;">Dump State</button>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // Core data
    const MOVES = {
      'tackle': { id: 'tackle', name: 'Tackle', power: 12, accuracy: 95, type: 'normal', category: 'physical' },
      'spark': { id: 'spark', name: 'Spark', power: 14, accuracy: 100, type: 'electric', category: 'physical' },
      'heal': { id: 'heal', name: 'Heal', power: 0, accuracy: 100, type: 'support', category: 'status', effect: { hp: 6 } },
    };

    const PATCHES = [
      {
        id:'balancing1',
        name:'XP Curve v1.1',
        description:'Slightly adjusted XP curve for smoother mid-game progression',
        apply: (data) => {
          data.playerMaxXp = (data.playerMaxXp || 20) + 4;
        }
      },
      {
        id:'renameSafe',
        name:'Compliant Assets',
        description:'Placeholders only; assets renamed to avoid conflicts',
        apply: (data) => {
          data.playerName = 'Vibradon';
        }
      }
    ];

    // Game state
    const game = {
      mapW: 20, mapH: 12,
      tile: 32,
      player: { x: 2, y: 2 },
      rival: { x: 11, y: 6, active: true },
      inDialogue: false,
      inBattle: false,
      patchesApplied: [],
      data: {
        playerName: 'You',
        player: { hp: 24, maxHp: 24, atk: 12, def: 10, xp: 0, level: 5, name: 'Vibradon' },
        rivalName: 'Rivalmon',
      },
      patchState: {}
    };

    // Map layout: 0 grass, 1 water, 2 obstacle
    const mapLayout = [];
    for (let y = 0; y < game.mapH; y++) {
      const row = [];
      for (let x = 0; x < game.mapW; x++) {
        if (x === 0 || y === 0 || x === game.mapW - 1 || y === game.mapH - 1) row.push(2);
        else if ((x === 5 && y > 3 && y < 9) || (y === 7 && x > 3 && x < 16)) row.push(1);
        else row.push(0);
      }
      mapLayout.push(row);
    }

    // Canvas setup
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const tileSize = game.tile;
    canvas.width = game.mapW * tileSize;
    canvas.height = game.mapH * tileSize;

    // animation & particles
    let particles = [];
    function spawnParticles(x, y, color) {
      const count = 14;
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2) * (i / count);
        particles.push({ x: x, y: y, vx: Math.cos(angle) * (1 + Math.random()*2), vy: Math.sin(angle) * (1 + Math.random()*2), life: 40 + Math.random()*20, color });
      }
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 1;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }
    function renderParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2, 2);
      }
    }

    // Simple input
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === 'z' || e.key === 'Z') {
        attemptTalk();
      }
      if (e.key === 'x' || e.key === 'X') {
        attemptRun();
      }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // Dialogue
    const dialogueBox = document.getElementById('dialogue');
    const dialogueText = document.getElementById('dialogueText');
    function showDialogue(text, duration = 1800) {
      dialogueBox.style.display = 'block';
      dialogueText.textContent = text;
      setTimeout(() => { dialogueBox.style.display = 'none'; }, duration);
    }

    // Map drawing
    function drawMap() {
      for (let y = 0; y < game.mapH; y++) {
        for (let x = 0; x < game.mapW; x++) {
          const t = mapLayout[y][x];
          const px = x * tileSize;
          const py = y * tileSize;
          if (t === 0) ctx.fillStyle = '#4caf50';
          else if (t === 1) ctx.fillStyle = '#2b7bd6';
          else ctx.fillStyle = '#555';
          ctx.fillRect(px, py, tileSize, tileSize);
          // grid shading
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(px, py, tileSize, tileSize);
        }
      }
      // Player
      const ppx = game.player.x * tileSize;
      const ppy = game.player.y * tileSize;
      ctx.fillStyle = '#ffd166';
      ctx.fillRect(ppx + 6, ppy + 6, tileSize - 12, tileSize - 12);
      // Rival
      if (game.rival.active) {
        ctx.fillStyle = '#66a2ff';
        ctx.fillRect(game.rival.x * tileSize + 8, game.rival.y * tileSize + 8, tileSize - 16, tileSize - 16);
      }
    }

    // Movement
    function canMove(nx, ny) {
      if (nx < 0 || ny < 0 || nx >= game.mapW || ny >= game.mapH) return false;
      return mapLayout[ny][nx] !== 2;
    }
    function updatePlayerFromInput() {
      let nx = game.player.x;
      let ny = game.player.y;
      if (keys['ArrowUp'] || keys['w'] || keys['W']) ny--;
      if (keys['ArrowDown'] || keys['s'] || keys['S']) ny++;
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) nx--;
      if (keys['ArrowRight'] || keys['d'] || keys['D']) nx++;

      if (nx !== game.player.x || ny !== game.player.y) {
        if (canMove(nx, ny)) {
          game.player.x = nx; game.player.y = ny;
        }
      }

      // near rival: show potential dialogue indicator (optional)
    }

    // Battle system (simplified)
    const playerPokemon = {
      name: 'Vibradon',
      level: 5,
      maxHp: 24,
      hp: 24,
      atk: 12,
      moves: ['spark', 'heal', 'tackle']
    };
    const rivalPokemon = {
      name: 'Rivalmon',
      level: 5,
      maxHp: 22,
      hp: 22,
      atk: 11,
      moves: ['tackle', 'growl']
    };

    function startBattle() {
      game.inBattle = true;
      document.getElementById('battleUI').style.display = 'block';
      updateBattleUI();
      logBattle("A wild Rivalmon appeared!");
      const btns = document.querySelectorAll('.moveBtn');
      btns.forEach(b => b.addEventListener('click', onBattleMove));
      // simple entrance animation
      spawnParticles((game.player.x + game.rival.x) * tileSize / 2, (game.player.y + game.rival.y) * tileSize / 2, '#fff');
    }

    function onBattleMove(e) {
      const moveId = e.currentTarget.getAttribute('data-id');
      playerTurn(moveId);
    }

    function playerTurn(moveId) {
      const mv = MOVES[moveId];
      if (!mv) return;
      let dmg = 0;
      if (mv.power > 0) {
        dmg = Math.max(1, Math.floor((2 * playerPokemon.level / 5 + 2) * mv.power * (playerPokemon.atk / rivalPokemon.level) / 50));
        rivalPokemon.hp = Math.max(0, rivalPokemon.hp - dmg);
        logBattle(`Your ${playerPokemon.name} used ${mv.name}! -${dmg} HP`);
        spawnParticles((game.rival.x) * tileSize + tileSize/2, (game.rival.y) * tileSize + tileSize/2, '#66a2ff');
      } else {
        // status/misc
        if (mv.id === 'heal') {
          const heal = mv.effect?.hp ?? 6;
          playerPokemon.hp = Math.min(playerPokemon.maxHp, playerPokemon.hp + heal);
          logBattle(`Your ${playerPokemon.name} heals +${heal} HP`);
        }
      }

      if (rivalPokemon.hp <= 0) {
        logBattle("Rivalmon fainted! You won!");
        endBattle(true);
        return;
      }

      // Rival turn
      setTimeout(rivalTurn, 350);
      updateBattleUI();
    }

    function rivalTurn() {
      const mvName = rivalPokemon.moves[Math.floor(Math.random() * rivalPokemon.moves.length)];
      const mv = MOVES[mvName] || { power: 0 };
      if (mv.power > 0) {
        const dmg = Math.max(1, Math.floor((2 * rivalPokemon.level / 5 + 2) * mv.power * (rivalPokemon.atk / playerPokemon.level) / 50));
        playerPokemon.hp = Math.max(0, playerPokemon.hp - dmg);
        logBattle(`Rivalmon used ${mv.name || 'Move'}! -${dmg} HP`);
        spawnParticles((game.player.x) * tileSize + tileSize/2, (game.player.y) * tileSize + tileSize/2, '#ff5555');
      } else {
        // status
        logBattle(`Rival's move skipped turn.`);
      }

      if (playerPokemon.hp <= 0) {
        logBattle("Your Vibradon fainted!");
        endBattle(false);
        return;
      }
      updateBattleUI();
    }

    function endBattle(victory) {
      game.inBattle = false;
      document.getElementById('battleUI').style.display = 'none';
      if (victory) {
        logBattle("Gained experience! Lv up soon.");
        playerPokemon.xp = (playerPokemon.xp || 0) + 18;
        if ((playerPokemon.xp) >= 40) {
          playerPokemon.level++;
          playerPokemon.maxHp += 4;
          playerPokemon.hp = playerPokemon.maxHp;
          playerPokemon.atk += 1;
          playerPokemon.xp = 0;
          logBattle("Vibradon leveled up!");
        }
      } else {
        logBattle("You retreated!");
      }
      // reset HPs for next round
      playerPokemon.hp = playerPokemon.maxHp;
      rivalPokemon.hp = rivalPokemon.maxHp;
      update();
    }

    function updateBattleUI() {
      const pHp = Math.max(0, Math.min(playerPokemon.maxHp, playerPokemon.hp));
      const oHp = Math.max(0, Math.min(rivalPokemon.maxHp, rivalPokemon.hp));
      document.getElementById('playerHPFill').style.width = (pHp / playerPokemon.maxHp) * 100 + '%';
      document.getElementById('opHPFill').style.width = (oHp / rivalPokemon.maxHp) * 100 + '%';
      document.getElementById('playerName').textContent = playerPokemon.name;
      document.getElementById('opName').textContent = rivalPokemon.name;
      document.getElementById('playerStats').textContent = `HP ${pHp} / ${playerPokemon.maxHp}  |  Lv ${playerPokemon.level}`;
      document.getElementById('opStats').textContent = `HP ${oHp} / ${rivalPokemon.maxHp}  |  Lv ${rivalPokemon.level}`;
      // log auto-scroll
      const log = document.getElementById('battleLog');
      log.scrollTop = log.scrollHeight;
    }

    function logBattle(text) {
      const log = document.getElementById('battleLog');
      log.innerHTML += '<div>' + text + '</div>';
      log.scrollTop = log.scrollHeight;
    }

    function log(text) { console.log(text); }

    // Talk/run logic
    function attemptTalk() {
      if (game.inBattle) return;
      if (Math.abs(game.player.x - game.rival.x) + Math.abs(game.player.y - game.rival.y) <= 1) {
        showDialogue("Rival: Hey! You wanna battle?CHAOS awaits!");
        setTimeout(() => startBattle(), 600);
      } else {
        showDialogue("There's no one to talk to here.");
      }
    }

    function attemptRun() {
      if (!game.inBattle) {
        showDialogue("You can't run from nothing!");
        return;
      }
      // try escape
      const ok = Math.random() > 0.4;
      if (ok) {
        endBattle(false);
        logBattle("You escaped safely.");
      } else {
        logBattle("Couldn't escape!");
        rivalTurn();
      }
    }

    // Patch panel
    const patchListEl = document.getElementById('patchList');
    function renderPatches() {
      patchListEl.innerHTML = '';
      PATCHES.forEach((p, idx) => {
        const item = document.createElement('div');
        item.className = 'patchItem';
        const left = document.createElement('div');
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.dataset.index = idx;
        left.appendChild(chk);
        const name = document.createElement('span');
        name.className = 'name';
        name.textContent = p.name;
        left.appendChild(name);
        const right = document.createElement('div');
        right.className = 'desc';
        right.textContent = p.description;
        item.appendChild(left);
        item.appendChild(right);
        patchListEl.appendChild(item);
      });
    }

    function applySelectedPatches() {
      const checks = patchListEl.querySelectorAll('input[type="checkbox"]');
      checks.forEach(ch => {
        if (ch.checked) {
          const idx = parseInt(ch.dataset.index, 10);
          const patch = PATCHES[idx];
          if (patch && patch.apply) patch.apply(game.data);
          game.patchesApplied.push(patch.id);
        }
      });
      logBattle('Patches applied.');
      renderPatchesState();
      update();
    }

    function exportCurrentPatch() {
      const payload = {
        type: 'data-export',
        version: '1.0',
        payload: {
          data: game.data,
          patchesApplied: game.patchesApplied
        }
      };
      const json = JSON.stringify(payload, null, 2);
      // copy to clipboard
      navigator.clipboard.writeText(json).then(() => {
        alert('Exported patch JSON to clipboard.');
      }).catch(() => {
        prompt('Patch JSON', json);
      });
    }

    function renderPatchesState() {
      // re-render could add status; for simplicity just refresh text
    }

    // Vibecode panel toggles
    const vibPanel = document.getElementById('vibecodePanel');
    const toggleBtn = document.getElementById('toggleVibecode');
    toggleBtn.addEventListener('click', () => {
      if (vibPanel.style.display === 'block') {
        vibPanel.style.display = 'none';
        toggleBtn.textContent = 'Open Vibecode Panel';
      } else {
        vibPanel.style.display = 'block';
        toggleBtn.textContent = 'Close Vibecode Panel';
      }
    });

    document.getElementById('loadPatchBtn').addEventListener('click', () => {
      const json = document.getElementById('patchEditor').value;
      try {
        const parsed = JSON.parse(json);
        if (parsed.payload && parsed.payload.data) {
          Object.assign(game.data, parsed.payload.data);
          logBattle('Patch loaded from editor.');
        } else {
          logBattle('Patch loaded (no data).');
        }
      } catch (e) {
        alert('Invalid JSON');
      }
    });
    document.getElementById('closeEditorBtn').addEventListener('click', () => {
      vibPanel.style.display = 'none';
      toggleBtn.textContent = 'Open Vibecode Panel';
    });
    document.getElementById('applySelected').addEventListener('click', applySelectedPatches);
    document.getElementById('exportCurrentPatch').addEventListener('click', exportCurrentPatch);
    document.getElementById('btnResetPatch').addEventListener('click', () => {
      localStorage.removeItem('vibecode_patch_state');
      game.patchesApplied = [];
      renderPatches();
      logBattle('Patches reset.');
      update();
    });
    document.getElementById('btnDumpState').addEventListener('click', () => {
      console.log('State', JSON.stringify({ game, data: game.data }, null, 2));
      alert('State dumped to console.');
    });

    // Save/Load patches
    function savePatches() {
      const data = { patchesApplied: game.patchesApplied };
      localStorage.setItem('vibecode_patch_state', JSON.stringify(data));
    }
    // HUD / rendering loop
    function drawScene() {
      // background clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // parallax gradient sky
      const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
      g.addColorStop(0, '#1e2a47');
      g.addColorStop(1, '#0a0f1a');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // map
      drawMap();
      // grid toggle visual
      if (document.getElementById('settingsGrid').checked) {
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        for (let x = 0; x <= game.mapW; x++) {
          ctx.beginPath();
          ctx.moveTo(x * tileSize, 0);
          ctx.lineTo(x * tileSize, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= game.mapH; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * tileSize);
          ctx.lineTo(canvas.width, y * tileSize);
          ctx.stroke();
        }
      }
      // player glow
      ctx.fillStyle = 'rgba(255,205,0,0.6)';
      ctx.beginPath();
      ctx.arc((game.player.x + 0.5) * tileSize, (game.player.y + 0.5) * tileSize, 6, 0, Math.PI * 2);
      ctx.fill();
      // rival glow
      if (game.rival.active) {
        ctx.fillStyle = 'rgba(100,180,255,0.6)';
        ctx.beginPath();
        ctx.arc((game.rival.x + 0.5) * tileSize, (game.rival.y + 0.5) * tileSize, 6, 0, Math.PI * 2);
        ctx.fill();
      }
      // particles
      updateParticles();
      renderParticles();

      // keyboard indicator pulse
      // nothing heavy
    }

    // Initialize
    function init() {
      // initial HPs and UI
      drawScene();
      updateHUD();
      patchListEl && renderPatches();
      // game loop
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    // HUD
    function updateHUD() {
      document.getElementById('hudName').textContent = 'Trainer: You';
      document.getElementById('hudRoute').textContent = 'Route A1';
      document.getElementById('hudLevel').textContent = 'Lv 5';
    }

    // Main loop
    let lastTime = 0;
    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      // only update world when not in battle
      if (!game.inBattle) {
        updatePlayerFromInput();
        // move rival slowly for flavor
        if (game.rival.active) {
          // gentle drift toward player
          const dx = Math.sign(game.player.x - game.rival.x);
          const dy = Math.sign(game.player.y - game.rival.y);
          if (Math.abs(game.player.x - game.rival.x) + Math.abs(game.player.y - game.rival.y) > 4) {
            // slow reposition
            if (Math.random() < 0.05) {
              if (canMove(game.rival.x - dx, game.rival.y - dy)) {
                game.rival.x -= dx;
                game.rival.y -= dy;
              }
            }
          }
        }
      }
      drawScene();
      // FPS indicator update
      fpsCalc(now);
      requestAnimationFrame(loop);
    }

    // FPS helper
    let frameCount = 0;
    let fpsTime = 0;
    function fpsCalc(now) {
      if (!fpsTime) fpsTime = now;
      frameCount++;
      const dt = now - fpsTime;
      if (dt >= 1000) {
        const fps = Math.round((frameCount * 1000) / dt);
        document.getElementById('hudFrameRate').textContent = fps + 'fps';
        fpsTime = now;
        frameCount = 0;
      }
    }

    // Init on load
    window.addEventListener('load', () => {
      // Initialize patch UI
      renderPatches();
      document.getElementById('applySelected').addEventListener('click', applySelectedPatches);
      document.getElementById('exportCurrentPatch').addEventListener('click', exportCurrentPatch);
      // Bind patch editor load/state save
      document.getElementById('loadPatchBtn').addEventListener('click', () => {
        const json = document.getElementById('patchEditor').value;
        try {
          const parsed = JSON.parse(json);
          if (parsed.payload && parsed.payload.data) Object.assign(game.data, parsed.payload.data);
          logBattle('Patch loaded from editor.');
        } catch {
          alert('Invalid JSON');
        }
      });
      // Save patches periodically
      setInterval(() => savePatches(), 15000);
      // Init loop
      init();
    });

    // Patch state persistence
    function savePatches() {
      const data = { patchesApplied: game.patchesApplied };
      localStorage.setItem('vibecode_patch_state', JSON.stringify(data));
    }
    // Fine-tuned: export compatibility for patch changes
    window.addEventListener('beforeunload', savePatches);

    // Kick off a little intro
    function attemptTalk() { /* reserved for future */ }

    // Expose some globals for debugging if needed
    window.__VIBECODE = { MOVES, PATCHES, game };

    // Bind movement to code path
    // nothing extra
  </script>
</body>
</html>