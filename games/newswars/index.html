<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Headline Battle Tournament</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#7dd3fc; --muted:#94a3b8; --win:#34d399; --lose:#f87171;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071022 0%, #071a2b 100%);color:#e6eef8;}
  .app{max-width:1200px;margin:20px auto;padding:20px;display:grid;grid-template-columns:1fr 420px;gap:20px;}
  header{grid-column:1/-1;display:flex;align-items:center;gap:12px;}
  h1{margin:0;font-size:20px;color:var(--accent);}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(8,20,34,0.6);border:1px solid rgba(255,255,255,0.02);}
  .left{display:flex;flex-direction:column;gap:12px;}
  textarea{width:100%;min-height:200px;background:transparent;color:inherit;border:1px dashed rgba(255,255,255,0.04);padding:12px;border-radius:8px;resize:vertical;}
  .controls{display:flex;gap:10px;flex-wrap:wrap;}
  button{background:linear-gradient(90deg,var(--accent),#60a5fa);border:none;padding:8px 12px;border-radius:8px;color:#022;cursor:pointer;font-weight:600;}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);}
  .small{padding:6px 8px;font-size:13px;border-radius:6px;}
  .panel{display:flex;gap:12px;align-items:center;justify-content:space-between;}
  .match-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:16px;border-radius:12px;display:flex;flex-direction:column;gap:12px;}
  .pair{display:flex;gap:12px;align-items:stretch;}
  .option{flex:1;padding:14px;border-radius:10px;background:var(--glass);cursor:pointer;transition:transform .14s ease,box-shadow .14s ease;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;}
  .option:hover{transform:translateY(-4px);box-shadow:0 8px 24px rgba(7,12,25,0.6);}
  .headline{font-weight:700;font-size:15px;line-height:1.2;}
  .meta{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}
  .score{font-weight:800;font-size:18px;color:var(--accent);}
  .winner{outline:3px solid rgba(52,211,153,0.08);box-shadow:0 8px 30px rgba(52,211,153,0.06);}
  .loser{opacity:0.6;}
  .sidebar{display:flex;flex-direction:column;gap:12px;}
  .chart{height:220px;padding:10px;}
  .tree{max-height:420px;overflow:auto;padding:8px;}
  .round{margin-bottom:10px;}
  .match-record{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);margin:6px 0;border:1px solid rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center;}
  .toggle{cursor:pointer;color:var(--muted);font-size:13px}
  .status{color:var(--muted);font-size:13px}
  .score-badge{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:700;}
  .legend{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
  .legend .k{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);}
  .footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:13px;margin-top:8px;}
  .controls .muted{color:var(--muted);font-size:13px}
  .toplist{display:flex;flex-direction:column;gap:8px;}
  .top-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);}
  .progress{height:8px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:10%;}
  .controls-row{display:flex;gap:8px;align-items:center;}
  .muted-border{border:1px dashed rgba(255,255,255,0.02);padding:8px;border-radius:8px;}
  .small-input{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;color:var(--muted);}
  .round-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .expand-btn{cursor:pointer;color:var(--accent);font-weight:700}
  .footer-note{font-size:12px;color:var(--muted)}
  .badge{font-size:12px;padding:6px 8px;border-radius:999px;background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.02)}
  .flex-row{display:flex;gap:8px;align-items:center;}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Headline Battle Tournament</h1>
    <div class="badge">1v1 knockout • scores from scoring function</div>
    <div style="flex:1"></div>
    <div class="status">Interactive demo — paste headlines or use defaults</div>
  </header>

  <div class="left card">
    <div style="display:flex;gap:12px;align-items:flex-start;">
      <div style="flex:1">
        <label style="font-size:13px;color:var(--muted);display:block;margin-bottom:6px">Headlines (one per line)</label>
        <textarea id="headlineInput"></textarea>
      </div>
      <div style="width:220px">
        <div class="panel">
          <div style="display:flex;flex-direction:column;gap:6px;">
            <div class="controls-row">
              <button id="startBtn">Start Tournament</button>
              <button class="secondary small" id="autoAllBtn">Auto-Resolve All</button>
            </div>
            <div class="controls-row">
              <button class="secondary small" id="stepBtn">Next Match</button>
              <button class="secondary small" id="resetBtn">Reset</button>
            </div>
          </div>
        </div>

        <div style="margin-top:12px;" class="muted-border">
          <div style="font-size:13px;color:var(--muted);margin-bottom:8px">Scoring Mode</div>
          <select id="scoringMode" class="small-input" style="width:100%;margin-bottom:8px">
            <option value="balanced">Balanced (length + urgency + novelty)</option>
            <option value="urgency">Urgency-biased</option>
            <option value="brevity">Brevity-biased</option>
            <option value="random">Randomized</option>
            <option value="custom">Custom JS (see box)</option>
          </select>
          <textarea id="customScoring" placeholder="function score(a,b,meta){ return 0.5; }" style="width:100%;height:80px;background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;border-radius:6px;color:var(--muted);"></textarea>
        </div>
      </div>
    </div>

    <div class="match-area" id="matchArea" style="margin-top:6px;">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <strong id="roundLabel">Round: —</strong>
          <span class="status" id="matchCount">Matches: 0</span>
        </div>
        <div class="legend">
          <div class="k">Click a headline to choose</div>
          <div class="k">Auto uses scoring function</div>
        </div>
      </div>

      <div class="pair" id="pairContainer">
        <div class="option" id="optA"><div class="headline" id="aText">—</div><div class="meta"><span id="aMeta">—</span><span class="score" id="aScore">—</span></div></div>
        <div style="width:12px"></div>
        <div class="option" id="optB"><div class="headline" id="bText">—</div><div class="meta"><span id="bMeta">—</span><span class="score" id="bScore">—</span></div></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="status" id="currentStatus">No tournament running</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <div class="status" id="winsLabel">Wins: —</div>
          <div class="status" id="scoreLabel">Total score: —</div>
        </div>
      </div>
    </div>

    <div style="margin-top:8px;display:flex;gap:8px;">
      <button id="autoResolveMatch" class="secondary small">Auto Resolve Current</button>
      <button id="showTreeBtn" class="secondary small">Toggle Tree</button>
      <button id="exportBtn" class="secondary small">Export JSON</button>
    </div>
  </div>

  <aside class="sidebar">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <strong>Ranking</strong>
        <div class="toggle" id="sortToggle">Sort: Wins</div>
      </div>
      <div class="chart" id="rankingChart"></div>
      <div style="margin-top:8px;" class="toplist" id="topList"></div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Bracket Tree</strong>
        <div class="toggle" id="collapseAll">Collapse</div>
      </div>
      <div class="tree" id="treeContainer"></div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Controls Log</strong>
        <div class="toggle" id="clearLog">Clear</div>
      </div>
      <div id="log" style="max-height:160px;overflow:auto;padding-top:8px;color:var(--muted);font-size:13px"></div>
    </div>
  </aside>

  <div class="footer">Built for playful headline sparring — single-file HTML app</div>
</div>

<script>
(function(){
  // Default headlines
  const defaultHeadlines = [
    "Central bank holds rates steady as inflation cools",
    "Breakthrough in battery tech promises longer range EVs",
    "Wildfires spread across region after heatwave",
    "Local school district adopts new literacy program",
    "Social media platform introduces AI content labels",
    "Scientists discover potential signs of life on distant moon",
    "New movie breaks box office records on opening weekend",
    "Major merger announced between two tech giants",
    "Rare species reintroduced to restored habitat",
    "City council approves ambitious transit expansion",
    "Cyberattack disrupts services at several banks",
    "Startup secures funding to scale renewable energy",
    "Olympic hopefuls train through pandemic-era restrictions",
    "Study links diet changes to improved heart health",
    "Historic peace talks yield preliminary agreement",
    "Housing market shows signs of cooling after surge"
  ];

  // DOM
  const headlineInput = document.getElementById('headlineInput');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const autoAllBtn = document.getElementById('autoAllBtn');
  const stepBtn = document.getElementById('stepBtn');
  const pairContainer = document.getElementById('pairContainer');
  const aText = document.getElementById('aText');
  const bText = document.getElementById('bText');
  const aScoreEl = document.getElementById('aScore');
  const bScoreEl = document.getElementById('bScore');
  const aMeta = document.getElementById('aMeta');
  const bMeta = document.getElementById('bMeta');
  const optA = document.getElementById('optA');
  const optB = document.getElementById('optB');
  const matchArea = document.getElementById('matchArea');
  const matchCount = document.getElementById('matchCount');
  const roundLabel = document.getElementById('roundLabel');
  const currentStatus = document.getElementById('currentStatus');
  const rankingChart = document.getElementById('rankingChart');
  const topList = document.getElementById('topList');
  const treeContainer = document.getElementById('treeContainer');
  const logArea = document.getElementById('log');
  const autoResolveMatchBtn = document.getElementById('autoResolveMatch');
  const scoringMode = document.getElementById('scoringMode');
  const customScoring = document.getElementById('customScoring');
  const showTreeBtn = document.getElementById('showTreeBtn');
  const collapseAllBtn = document.getElementById('collapseAll');
  const exportBtn = document.getElementById('exportBtn');
  const sortToggle = document.getElementById('sortToggle');
  const clearLog = document.getElementById('clearLog');

  // State
  let headlines = [];
  let players = []; // objects {id,text}
  let rounds = []; // array of rounds; each round is array of matches
  let currentRound = 0;
  let currentMatchIndex = 0;
  let stats = {}; // id -> {wins,score,battles}
  let autoRunning = false;
  let sortBy = 'wins'; // or 'score'
  let treeVisible = true;

  // Utilities
  function rand(min=0,max=1){ return Math.random()*(max-min)+min; }
  function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
  function uid(){ return Math.random().toString(36).slice(2,9); }
  function log(msg){ const d=document.createElement('div'); d.textContent=msg; logArea.prepend(d); }
  function cleanText(s){ return (s||'').replace(/\\s+/g,' ').trim(); }

  function defaultScoringFn(a,b,meta){
    // return score in [0,1] for headline a in match vs b
    // features: urgency words, length, novelty, sentiment-lite
    const urgencyWords = ["urgent","breaking","crash","disaster","fire","attack","cyberattack","explosive","announces","announced","emergency","warn","warning","conflict","heatwave","wildfire"];
    const positiveWords = ["breakthrough","promises","reintroduced","historic","hopeful","improved","secured","growth","record","agreement"];
    const toLower = (s)=>s.toLowerCase();
    function countWords(list,txt){
      let c=0; list.forEach(w=>{ if(txt.includes(w)) c++; });
      return c;
    }
    a = toLower(a); b = toLower(b);
    let lenScore = clamp(1 - Math.abs(a.split(' ').length - b.split(' ').length)/8, 0, 1);
    let urgencyA = clamp(countWords(urgencyWords,a)/2,0,1);
    let posA = clamp(countWords(positiveWords,a)/2,0,1);
    // novelty: longer unique words
    let uniqA = new Set(a.split(' ')).size / Math.max(3, a.split(' ').length);
    let novelty = clamp(uniqA,0,1);
    // simple baseline
    let base = 0.4*lenScore + 0.35*urgencyA + 0.15*novelty + 0.10*posA;
    // small randomness
    base += rand(-0.08,0.08);
    return clamp(base,0,1);
  }

  function brevityScoring(a,b){
    // favors shorter headlines
    let la = a.split(' ').length, lb = b.split(' ').length;
    let score = clamp(1 - (la / Math.max(la,lb)), 0, 1);
    score += rand(-0.05,0.05);
    return clamp(score,0,1);
  }

  function urgencyScoring(a,b){
    const urgent = ["breaking","urgent","emergency","crash","wildfire","attack","exploit","heatwave","warn","cyberattack","fire"];
    function count(txt){ return urgent.reduce((s,w)=> s + (txt.includes(w)?1:0),0); }
    a = a.toLowerCase(); b = b.toLowerCase();
    let ca = count(a), cb = count(b);
    let total = ca + cb;
    let score = total === 0 ? 0.5 : clamp(ca/total,0,1);
    score += rand(-0.05,0.05);
    return clamp(score,0,1);
  }

  function randomScoring(a,b){ return clamp(rand(),0,1); }

  function getScoringFunction(){
    const mode = scoringMode.value;
    if(mode === 'custom'){
      let src = customScoring.value.trim();
      if(!src){ return defaultScoringFn; }
      try{
        // Wrap in try-catch and provide safe sandboxed function execution: limited but user-provided
        /* eslint-disable no-new-func */
        const userFn = new Function('a','b','meta',`return (${src})(a,b,meta);`);
        // Return a wrapper that handles errors and returns fallback
        return function(a,b,meta){
          try{ let v = userFn(a,b,meta); return typeof v === 'number' ? clamp(v,0,1) : clamp(Number(v)||0,0,1); }
          catch(e){ console.warn('custom scoring error',e); return defaultScoringFn(a,b,meta); }
        };
      }catch(e){
        return defaultScoringFn;
      }
    } else if(mode === 'balanced'){
      return defaultScoringFn;
    } else if(mode === 'urgency'){
      return urgencyScoring;
    } else if(mode === 'brevity'){
      return brevityScoring;
    } else if(mode === 'random'){
      return randomScoring;
    } else {
      return defaultScoringFn;
    }
  }

  // Tournament construction
  function preparePlayers(list){
    players = list.map((t,i)=>({id: uid(), text: cleanText(t)}));
    stats = {};
    players.forEach(p=> stats[p.id] = {wins:0,score:0,battles:0,text:p.text});
  }

  function pairRound(playerArray){
    // shuffle then pair; if odd give bye to last (it advances automatically)
    let arr = [...playerArray];
    for(let i=arr.length-1;i>0;i--){ let j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    let matches = [];
    for(let i=0;i<arr.length;i+=2){
      if(i+1>=arr.length){
        matches.push({a:arr[i],b:null,aScore:null,bScore:null,winner:arr[i],bye:true});
      } else {
        matches.push({a:arr[i],b:arr[i+1],aScore:null,bScore:null,winner:null,bye:false});
      }
    }
    return matches;
  }

  function buildTournament(){
    rounds = [];
    currentRound = 0;
    currentMatchIndex = 0;
    let pool = [...players];
    let r0 = pairRound(pool);
    rounds.push(r0);
    // compute subsequent rounds as placeholders until winners known
    let above = r0.filter(m=>m.b).map(()=>null);
    while(above.length > 1){
      let nextPairs = new Array(Math.ceil(above.length/2)).fill(null).map(()=>({a:null,b:null,aScore:null,bScore:null,winner:null,bye:false}));
      rounds.push(nextPairs);
      above = nextPairs;
    }
  }

  function renderMatch(){
    const round = rounds[currentRound];
    if(!round) return;
    const match = round[currentMatchIndex];
    if(!match) return;
    roundLabel.textContent = `Round ${currentRound+1} of ${rounds.length}`;
    matchCount.textContent = `Matches in round: ${round.length}`;
    if(match.bye){
      aText.textContent = match.a.text;
      bText.textContent = "(bye)";
      aMeta.textContent = `auto-advance`;
      bMeta.textContent = '';
      aScoreEl.textContent = '—';
      bScoreEl.textContent = '—';
      optA.classList.add('winner'); optA.classList.remove('loser');
      optB.classList.remove('winner'); optB.classList.add('loser');
      currentStatus.textContent = `This player receives a bye and advances automatically.`;
    } else {
      aText.textContent = match.a.text;
      bText.textContent = match.b.text;
      aMeta.textContent = `id: ${match.a.id}`;
      bMeta.textContent = `id: ${match.b.id}`;
      aScoreEl.textContent = match.aScore === null ? '—' : (match.aScore.toFixed(3));
      bScoreEl.textContent = match.bScore === null ? '—' : (match.bScore.toFixed(3));
      optA.classList.remove('winner','loser'); optB.classList.remove('winner','loser');
      currentStatus.textContent = `Choose a winner or auto-resolve with scoring function.`;
    }
    updateStatsLabels();
  }

  function updateStatsLabels(){
    // brief summary
    let remaining = 0;
    for(let r=currentRound;r<rounds.length;r++){
      remaining += rounds[r].length - currentMatchIndex;
      break;
    }
    let totalPlayers = players.length;
    let summaryWins = Object.values(stats).reduce((s,o)=>s+o.wins,0);
    document.getElementById('winsLabel').textContent = `Wins recorded: ${summaryWins}`;
    document.getElementById('scoreLabel').textContent = `Players: ${totalPlayers}`;
  }

  function advanceMatch(){
    const round = rounds[currentRound];
    if(!round) return;
    if(currentMatchIndex+1 < round.length){
      currentMatchIndex++;
    } else {
      // move to next round: gather winners from this round to populate next round
      const winners = round.map(m=>{
        if(m.bye) return m.winner;
        return m.winner;
      });
      // collect next round index
      if(currentRound+1 < rounds.length){
        const next = rounds[currentRound+1];
        // fill next round matches a/b
        let idx = 0;
        for(let i=0;i<next.length;i++){
          next[i].a = winners[idx] || null; idx++;
          next[i].b = winners[idx] || null; idx++;
          // mark bye if b is null and a exists
          next[i].bye = !next[i].b && !!next[i].a;
          next[i].winner = next[i].bye ? next[i].a : null;
        }
        currentRound++;
        currentMatchIndex = 0;
      } else {
        // tournament over
        currentStatus.textContent = "Tournament complete.";
        autoRunning = false;
        currentRound++;
      }
    }
    renderMatch();
    renderTree();
    renderRanking();
  }

  // scoring and resolving
  function resolveMatchAuto(match, meta={}){
    const sf = getScoringFunction();
    if(match.bye){
      match.winner = match.a;
      // update stats
      stats[match.a.id].wins += 1;
      stats[match.a.id].battles += 0;
      log(`Bye: "${match.a.text}" advances.`);
      return match.winner;
    }
    const a = match.a.text, b = match.b.text;
    let aScore = sf(a,b,meta);
    let bScore = sf(b,a,meta);
    // normalize and small nudge to avoid ties
    const total = aScore + bScore;
    if(total === 0){ aScore = bScore = 0.5; }
    else { aScore = aScore/total; bScore = bScore/total; }
    // add slight randomness so repeated runs vary
    aScore = clamp(aScore + rand(-0.03,0.03),0,1);
    bScore = clamp(bScore + rand(-0.03,0.03),0,1);
    match.aScore = aScore;
    match.bScore = bScore;
    match.winner = aScore >= bScore ? match.a : match.b;
    // update stats
    stats[match.a.id].battles += 1;
    stats[match.b.id].battles += 1;
    stats[match.a.id].score += aScore;
    stats[match.b.id].score += bScore;
    stats[match.winner.id].wins += 1;
    log(`Auto: "${match.a.text}" scored ${aScore.toFixed(3)} vs "${match.b.text}" ${bScore.toFixed(3)} → winner: "${match.winner.text}"`);
    return match.winner;
  }

  function resolveMatchManual(match, chosenId){
    if(match.bye){
      return resolveMatchAuto(match);
    }
    const a = match.a.text, b = match.b.text;
    const chosen = chosenId === match.a.id ? match.a : match.b;
    const other = chosen === match.a ? match.b : match.a;
    // assign scores: winner gets between 0.6-1.0, loser 0-0.45 depending on closeness
    const winnerScore = clamp(rand(0.65, 0.95),0,1);
    const loserScore = clamp(rand(0.05, 0.45),0,1);
    if(chosen === match.a){
      match.aScore = winnerScore; match.bScore = loserScore;
    } else {
      match.bScore = winnerScore; match.aScore = loserScore;
    }
    match.winner = chosen;
    // stats
    stats[match.a.id].battles += 1;
    stats[match.b.id].battles += 1;
    stats[match.a.id].score += match.aScore;
    stats[match.b.id].score += match.bScore;
    stats[match.winner.id].wins += 1;
    log(`Manual: "${match.winner.text}" chosen by user (scores ${match.aScore?.toFixed(3) || '—'} vs ${match.bScore?.toFixed(3) || '—'})`);
    return match.winner;
  }

  // UI interactions
  optA.addEventListener('click', ()=>{
    const match = rounds[currentRound][currentMatchIndex];
    if(!match) return;
    if(match.bye){
      // mark advanced and auto-update
      resolveMatchAuto(match);
      setTimeout(advanceMatch, 400);
    } else {
      resolveMatchManual(match, match.a.id);
      markWinnerOnUI(match);
      setTimeout(advanceMatch, 600);
    }
    renderRanking();
    renderTree();
  });

  optB.addEventListener('click', ()=>{
    const match = rounds[currentRound][currentMatchIndex];
    if(!match) return;
    if(match.bye){
      // nothing to pick
      resolveMatchAuto(match);
      setTimeout(advanceMatch, 400);
    } else {
      resolveMatchManual(match, match.b.id);
      markWinnerOnUI(match);
      setTimeout(advanceMatch, 600);
    }
    renderRanking();
    renderTree();
  });

  autoResolveMatchBtn.addEventListener('click', ()=>{
    const match = rounds[currentRound][currentMatchIndex];
    if(!match) return;
    resolveMatchAuto(match);
    markWinnerOnUI(match);
    setTimeout(advanceMatch, 600);
    renderRanking();
    renderTree();
  });

  startBtn.addEventListener('click', ()=>{
    const raw = headlineInput.value.trim();
    const list = raw ? raw.split(/\\n+/).map(s=>s.trim()).filter(Boolean) : defaultHeadlines;
    if(list.length < 2){ alert('Add at least 2 headlines'); return; }
    preparePlayers(list);
    buildTournament();
    log('Tournament started with ' + players.length + ' players');
    renderTree();
    renderRanking();
    renderMatch();
  });

  resetBtn.addEventListener('click', ()=>{
    headlines = [];
    players = [];
    rounds = [];
    stats = {};
    currentRound = 0;
    currentMatchIndex = 0;
    autoRunning = false;
    headlineInput.value = defaultHeadlines.join('\\n');
    pairContainer.style.display = '';
    aText.textContent = bText.textContent = '—';
    aScoreEl.textContent = bScoreEl.textContent = '—';
    roundLabel.textContent = 'Round: —';
    matchCount.textContent = 'Matches: 0';
    treeContainer.innerHTML = '';
    rankingChart.innerHTML = '';
    topList.innerHTML = '';
    log('Reset tournament to defaults.');
  });

  stepBtn.addEventListener('click', ()=>{
    const round = rounds[currentRound];
    if(!round){ log('No tournament running'); return; }
    // step: if current match unresolved, auto-resolve it; else advance to next
    const match = round[currentMatchIndex];
    if(!match) return;
    if(match.winner === null){
      resolveMatchAuto(match);
      markWinnerOnUI(match);
      renderRanking();
      renderTree();
      setTimeout(advanceMatch, 500);
    } else {
      advanceMatch();
    }
  });

  autoAllBtn.addEventListener('click', async ()=>{
    if(autoRunning){ autoRunning = false; log('Auto-run stopped.'); return; }
    if(!rounds.length){ log('No tournament to auto-run'); return; }
    autoRunning = true;
    log('Auto-run started...');
    while(autoRunning && currentRound < rounds.length){
      const round = rounds[currentRound];
      while(autoRunning && currentMatchIndex < round.length){
        const m = rounds[currentRound][currentMatchIndex];
        if(m.winner === null){
          resolveMatchAuto(m);
          markWinnerOnUI(m);
          renderRanking();
          renderTree();
          await new Promise(r=>setTimeout(r, 300 + Math.random()*300));
        }
        await new Promise(r=>setTimeout(r, 80));
        advanceMatch();
      }
      if(currentRound >= rounds.length) break;
    }
    if(autoRunning){ log('Auto-run finished.'); }
    autoRunning = false;
  });

  // visualization
  function renderRanking(){
    // compute ranking list by wins then score
    const items = Object.values(stats).map(o=>({id:o.text, wins:o.wins, score:o.score, battles:o.battles, rawText:o.text}));
    items.sort((x,y)=>{
      if(sortBy === 'wins') return (y.wins - x.wins) || (y.score - x.score);
      return (y.score - x.score) || (y.wins - x.wins);
    });
    topList.innerHTML = '';
    const topN = Math.min(10, items.length);
    for(let i=0;i<topN;i++){
      const it = items[i];
      const div = document.createElement('div');
      div.className = 'top-item';
      div.innerHTML = `<div style="flex:1"><strong style="display:block;font-size:13px">${escapeHtml(it.rawText)}</strong><div class="status" style="margin-top:4px">Battles: ${it.battles} • Wins: ${it.wins}</div></div>
      <div style="width:140px;text-align:right">
        <div class="score-badge">${it.score.toFixed(2)}</div>
        <div style="height:6px;margin-top:6px" class="progress"><i style="width:${Math.round((it.score/(Math.max(1,items[0]?.score||1))) * 100)}%"></i></div>
      </div>`;
      topList.appendChild(div);
    }
    renderBarChart(items);
  }

  function renderBarChart(list){
    // simple SVG bar chart of top 8
    const max = list.length ? Math.max(...list.map(it=>it.score||0), 1) : 1;
    const pad = 10;
    const width = rankingChart.clientWidth || 380;
    const height = rankingChart.clientHeight || 220;
    const svgNS = 'http://www.w3.org/2000/svg';
    rankingChart.innerHTML = '';
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    rankingChart.appendChild(svg);
    const top = Math.min(6, list.length);
    const barH = (height - pad*2) / Math.max(1, top);
    for(let i=0;i<top;i++){
      const it = list[i];
      const y = pad + i*barH;
      const w = Math.max(2, (it.score/max) * (width - 140));
      const g = document.createElementNS(svgNS,'g');
      // background rect
      const bg = document.createElementNS(svgNS,'rect');
      bg.setAttribute('x', pad);
      bg.setAttribute('y', y+4);
      bg.setAttribute('width', width - pad*2);
      bg.setAttribute('height', barH - 8);
      bg.setAttribute('rx', 8);
      bg.setAttribute('fill', 'rgba(255,255,255,0.02)');
      g.appendChild(bg);
      // bar
      const bar = document.createElementNS(svgNS,'rect');
      bar.setAttribute('x', pad);
      bar.setAttribute('y', y+4);
      bar.setAttribute('width', w);
      bar.setAttribute('height', barH - 8);
      bar.setAttribute('rx', 8);
      bar.setAttribute('fill', 'url(#grad)');
      g.appendChild(bar);
      // text
      const t = document.createElementNS(svgNS,'text');
      t.setAttribute('x', width - 130);
      t.setAttribute('y', y + barH/2 + 6);
      t.setAttribute('fill', '#dff6ff');
      t.setAttribute('font-size', '12');
      t.setAttribute('text-anchor', 'end');
      t.textContent = `${it.score.toFixed(2)} / ${it.wins}w`;
      g.appendChild(t);
      // label
      const lbl = document.createElementNS(svgNS,'text');
      lbl.setAttribute('x', pad + 6);
      lbl.setAttribute('y', y + barH/2 + 6);
      lbl.setAttribute('fill', '#a7cfe8');
      lbl.setAttribute('font-size', '12');
      lbl.textContent = it.rawText.length > 40 ? it.rawText.slice(0,40)+'…' : it.rawText;
      g.appendChild(lbl);
      svg.appendChild(g);
    }
    // gradient defs
    const defs = document.createElementNS(svgNS,'defs');
    const lin = document.createElementNS(svgNS,'linearGradient');
    lin.setAttribute('id','grad');
    lin.setAttribute('x1','0%'); lin.setAttribute('x2','100%');
    const stop1 = document.createElementNS(svgNS,'stop'); stop1.setAttribute('offset','0%'); stop1.setAttribute('stop-color','#7dd3fc');
    const stop2 = document.createElementNS(svgNS,'stop'); stop2.setAttribute('offset','100%'); stop2.setAttribute('stop-color','#60a5fa');
    lin.appendChild(stop1); lin.appendChild(stop2);
    defs.appendChild(lin);
    svg.appendChild(defs);
  }

  function renderTree(){
    treeContainer.innerHTML = '';
    for(let r=0;r<rounds.length;r++){
      const roundDiv = document.createElement('div');
      roundDiv.className = 'round';
      const header = document.createElement('div');
      header.className = 'round-header';
      header.innerHTML = `<div style="font-weight:700">Round ${r+1}</div><div class="status">${rounds[r].length} matches</div>`;
      roundDiv.appendChild(header);
      rounds[r].forEach((m,mi)=>{
        const rec = document.createElement('div');
        rec.className = 'match-record';
        const left = document.createElement('div');
        const a = m.a ? m.a.text : '(TBD)';
        const b = m.b ? m.b.text : '(TBD)';
        const winnerText = m.winner ? m.winner.text : '(pending)';
        left.innerHTML = `<div style="font-weight:700">${truncate(a,40)} ${m.b?'<span style="color:var(--muted)"> vs </span>'+truncate(b,40):'<span style="color:var(--muted)"> (bye) </span>'}</div>
                          <div class="status">${m.aScore===null?'':('a:'+ (m.aScore||0).toFixed(3))} ${m.bScore===null?'':(' b:'+ (m.bScore||0).toFixed(3))}</div>`;
        const right = document.createElement('div');
        right.style.textAlign = 'right';
        right.innerHTML = `<div style="font-weight:700;color:${m.winner? 'var(--accent)' : 'var(--muted)'}">${truncate(winnerText,40)}</div>
                           <div class="status">${m.bye ? 'bye' : (m.winner ? 'resolved' : 'pending')}</div>`;
        rec.appendChild(left); rec.appendChild(right);
        roundDiv.appendChild(rec);
      });
      treeContainer.appendChild(roundDiv);
    }
  }

  function markWinnerOnUI(match){
    if(match.winner){
      if(match.winner.id === match.a.id){
        optA.classList.add('winner'); optB.classList.add('loser');
      } else {
        optB.classList.add('winner'); optA.classList.add('loser');
      }
      aScoreEl.textContent = match.aScore === null ? '—' : match.aScore.toFixed(3);
      bScoreEl.textContent = match.bScore === null ? '—' : match.bScore.toFixed(3);
    }
  }

  // helpers
  function truncate(s,n){ if(!s) return ''; return s.length>n? s.slice(0,n-1)+'…' : s; }
  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // initial fill
  headlineInput.value = defaultHeadlines.join('\\n');

  // tree toggles
  showTreeBtn.addEventListener('click', ()=>{
    treeVisible = !treeVisible;
    treeContainer.style.display = treeVisible ? '' : 'none';
    showTreeBtn.textContent = treeVisible ? 'Hide Tree' : 'Show Tree';
  });

  collapseAllBtn.addEventListener('click', ()=>{
    // simple rebuild with minimal info
    if(collapseAllBtn.textContent === 'Collapse'){
      treeContainer.querySelectorAll('.match-record').forEach(m=>m.style.display='none');
      collapseAllBtn.textContent = 'Expand';
    } else {
      treeContainer.querySelectorAll('.match-record').forEach(m=>m.style.display='flex');
      collapseAllBtn.textContent = 'Collapse';
    }
  });

  sortToggle.addEventListener('click', ()=>{
    sortBy = sortBy === 'wins' ? 'score' : 'wins';
    sortToggle.textContent = `Sort: ${sortBy === 'wins' ? 'Wins' : 'Score'}`;
    renderRanking();
  });

  clearLog.addEventListener('click', ()=>{ logArea.innerHTML = ''; });

  exportBtn.addEventListener('click', ()=>{
    const data = {players,rounds,stats};
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([JSON.stringify(data,null,2)],{type:'application/json'}));
    a.download = 'tournament.json';
    a.click();
  });

  // small safety: when user edits scoring function we try to validate minimal content
  customScoring.addEventListener('input', ()=>{
    // no action needed; validation happens when executed
  });

  // init blank render
  renderRanking();
  renderTree();
})();
</script>
</body>
</html>