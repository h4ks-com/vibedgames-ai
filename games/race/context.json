{
  "messages": [
    {
      "role": "user",
      "content": "infinite generated track racing game back view like enduro. Just keeps getting faster, crash 3 times in obstacles you loose, keeps scoring higher and faster proportionaly to speed, there are other cars you have to bypass that work as obstacles too. Fine tune it so that the game is challending and there aren't way too many or too little obstacles.\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Infinite Track Racing</title>\n<style>\n  /* Reset and base */\n  * {\n    box-sizing: border-box;\n  }\n  body, html {\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    background: linear-gradient(#3a9df8, #0a2d62);\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    user-select: none;\n  }\n  #gameCanvas {\n    display: block;\n    margin: 0 auto;\n    background: #222;\n    background-image:\n      radial-gradient(circle at 50% 150%, #555 20%, transparent 70%);\n    image-rendering: pixelated;\n    border: 3px solid #666;\n    border-radius: 8px;\n  }\n  #ui {\n    position: absolute;\n    top: 8px;\n    left: 50%;\n    transform: translateX(-50%);\n    color: #eee;\n    font-weight: 700;\n    text-shadow: 0 0 6px #0008;\n    font-size: 18px;\n    user-select: none;\n  }\n  #message {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    color: #e33;\n    font-size: 36px;\n    font-weight: 900;\n    text-shadow: 0 0 12px #900b;\n    pointer-events: none;\n    user-select: none;\n  }\n  #restartInstructions {\n    position: absolute;\n    top: calc(50% + 50px);\n    left: 50%;\n    transform: translateX(-50%);\n    color: #eee;\n    font-size: 16px;\n    font-weight: 600;\n    text-shadow: 0 0 6px #0008;\n    user-select: none;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"gameCanvas\" width=\"480\" height=\"640\"></canvas>\n<div id=\"ui\">\n  <span id=\"score\">Score: 0</span>\n  &nbsp;&nbsp;&nbsp;\n  <span id=\"crashes\">Crashes: 0 / 3</span>\n  &nbsp;&nbsp;&nbsp;\n  <span id=\"speed\">Speed: 0</span>\n</div>\n<div id=\"message\" style=\"display:none;\">GAME OVER</div>\n<div id=\"restartInstructions\" style=\"display:none;\">Press SPACE to Restart</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('gameCanvas');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width;\n  const H = canvas.height;\n\n  // UI elements\n  const scoreEl = document.getElementById('score');\n  const crashesEl = document.getElementById('crashes');\n  const speedEl = document.getElementById('speed');\n  const messageEl = document.getElementById('message');\n  const restartInstructionsEl = document.getElementById('restartInstructions');\n\n  // Game states\n  let running = true;\n\n  // Constants\n  const TRACK_WIDTH = 320;\n  const TRACK_MARGIN = (W - TRACK_WIDTH) / 2;\n  const LANE_COUNT = 3;\n  const LANE_WIDTH = TRACK_WIDTH / LANE_COUNT;\n  const PLAYER_WIDTH = 28;\n  const PLAYER_HEIGHT = 48;\n  const OBSTACLE_WIDTH = 26;\n  const OBSTACLE_HEIGHT = 40;\n  const OBSTACLE_SPEED_BASE = 0.5;  // Base speed for obstacles relative to player speed\n\n  const MAX_CRASHES = 3;\n  const OBSTACLE_SPAWN_INTERVAL_MIN = 500; // ms\n  const OBSTACLE_SPAWN_INTERVAL_MAX = 1200; // ms\n\n  const MAX_OBSTACLES_ON_SCREEN = 7; // Fine tuning\n\n  // Game variables\n  let score = 0;\n  let crashes = 0;\n  let speed = 4;  // == pixels per frame, will increase progressively.\n  let speedMax = 16;\n  let speedIncRate = 0.0017; // Increase speed per frame - tuning for challenge progression\n\n  // Player car (horizontal lane)\n  // lanes indexed 0..2 -> x position = TRACK_MARGIN + lane * LANE_WIDTH + (LANE_WIDTH - PLAYER_WIDTH)/2\n  let playerLane = 1; // middle lane default\n  let playerX = TRACK_MARGIN + playerLane * LANE_WIDTH + (LANE_WIDTH - PLAYER_WIDTH) / 2;\n  const playerY = H - PLAYER_HEIGHT - 12;\n\n  // Obstacles - array with objects {lane, y, type}\n  // type: 0 = static obstacle, 1 = opponent car\n  let obstacles = [];\n\n  // For obstacle spawn timing controlled to not overspawn:\n  let obstacleTimer = 0;\n  let nextObstacleInterval = randomRange(OBSTACLE_SPAWN_INTERVAL_MIN, OBSTACLE_SPAWN_INTERVAL_MAX);\n\n  // Input state\n  const keys = {\n    left: false,\n    right: false,\n  };\n\n  // Load assets as simple shapes since single file requested (draw shapes)\n  // Colors\n  const COLORS = {\n    trackMarking: '#eee',\n    roadSide: '#111',\n    grass: '#063013',\n    playerCar: '#f44',\n    obstacleStatic: '#a3a3a3',\n    obstacleCar: '#ffaa00',\n    shadow: 'rgba(0,0,0,0.35)',\n  };\n\n  // Background road stripes positions for animation\n  // We'll draw dashed white stripes for lane markings\n  // and side road borders\n  // Use vertical offset to create moving illusion\n\n  let stripesOffset = 0;\n\n  // Functions\n\n  function randomRange(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  function clamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n  }\n\n  function lanesToX(lane) {\n    return TRACK_MARGIN + lane * LANE_WIDTH + (LANE_WIDTH - PLAYER_WIDTH) / 2;\n  }\n\n  function drawRoad() {\n    // Grass\n    ctx.fillStyle = COLORS.grass;\n    ctx.fillRect(0, 0, W, H);\n\n    // Road\n    ctx.fillStyle = '#222';\n    ctx.fillRect(TRACK_MARGIN, 0, TRACK_WIDTH, H);\n\n    // Road sides\n    ctx.fillStyle = COLORS.roadSide;\n    ctx.fillRect(0, 0, TRACK_MARGIN, H);\n    ctx.fillRect(TRACK_MARGIN + TRACK_WIDTH, 0, TRACK_MARGIN, H);\n\n    // Lane markings (center stripes)\n    ctx.strokeStyle = COLORS.trackMarking;\n    ctx.lineWidth = 4;\n    ctx.lineCap = 'round';\n    ctx.setLineDash([20, 30]); // dash pattern\n\n    // Draw lane separators (2 lines)\n    for (let i = 1; i < LANE_COUNT; i++) {\n      let x = TRACK_MARGIN + i * LANE_WIDTH;\n      ctx.beginPath();\n      ctx.moveTo(x, -stripesOffset);\n      ctx.lineTo(x, H + stripesOffset);\n      ctx.stroke();\n    }\n\n    // Solid white line for right/left border inside road area (slightly inset)\n    ctx.setLineDash([]);\n    ctx.lineWidth = 6;\n    ctx.strokeStyle = '#ddd';\n    // Left border line\n    ctx.beginPath();\n    ctx.moveTo(TRACK_MARGIN + 2, 0);\n    ctx.lineTo(TRACK_MARGIN + 2, H);\n    ctx.stroke();\n    // Right border line\n    ctx.beginPath();\n    ctx.moveTo(TRACK_MARGIN + TRACK_WIDTH - 2, 0);\n    ctx.lineTo(TRACK_MARGIN + TRACK_WIDTH - 2, H);\n    ctx.stroke();\n  }\n\n  function drawPlayer() {\n    // Draw shadow ellipse under car\n    ctx.fillStyle = COLORS.shadow;\n    ctx.beginPath();\n    ctx.ellipse(playerX + PLAYER_WIDTH/2, playerY + PLAYER_HEIGHT - 6, PLAYER_WIDTH*0.55, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Car body - red rectangle with rounded corners\n    ctx.fillStyle = COLORS.playerCar;\n    roundRect(ctx, playerX, playerY, PLAYER_WIDTH, PLAYER_HEIGHT, 8);\n    ctx.fill();\n\n    // Windows front and top (light blue)\n    ctx.fillStyle = '#68c8ff';\n    ctx.fillRect(playerX + 5, playerY + 8, PLAYER_WIDTH - 10, 16); // windshield\n    ctx.fillRect(playerX + 7, playerY + 30, PLAYER_WIDTH - 14, 8);  // roof window\n\n    // Headlights - small white rectangles front bottom\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(playerX + 5, playerY + PLAYER_HEIGHT - 14, 6, 6);\n    ctx.fillRect(playerX + PLAYER_WIDTH - 11, playerY + PLAYER_HEIGHT - 14, 6, 6);\n  }\n\n  function roundRect(ctx,x,y,width,height,radius){\n    ctx.beginPath();\n    ctx.moveTo(x+radius,y);\n    ctx.lineTo(x+width-radius,y);\n    ctx.quadraticCurveTo(x+width,y,x+width,y+radius);\n    ctx.lineTo(x+width,y+height-radius);\n    ctx.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);\n    ctx.lineTo(x+radius,y+height);\n    ctx.quadraticCurveTo(x,y+height,x,y+height-radius);\n    ctx.lineTo(x,y+radius);\n    ctx.quadraticCurveTo(x,y,x+radius,y);\n    ctx.closePath();\n  }\n\n  function drawObstacle(obs) {\n    let x = lanesToX(obs.lane);\n    let y = obs.y;\n\n    // Draw shadow ellipse\n    ctx.fillStyle = COLORS.shadow;\n    ctx.beginPath();\n    ctx.ellipse(x + OBSTACLE_WIDTH / 2, y + OBSTACLE_HEIGHT - 6, OBSTACLE_WIDTH * 0.55, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    if (obs.type === 0) {\n      // Static obstacle - gray rock with some texture (circle with darker spots)\n      ctx.fillStyle = COLORS.obstacleStatic;\n      ctx.beginPath();\n      const cx = x + OBSTACLE_WIDTH / 2;\n      const cy = y + OBSTACLE_HEIGHT / 2;\n      ctx.ellipse(cx, cy, OBSTACLE_WIDTH / 2, OBSTACLE_HEIGHT / 2, 0, 0, 2 * Math.PI);\n      ctx.fill();\n\n      ctx.fillStyle = '#777';\n      ctx.beginPath();\n      ctx.ellipse(cx - 6, cy - 7, 6, 5, 0.3, 0, 2 * Math.PI);\n      ctx.fill();\n\n      ctx.beginPath();\n      ctx.ellipse(cx + 7, cy + 5, 5, 3, -0.4, 0, 2 * Math.PI);\n      ctx.fill();\n\n    } else if (obs.type === 1) {\n      // Opponent car - orange rectangle with windows\n      ctx.fillStyle = COLORS.obstacleCar;\n      roundRect(ctx, x, y, OBSTACLE_WIDTH, OBSTACLE_HEIGHT, 6);\n      ctx.fill();\n\n      ctx.fillStyle = '#cc8e00';\n      ctx.fillRect(x + 5, y + 10, OBSTACLE_WIDTH - 10, 12); // windshield\n\n      ctx.fillStyle = '#ffeb7c';\n      ctx.fillRect(x + 6, y + 30, OBSTACLE_WIDTH - 12, 6); // roof window\n\n      // Headlights (front bottom)\n      ctx.fillStyle = '#fff8b0';\n      ctx.fillRect(x + 6, y + OBSTACLE_HEIGHT - 14, 5, 5);\n      ctx.fillRect(x + OBSTACLE_WIDTH - 12, y + OBSTACLE_HEIGHT - 14, 5, 5);\n    }\n  }\n\n  function updateObstacles(deltaTime) {\n    const speedFactor = speed / 4; // base speed is 4\n    // Move each obstacle down depending on speed and type\n    // Opponent cars move slightly slower (towards player)\n    for (let i = obstacles.length -1; i >= 0; i--) {\n      let o = obstacles[i];\n      if (o.type === 1) {\n        // opponent car - moves slower than player speed but down\n        o.y += speed * (1 - OBSTACLE_SPEED_BASE * 0.7);\n      } else {\n        // static obstacles move exactly down at player speed\n        o.y += speed;\n      }\n      // Remove obstacles that have gone past bottom\n      if (o.y > H + 50) {\n        obstacles.splice(i, 1);\n      }\n    }\n\n    // Spawn new obstacles based on timer & density tuning\n\n    obstacleTimer += deltaTime * 1000;\n    // dynamically adjust spawn rate based on speed and number of obstacles on screen.\n    // keep between min and max interval but reduce interval as speed increases (harder)\n    let interval = lerp(OBSTACLE_SPAWN_INTERVAL_MAX, OBSTACLE_SPAWN_INTERVAL_MIN, (speed - 4) / (speedMax - 4));\n    // limit spawn if too many obstacles on screen\n    if (obstacles.length >= MAX_OBSTACLES_ON_SCREEN) {\n      interval = interval * 1.5;\n    }\n\n    if (obstacleTimer > interval) {\n      obstacleTimer = 0;\n      // Spawn an obstacle\n      // Decide obstacle type probabilities:\n      // static obstacles: 65%, cars: 35%, adjusted for fun balance\n      const typeRand = Math.random();\n      let type = (typeRand < 0.65) ? 0 : 1;\n\n      // Pick a lane without obstacle currently near spawn position\n      const lanesBlocked = obstacles.filter(o => o.y < 100).map(o => o.lane);\n      const candidateLanes = [];\n      for(let i=0; i<LANE_COUNT; i++) {\n        if (!lanesBlocked.includes(i)) candidateLanes.push(i);\n      }\n      if (candidateLanes.length === 0) {\n        // all lanes blocked near spawn? just pick random lane anyway\n        candidateLanes.push(randomInt(0, LANE_COUNT - 1));\n      }\n      const lane = candidateLanes[randomInt(0, candidateLanes.length -1)];\n\n      const newObstacle = { lane: lane, y: -OBSTACLE_HEIGHT - randomRange(0, 100), type: type };\n      obstacles.push(newObstacle);\n    }\n  }\n\n  // Utility: linear interpolation\n  function lerp(a, b, t) {\n    return a + (b - a) * t;\n  }\n\n  function randomInt(min, max) {\n    return Math.floor(randomRange(min, max + 1));\n  }\n\n  function detectCollisions() {\n    for (const o of obstacles) {\n      if (o.lane !== playerLane) continue;\n      // bounding box collision check\n      let ox = lanesToX(o.lane);\n      let oy = o.y;\n      // simple rect overlap test:\n      if (\n        playerY < oy + OBSTACLE_HEIGHT - 6 &&\n        playerY + PLAYER_HEIGHT - 12 > oy + 6 &&\n        playerX < ox + OBSTACLE_WIDTH - 4 &&\n        playerX + PLAYER_WIDTH - 4 > ox\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function onCrash() {\n    crashes++;\n    crashesEl.textContent = `Crashes: ${crashes} / ${MAX_CRASHES}`;\n    // Flash screen red quickly\n    flashRed = 10;\n\n    if (crashes >= MAX_CRASHES) {\n      gameOver();\n    }\n  }\n\n  function gameOver() {\n    running = false;\n    messageEl.style.display = 'block';\n    restartInstructionsEl.style.display = 'block';\n  }\n\n  // Control handler\n  window.addEventListener('keydown', e => {\n    if (!running) {\n      if (e.code === 'Space') {\n        resetGame();\n        return;\n      }\n      return;\n    }\n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'KeyA':\n        keys.left = true;\n        break;\n      case 'ArrowRight':\n      case 'KeyD':\n        keys.right = true;\n        break;\n    }\n  });\n  window.addEventListener('keyup', e => {\n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'KeyA':\n        keys.left = false;\n        break;\n      case 'ArrowRight':\n      case 'KeyD':\n        keys.right = false;\n        break;\n    }\n  });\n\n  let flashRed = 0;\n\n  // Main game loop\n  let lastTimeStamp = 0;\n  function loop(time = 0) {\n    if (!lastTimeStamp) lastTimeStamp = time;\n    const deltaTime = (time - lastTimeStamp) / 1000; // seconds\n    lastTimeStamp = time;\n\n    if (running) {\n      // Update speed with progressive acceleration, capped\n      speed = clamp(speed + speedIncRate, 4, speedMax);\n\n      // Update player lane based on input (smooth lane switching maybe?)\n      if (keys.left && playerLane > 0) {\n        playerLane--;\n        keys.left = false; // prevent continuous lane switch, only on press\n      }\n      if (keys.right && playerLane < LANE_COUNT - 1) {\n        playerLane++;\n        keys.right = false;\n      }\n      playerX = lanesToX(playerLane);\n\n      stripesOffset += speed * 4;\n      if (stripesOffset > 50) stripesOffset -= 50;\n\n      // Update obstacles\n      updateObstacles(deltaTime);\n\n      // Update score proportional to speed\n      // Score increase = speed * deltaTime * factor (scaled for challenge)\n      score += speed * deltaTime * 20;\n      scoreEl.textContent = 'Score: ' + Math.floor(score);\n\n      crashesEl.textContent = `Crashes: ${crashes} / ${MAX_CRASHES}`;\n      speedEl.textContent = 'Speed: ' + speed.toFixed(1);\n\n      // Detect collisions\n      if (detectCollisions()) {\n        onCrash();\n        // remove collided obstacles to avoid multi counts\n        obstacles = obstacles.filter(o => !(o.lane === playerLane && o.y + OBSTACLE_HEIGHT > playerY && o.y < playerY + PLAYER_HEIGHT));\n      }\n    }\n\n    // DRAW\n\n    // Clear\n    ctx.clearRect(0, 0, W, H);\n\n    // Draw background road/tracks\n    drawRoad();\n\n    // Draw obstacles\n    obstacles.forEach(drawObstacle);\n\n    // Draw player car\n    drawPlayer();\n\n    // Flash red on crash\n    if (flashRed > 0) {\n      ctx.fillStyle = `rgba(255,0,0,${flashRed / 10 * 0.5})`;\n      ctx.fillRect(0, 0, W, H);\n      flashRed--;\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n  function resetGame() {\n    score = 0;\n    crashes = 0;\n    speed = 4;\n    playerLane = 1;\n    playerX = lanesToX(playerLane);\n    obstacles = [];\n    obstacleTimer = 0;\n    nextObstacleInterval = randomRange(OBSTACLE_SPAWN_INTERVAL_MIN, OBSTACLE_SPAWN_INTERVAL_MAX);\n    running = true;\n    messageEl.style.display = 'none';\n    restartInstructionsEl.style.display = 'none';\n  }\n\n  loop();\n\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}