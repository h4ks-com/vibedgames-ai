{
  "messages": [
    {
      "role": "user",
      "content": "infinite generated track racing game back view like enduro. Just keeps getting faster, crash 3 times in obstacles you loose, keeps scoring higher and faster proportionaly to speed, there are other cars you have to bypass that work as obstacles too. Fine tune it so that the game is challending and there aren't way too many or too little obstacles.\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Infinite Track Racing</title>\n<style>\n  /* Reset and base */\n  * {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  body {\n    background: #111;\n    overflow: hidden;\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    user-select: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n  }\n  #game {\n    display: block;\n    margin: 0 auto;\n    background: linear-gradient(to top, #222 20%, #555 80%);\n    border: 3px solid #666;\n    position: relative;\n  }\n  canvas {\n    display: block;\n    background: #222;\n  }\n  #ui {\n    position: absolute;\n    top: 8px;\n    left: 50%;\n    transform: translateX(-50%);\n    color: #eee;\n    font-weight: bold;\n    font-size: 1.2rem;\n    text-shadow: 0 0 4px #000;\n    pointer-events: none;\n    user-select: none;\n  }\n  #message {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    color: #f33;\n    font-size: 2rem;\n    font-weight: 900;\n    text-align: center;\n    text-shadow: 0 0 6px #900;\n    user-select: none;\n  }\n  #restartBtn {\n    margin-top: 1rem;\n    background: #f33;\n    color: #fff;\n    border: none;\n    padding: 0.5rem 1.5rem;\n    font-weight: 700;\n    font-size: 1rem;\n    border-radius: 5px;\n    cursor: pointer;\n    user-select: none;\n    transition: background-color 0.25s ease;\n  }\n  #restartBtn:hover,\n  #restartBtn:focus {\n    background: #c00;\n    outline: none;\n  }\n</style>\n</head>\n<body>\n<div id=\"game\" style=\"position: relative; width: 480px; height: 640px;\">\n  <canvas id=\"canvas\" width=\"480\" height=\"640\"></canvas>\n  <div id=\"ui\">Score: 0<br>Crashes: 0/3</div>\n  <div id=\"message\" style=\"display: none;\">\n    YOU CRASHED!<br />\n    <button id=\"restartBtn\">Restart</button>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const ui = document.getElementById(\"ui\");\n  const message = document.getElementById(\"message\");\n  const restartBtn = document.getElementById(\"restartBtn\");\n\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n\n  // Game constants\n  const TRACK_WIDTH = WIDTH * 0.7;\n  const TRACK_LINE_WIDTH = 4;\n  const ROAD_SIDE_WIDTH = (WIDTH - TRACK_WIDTH) / 2;\n\n  const CAR_WIDTH = 36;\n  const CAR_HEIGHT = 72;\n  const PLAYER_START_X = WIDTH / 2;\n  const PLAYER_START_Y = HEIGHT - CAR_HEIGHT - 20;\n\n  const MAX_CRASHES = 3;\n\n  // Speed and difficulty tuning\n  const BASE_SPEED = 4;\n  const MAX_SPEED = 20;\n  const ACCELERATION = 0.0015; // speed increase per frame\n\n  const OBSTACLE_WIDTH = 40;\n  const OBSTACLE_HEIGHT = 72;\n\n  const OTHER_CAR_COLOR = \"#b53535\";\n  const OBSTACLE_COLOR = \"#444\";\n\n  const LINE_COLOR = \"#ccc\";\n  const SIDE_STRIPE_COLOR = \"#bbb\";\n\n  const FINISH_LINE_FREQ = 15000; // ms to spawn a brief finishing line, no game ending here, just effect\n\n  // Input state\n  let input = {\n    left: false,\n    right: false,\n  };\n\n  // Game state\n  let player = {\n    x: PLAYER_START_X,\n    y: PLAYER_START_Y,\n    width: CAR_WIDTH,\n    height: CAR_HEIGHT,\n    speed: BASE_SPEED,\n  };\n\n  let obstacles = [];\n  let otherCars = [];\n  let roadLines = [];\n  let crashes = 0;\n  let score = 0;\n  let speed = BASE_SPEED;\n  let frames = 0;\n  let gameOver = false;\n\n  // Lane Calculation\n  // We'll divide the track into 3 lanes to organize cars neatly\n  const LANES = 3;\n  const laneWidth = TRACK_WIDTH / LANES;\n  const laneX = (lane) => ROAD_SIDE_WIDTH + laneWidth * lane + laneWidth / 2;\n\n  class Obstacle {\n    constructor(type, lane, y, speedMultiplier = 1) {\n      this.type = type; // \"static\" or \"car\"\n      this.lane = lane;\n      this.width = OBSTACLE_WIDTH;\n      this.height = OBSTACLE_HEIGHT;\n      this.x = laneX(lane);\n      this.y = y; // y position on screen (vertical)\n      this.speedMultiplier = speedMultiplier; // for other cars to go slightly slower / faster to add challenge\n      this.passed = false;\n    }\n    update(gameSpeed) {\n      this.y += gameSpeed * this.speedMultiplier;\n    }\n    draw(ctx) {\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      if (this.type === \"car\") {\n        // Draw other car (red rectangle with windows)\n        ctx.fillStyle = OTHER_CAR_COLOR;\n        ctx.shadowColor = \"#700\";\n        ctx.shadowBlur = 10;\n        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);\n        // windows\n        ctx.fillStyle = \"#fff\";\n        ctx.fillRect(-this.width / 3, -this.height / 3, this.width / 6, this.height / 8);\n        ctx.fillRect(this.width / 6, -this.height / 3, this.width / 6, this.height / 8);\n        // wheels\n        ctx.fillStyle = \"#222\";\n        ctx.fillRect(-this.width / 2 + 5, this.height / 2 - 10, 10, 5);\n        ctx.fillRect(this.width / 2 - 15, this.height / 2 - 10, 10, 5);\n      } else {\n        // Static obstacle - dark grey boulder shape\n        ctx.fillStyle = OBSTACLE_COLOR;\n        ctx.shadowColor = \"#222\";\n        ctx.shadowBlur = 10;\n        ctx.beginPath();\n        ctx.ellipse(0, 0, this.width / 2, this.height / 3, 0, 0, Math.PI * 2);\n        ctx.fill();\n        // Cracks\n        ctx.strokeStyle = \"#666\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(-10, 0);\n        ctx.lineTo(0, -10);\n        ctx.lineTo(10, 0);\n        ctx.lineTo(0, 10);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n\n  // Player car drawing (simple blueish sport motorbike from back view)\n  function drawPlayer(ctx, x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n\n    // Body\n    ctx.fillStyle = \"#3366cc\";\n    ctx.shadowColor = \"#1144cc\";\n    ctx.shadowBlur = 12;\n    ctx.beginPath();\n    ctx.moveTo(0, CAR_HEIGHT / 2);\n    ctx.lineTo(CAR_WIDTH / 2, -CAR_HEIGHT / 2);\n    ctx.lineTo(-CAR_WIDTH / 2, -CAR_HEIGHT / 2);\n    ctx.closePath();\n    ctx.fill();\n\n    // Lights (back)\n    ctx.fillStyle = \"#ff2222\";\n    ctx.beginPath();\n    ctx.ellipse(-CAR_WIDTH / 4, CAR_HEIGHT / 2 - 10, 8, 15, 0, 0, Math.PI * 2);\n    ctx.ellipse(CAR_WIDTH / 4, CAR_HEIGHT / 2 - 10, 8, 15, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Tires - black side view\n    ctx.fillStyle = \"#111\";\n    ctx.beginPath();\n    ctx.ellipse(-CAR_WIDTH / 2 + 7, CAR_HEIGHT / 2 - 5, 10, 20, 0, 0, Math.PI * 2);\n    ctx.ellipse(CAR_WIDTH / 2 - 7, CAR_HEIGHT / 2 - 5, 10, 20, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  // Draw track sides & stripes\n  function drawTrack(ctx, scroll) {\n    // Draw grass side\n    ctx.fillStyle = \"#0a470a\";\n    ctx.fillRect(0, 0, ROAD_SIDE_WIDTH, HEIGHT);\n    ctx.fillRect(WIDTH - ROAD_SIDE_WIDTH, 0, ROAD_SIDE_WIDTH, HEIGHT);\n\n    // Road surface\n    ctx.fillStyle = \"#444\";\n    ctx.fillRect(ROAD_SIDE_WIDTH, 0, TRACK_WIDTH, HEIGHT);\n\n    // Side white stripes (dashed)\n    ctx.strokeStyle = SIDE_STRIPE_COLOR;\n    ctx.lineWidth = 8;\n    ctx.setLineDash([40, 30]);\n    ctx.lineDashOffset = -scroll * speed * 15;\n    // Left\n    ctx.beginPath();\n    ctx.moveTo(ROAD_SIDE_WIDTH + 4, 0);\n    ctx.lineTo(ROAD_SIDE_WIDTH + 4, HEIGHT);\n    ctx.stroke();\n    // Right\n    ctx.beginPath();\n    ctx.moveTo(WIDTH - ROAD_SIDE_WIDTH - 4, 0);\n    ctx.lineTo(WIDTH - ROAD_SIDE_WIDTH - 4, HEIGHT);\n    ctx.stroke();\n\n    ctx.setLineDash([]);\n\n    // Middle dashed lines between lanes (2 lines)\n    ctx.strokeStyle = LINE_COLOR;\n    ctx.lineWidth = TRACK_LINE_WIDTH;\n    ctx.setLineDash([20, 30]);\n    ctx.lineDashOffset = -scroll * speed * 30;\n\n    for (let i = 1; i < LANES; i++) {\n      let x = ROAD_SIDE_WIDTH + i * laneWidth;\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, HEIGHT);\n      ctx.stroke();\n    }\n\n    ctx.setLineDash([]);\n  }\n\n  // Spawn obstacles dynamically\n  // Goal: keep difficulty balanced: starting slow frequency, slowly increasing with speed\n\n  function spawnObstacles() {\n    // To keep challenge balanced, probability based on speed and frames.\n    // We keep constant approx obstacle density ~ one per 140 px vertical at low speed, ~ one per 80px at high speed.\n\n    // Calculate spawn chance per frame\n    // The faster, the higher the spawn chance (max ~0.04 chance/frame)\n    // At low speed 4, chance ~0.01 per frame\n\n    const baseChance = 0.01;\n    const maxChance = 0.035;\n    const speedFactor = (speed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED);\n    const chance = baseChance + (maxChance - baseChance) * speedFactor;\n\n    if (Math.random() < chance) {\n      // Choose random lane\n      let lane = Math.floor(Math.random() * LANES);\n\n      // Decide obstacle type: mostly other cars, some static obstacles\n      // 70% other cars, 30% static obstacles\n      let isCar = Math.random() < 0.7;\n\n      // Spawn far above visible area so obstacle scrolls down\n      let y = -OBSTACLE_HEIGHT;\n      let speedMultiplier = 1;\n\n      if (isCar) {\n        // other cars can have speed multiplier around 0.8 - 1.1 to add challenge\n        speedMultiplier = 0.85 + Math.random() * 0.5;\n      }\n\n      // Check for overlapping with existing obstacles in nearby y position\n      // so obstacles don't stack too close for impossible situations\n      let safeToSpawn = true;\n      for (let ob of obstacles) {\n        if (\n          ob.lane === lane &&\n          Math.abs(ob.y - y) < OBSTACLE_HEIGHT * 3 // vertical buffer\n        ) {\n          safeToSpawn = false;\n          break;\n        }\n      }\n      if (!safeToSpawn) return;\n\n      obstacles.push(new Obstacle(isCar ? \"car\" : \"static\", lane, y, speedMultiplier));\n    }\n  }\n\n  // Check collision between player and obstacles\n  function checkCollisions() {\n    for (let ob of obstacles) {\n      if (ob.y > HEIGHT + OBSTACLE_HEIGHT) continue; // ignore out of screen\n\n      let dx = Math.abs(ob.x - player.x);\n      let dy = Math.abs(ob.y - player.y);\n\n      // Using rectangles. Player box slightly smaller horizontally (for better fairness)\n      let pw = player.width * 0.7;\n      let ph = player.height * 0.9;\n\n      let ow = ob.width;\n      let oh = ob.height;\n\n      if (dx < (pw / 2 + ow / 2) && dy < (ph / 2 + oh / 2)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Handle input\n  window.addEventListener(\"keydown\", (e) => {\n    if (gameOver) return;\n    if (e.code === \"ArrowLeft\" || e.code === \"KeyA\") input.left = true;\n    else if (e.code === \"ArrowRight\" || e.code === \"KeyD\") input.right = true;\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    if (e.code === \"ArrowLeft\" || e.code === \"KeyA\") input.left = false;\n    else if (e.code === \"ArrowRight\" || e.code === \"KeyD\") input.right = false;\n  });\n\n  // Mobile touch controls - simple left/right half screen touch\n  canvas.addEventListener(\"touchstart\", (e) => {\n    if (gameOver) return;\n    e.preventDefault();\n    for (let touch of e.touches) {\n      const x = touch.clientX - canvas.getBoundingClientRect().left;\n      if (x < WIDTH / 2) input.left = true;\n      else input.right = true;\n    }\n  });\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    // Reset both on any touchend, simple logic\n    input.left = false;\n    input.right = false;\n  });\n  canvas.addEventListener(\"touchcancel\", () => {\n    input.left = false;\n    input.right = false;\n  });\n\n  // Restart button\n  restartBtn.addEventListener(\"click\", () => {\n    resetGame();\n  });\n\n  // Reset game state\n  function resetGame() {\n    obstacles = [];\n    crashes = 0;\n    score = 0;\n    speed = BASE_SPEED;\n    player.x = PLAYER_START_X;\n    player.y = PLAYER_START_Y;\n    gameOver = false;\n    message.style.display = \"none\";\n    ui.style.display = \"block\";\n    lastSpawnTime = 0;\n    lastFinishLineTime = 0;\n    roadScroll = 0;\n    frames = 0;\n    requestAnimationFrame(gameLoop);\n  }\n\n  // Road lines to simulate movement (like Enduro)\n  let roadScroll = 0;\n\n  // Finish line effect spawn timing\n  let lastFinishLineTime = 0;\n\n  function drawFinishLine(yPosition) {\n    // thick white stripes across the road to mimic finish line\n    ctx.save();\n    ctx.strokeStyle = \"#fff\";\n    ctx.lineWidth = 14;\n    ctx.shadowColor = \"#fff\";\n    ctx.shadowBlur = 12;\n    ctx.setLineDash([]);\n    const stripes = 8;\n    const stripeWidth = TRACK_WIDTH / stripes;\n    const lineHeight = 16;\n    let startY = yPosition;\n\n    for (let i = 0; i < stripes; i++) {\n      if (i % 2 === 0) {\n        ctx.fillStyle = \"#fff\";\n      } else {\n        ctx.fillStyle = \"#333\";\n      }\n      ctx.fillRect(\n        ROAD_SIDE_WIDTH + i * stripeWidth,\n        startY - lineHeight / 2,\n        stripeWidth,\n        lineHeight\n      );\n    }\n    ctx.restore();\n  }\n\n  // Game loop\n  function gameLoop(timestamp) {\n    if (gameOver) return;\n\n    frames++;\n    roadScroll += speed;\n\n    // Clear screen\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw track and road lines\n    drawTrack(ctx, roadScroll);\n\n    // Spawn finish line every ~15 seconds for visual effect\n    if (!lastFinishLineTime) lastFinishLineTime = performance.now();\n    if (performance.now() - lastFinishLineTime > FINISH_LINE_FREQ) {\n      // Animate finish line appearing from top\n      const finishLineSpeed = speed * 2;\n      const finishLineHeight = 20;\n      let finishLineY = ((performance.now() - lastFinishLineTime) / 10) - finishLineHeight * 2;\n\n      if (finishLineY < HEIGHT + finishLineHeight) {\n        drawFinishLine(finishLineY);\n      } else {\n        lastFinishLineTime = performance.now();\n      }\n    }\n\n    // Spawn obstacles\n    spawnObstacles();\n\n    // Update obstacles positions\n    for (let i = obstacles.length - 1; i >= 0; i--) {\n      obstacles[i].update(speed);\n      // Remove off-screen obstacles\n      if (obstacles[i].y > HEIGHT + OBSTACLE_HEIGHT) {\n        obstacles.splice(i, 1);\n      }\n    }\n\n    // Draw obstacles\n    for (let ob of obstacles) {\n      ob.draw(ctx);\n    }\n\n    // Handle input & update player position\n    const laneLeftBound = ROAD_SIDE_WIDTH + CAR_WIDTH / 2;\n    const laneRightBound = WIDTH - ROAD_SIDE_WIDTH - CAR_WIDTH / 2;\n    // Player horizontal speed factor (pixels/frame)\n    const playerMoveSpeed = 7;\n\n    if (input.left) {\n      player.x -= playerMoveSpeed;\n      if (player.x < laneLeftBound) player.x = laneLeftBound;\n    }\n    if (input.right) {\n      player.x += playerMoveSpeed;\n      if (player.x > laneRightBound) player.x = laneRightBound;\n    }\n\n    // Draw player\n    drawPlayer(ctx, player.x, player.y);\n\n    // Increase speed gradually until max\n    if (speed < MAX_SPEED) {\n      speed += ACCELERATION;\n      speed = Math.min(speed, MAX_SPEED);\n    }\n\n    // Increase score proportional to speed (e.g. speed^1.3 for bigger reward with speed)\n    score += 0.15 * Math.pow(speed, 1.3);\n\n    // Check collisions\n    if (checkCollisions()) {\n      crashes++;\n      // Remove obstacles close to player that collided to avoid multiple count in same frame\n      obstacles = obstacles.filter(\n        (ob) =>\n          Math.abs(ob.x - player.x) > OBSTACLE_WIDTH * 1.1 ||\n          Math.abs(ob.y - player.y) > OBSTACLE_HEIGHT * 1.1\n      );\n      if (crashes >= MAX_CRASHES) {\n        gameOver = true;\n        ui.style.display = \"none\";\n        message.style.display = \"block\";\n      }\n    }\n\n    // Update UI\n    ui.innerHTML = `Score: ${Math.floor(score)}<br>Crashes: ${crashes}/${MAX_CRASHES}`;\n\n    if (!gameOver) requestAnimationFrame(gameLoop);\n  }\n\n  resetGame();\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}