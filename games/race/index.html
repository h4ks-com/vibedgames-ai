<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Infinite Track Racing - Cars Only</title>
<style>
  /* Reset and base */
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  html, body {
    height: 100%;
    background: #111;
    overflow: hidden;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  #game {
    position: relative;
    margin: 0 auto;
    width: 480px;
    height: 100vh;
    max-height: 100%;
    border: 3px solid #666;
    background: linear-gradient(to top, #222 20%, #555 80%);
    overflow: hidden;
  }
  canvas {
    display: block;
    background: #222;
    width: 100%;
    height: 100%;
  }
  #ui {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    color: #eee;
    font-weight: bold;
    font-size: 1.4rem;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
    user-select: none;
    line-height: 1.3;
  }
  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #f33;
    font-size: 2rem;
    font-weight: 900;
    text-align: center;
    text-shadow: 0 0 6px #900;
    user-select: none;
    display: none;
  }
  #restartBtn {
    margin-top: 1rem;
    background: #f33;
    color: #fff;
    border: none;
    padding: 0.5rem 1.5rem;
    font-weight: 700;
    font-size: 1.1rem;
    border-radius: 5px;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.25s ease;
  }
  #restartBtn:hover,
  #restartBtn:focus {
    background: #c00;
    outline: none;
  }
</style>
</head>
<body>
<div id="game">
  <canvas id="canvas"></canvas>
  <div id="ui">Score: 0<br>Crashes: 0/3</div>
  <div id="message">
    YOU CRASHED!<br />
    <button id="restartBtn">Restart</button>
  </div>
</div>

<script>
(() => {
  const gameDiv = document.getElementById("game");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const ui = document.getElementById("ui");
  const message = document.getElementById("message");
  const restartBtn = document.getElementById("restartBtn");

  // Dimensions
  const WIDTH = 480;
  const HEIGHT = window.innerHeight;

  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  // Constants
  const TRACK_WIDTH = WIDTH * 0.7;
  const ROAD_SIDE_WIDTH = (WIDTH - TRACK_WIDTH) / 2;

  const CAR_WIDTH = 36;
  const CAR_HEIGHT = 72;
  const PLAYER_START_X = WIDTH / 2;
  const PLAYER_START_Y = HEIGHT - CAR_HEIGHT - 20;

  const MAX_CRASHES = 3;

  // Speed parameters (logarithmic scaling with score)
  // speed = minSpeed + log10(1 + score / 200) * scaleSpeed
  const MIN_SPEED = 0; // Start from zero speed
  const MAX_SPEED = 20; // cap max speed
  const SPEED_SCALE = 8; // how fast it increases with score

  // Speed recovery after crash timing (in ms)
  const RECOVERY_TIME = 2000;

  // Lanes setup
  const LANES = 3;
  const laneWidth = TRACK_WIDTH / LANES;
  const laneX = (lane) => ROAD_SIDE_WIDTH + laneWidth * lane + laneWidth / 2;

  // Red other cars color
  const OTHER_CAR_COLOR = "#b53535";

  // Input state
  let input = { left: false, right: false };

  // Game state
  let player = {
    x: PLAYER_START_X,
    y: PLAYER_START_Y,
    width: CAR_WIDTH,
    height: CAR_HEIGHT,
  };

  let obstacles = [];
  let crashes = 0;
  let score = 0;
  let frames = 0;
  let gameOver = false;

  // Speed control variables
  let displayedSpeed = 0; // speed used for moving obstacles etc (smoothly interpolated)
  let targetSpeed = 0;    // speed player is aiming for based on score
  let recoveryStartTime = null; // when crash recovery started (null if not recovering)

  // Player horizontal movement
  const PLAYER_MOVE_SPEED = 7;

  class Obstacle {
    constructor(lane, y, speedMultiplier = 1) {
      this.type = "car";
      this.lane = lane;
      this.width = CAR_WIDTH;
      this.height = CAR_HEIGHT;
      this.x = laneX(lane);
      this.y = y;
      this.speedMultiplier = speedMultiplier;
    }
    update(speed) {
      this.y += speed * this.speedMultiplier;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.fillStyle = OTHER_CAR_COLOR;
      ctx.shadowColor = "#700";
      ctx.shadowBlur = 10;
      ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

      // windows
      ctx.fillStyle = "#fff";
      ctx.fillRect(-this.width / 3, -this.height / 3, this.width / 6, this.height / 8);
      ctx.fillRect(this.width / 6, -this.height / 3, this.width / 6, this.height / 8);

      // wheels
      ctx.fillStyle = "#222";
      ctx.fillRect(-this.width / 2 + 5, this.height / 2 - 10, 10, 5);
      ctx.fillRect(this.width / 2 - 15, this.height / 2 - 10, 10, 5);

      ctx.restore();
    }
  }

  function drawPlayer(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);

    // Body
    ctx.fillStyle = "#3366cc";
    ctx.shadowColor = "#1144cc";
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.moveTo(0, CAR_HEIGHT / 2);
    ctx.lineTo(CAR_WIDTH / 2, -CAR_HEIGHT / 2);
    ctx.lineTo(-CAR_WIDTH / 2, -CAR_HEIGHT / 2);
    ctx.closePath();
    ctx.fill();

    // Lights (back)
    ctx.fillStyle = "#ff2222";
    ctx.beginPath();
    ctx.ellipse(-CAR_WIDTH / 4, CAR_HEIGHT / 2 - 10, 8, 15, 0, 0, Math.PI * 2);
    ctx.ellipse(CAR_WIDTH / 4, CAR_HEIGHT / 2 - 10, 8, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tires - black side view
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.ellipse(-CAR_WIDTH / 2 + 7, CAR_HEIGHT / 2 - 5, 10, 20, 0, 0, Math.PI * 2);
    ctx.ellipse(CAR_WIDTH / 2 - 7, CAR_HEIGHT / 2 - 5, 10, 20, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawTrack(ctx, scroll) {
    // Draw grass sides
    ctx.fillStyle = "#0a470a";
    ctx.fillRect(0, 0, ROAD_SIDE_WIDTH, HEIGHT);
    ctx.fillRect(WIDTH - ROAD_SIDE_WIDTH, 0, ROAD_SIDE_WIDTH, HEIGHT);

    // Road surface
    ctx.fillStyle = "#444";
    ctx.fillRect(ROAD_SIDE_WIDTH, 0, TRACK_WIDTH, HEIGHT);

    // Side white stripes (dashed)
    ctx.strokeStyle = "#bbb";
    ctx.lineWidth = 8;
    ctx.setLineDash([40, 30]);
    ctx.lineDashOffset = -scroll * displayedSpeed * 15;
    // Left
    ctx.beginPath();
    ctx.moveTo(ROAD_SIDE_WIDTH + 4, 0);
    ctx.lineTo(ROAD_SIDE_WIDTH + 4, HEIGHT);
    ctx.stroke();
    // Right
    ctx.beginPath();
    ctx.moveTo(WIDTH - ROAD_SIDE_WIDTH - 4, 0);
    ctx.lineTo(WIDTH - ROAD_SIDE_WIDTH - 4, HEIGHT);
    ctx.stroke();

    ctx.setLineDash([]);

    // Middle dashed lines between lanes (2 lines)
    ctx.strokeStyle = "#ccc";
    ctx.lineWidth = 4;
    ctx.setLineDash([20, 30]);
    ctx.lineDashOffset = -scroll * displayedSpeed * 30;

    for (let i = 1; i < LANES; i++) {
      let x = ROAD_SIDE_WIDTH + i * laneWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, HEIGHT);
      ctx.stroke();
    }

    ctx.setLineDash([]);
  }

  // Spawn only red cars, controlled so they don't cluster and not too many
  function spawnObstacles() {
    // Frequency base chance, influenced by targetSpeed but capped for challenge balance
    const baseChance = 0.012;
    const maxChance = 0.035;
    // Speed factor from 0 to 1 relative to max speed (targetSpeed capped)
    const speedFactor = Math.min(targetSpeed / MAX_SPEED, 1);
    const spawnChance = baseChance + (maxChance - baseChance) * speedFactor;

    if (Math.random() < spawnChance) {
      let lane = Math.floor(Math.random() * LANES);

      // Spawn obstacle y above screen so it scrolls down
      let y = -CAR_HEIGHT;

      // other cars can have speed multipliers 0.85 to 1.15 to add challenge (random)
      let speedMultiplier = 0.85 + Math.random() * 0.3;

      // Avoid overlapping with existing cars in the same lane close by
      for (let ob of obstacles) {
        if (ob.lane === lane && Math.abs(ob.y - y) < CAR_HEIGHT * 3) {
          return; // skip spawn this frame
        }
      }

      obstacles.push(new Obstacle(lane, y, speedMultiplier));
    }
  }

  // Collision check between player and obstacles
  function checkCollisions() {
    for (let ob of obstacles) {
      if (ob.y > HEIGHT + CAR_HEIGHT) continue;

      let dx = Math.abs(ob.x - player.x);
      let dy = Math.abs(ob.y - player.y);

      // Rectangular collision box
      const pw = player.width * 0.7;
      const ph = player.height * 0.9;

      const ow = ob.width;
      const oh = ob.height;

      if (dx < (pw / 2 + ow / 2) && dy < (ph / 2 + oh / 2)) {
        return true;
      }
    }
    return false;
  }

  // Input handlers
  window.addEventListener("keydown", (e) => {
    if (gameOver) return;
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
  });

  // Touch controls (left/right half of canvas)
  canvas.addEventListener("touchstart", (e) => {
    if (gameOver) return;
    e.preventDefault();
    for (let touch of e.touches) {
      const x = touch.clientX - canvas.getBoundingClientRect().left;
      if (x < WIDTH / 2) input.left = true;
      else input.right = true;
    }
  }, { passive: false });
  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    input.left = false;
    input.right = false;
  }, { passive: false });
  canvas.addEventListener("touchcancel", () => {
    input.left = false;
    input.right = false;
  });

  // Restart button
  restartBtn.addEventListener("click", () => {
    resetGame();
  });

  // Utility: calculate target speed from score (logarithmic)
  // speed = MIN_SPEED + SPEED_SCALE * log10(1 + score/200)
  // capped by MAX_SPEED
  function getTargetSpeed(score) {
    return Math.min(
      MIN_SPEED + SPEED_SCALE * Math.log10(1 + score / 200),
      MAX_SPEED
    );
  }

  // Reset game state
  function resetGame() {
    obstacles = [];
    crashes = 0;
    score = 0;
    displayedSpeed = 0;
    targetSpeed = 0;
    recoveryStartTime = null;
    player.x = PLAYER_START_X;
    player.y = PLAYER_START_Y;
    gameOver = false;
    ui.style.display = "block";
    message.style.display = "none";
    lastSpawnTime = 0;
    frames = 0;
    roadScroll = 0;
    requestAnimationFrame(gameLoop);
  }

  // Road scroll to simulate movement
  let roadScroll = 0;

  // Timing for spawning obstacles
  let lastSpawnTime = 0;

  // Game loop
  function gameLoop(timestamp) {
    if (gameOver) return;

    frames++;

    // Update target speed based on score unless recovering from crash
    if (!recoveryStartTime) {
      targetSpeed = getTargetSpeed(score);
    } else {
      // Recovery mode: interpolate displayedSpeed from 0 to targetSpeed over RECOVERY_TIME
      const elapsed = timestamp - recoveryStartTime;
      const progress = Math.min(elapsed / RECOVERY_TIME, 1);
      displayedSpeed = progress * targetSpeed;
      if (progress >= 1) {
        recoveryStartTime = null;
        displayedSpeed = targetSpeed;
      }
    }

    // When NOT recovering, smoothly approach targetSpeed (for small frame jitter)
    if (!recoveryStartTime) {
      const speedDiff = targetSpeed - displayedSpeed;
      displayedSpeed += speedDiff * 0.06; // smooth lerp for minor changes
      if (Math.abs(speedDiff) < 0.02) displayedSpeed = targetSpeed;
    }

    // Move player left/right based on input
    if (!gameOver) {
      if (input.left) {
        player.x -= PLAYER_MOVE_SPEED;
      }
      if (input.right) {
        player.x += PLAYER_MOVE_SPEED;
      }

      const leftBound = ROAD_SIDE_WIDTH + CAR_WIDTH / 2;
      const rightBound = WIDTH - ROAD_SIDE_WIDTH - CAR_WIDTH / 2;

      if (player.x < leftBound) player.x = leftBound;
      if (player.x > rightBound) player.x = rightBound;
    }

    // Clear canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw track with scroll offset
    roadScroll += displayedSpeed;
    drawTrack(ctx, roadScroll);

    // Spawn obstacles (cars) - limit spawn rate by timestamp
    if (timestamp - lastSpawnTime > 600) {
      spawnObstacles();
      lastSpawnTime = timestamp;
    }

    // Update obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].update(displayedSpeed);
      // Remove if off screen
      if (obstacles[i].y > HEIGHT + CAR_HEIGHT) {
        obstacles.splice(i, 1);
      }
    }

    // Draw obstacles
    for (let ob of obstacles) {
      ob.draw(ctx);
    }

    // Draw player
    drawPlayer(ctx, player.x, player.y);

    // Update score proportional to displayedSpeed; faster means quicker scoring
    // Formula: score += displayedSpeed^1.3 * 0.15
    score += Math.pow(displayedSpeed, 1.3) * 0.15;

    // Check collisions only if not recovering or gameover
    if (!recoveryStartTime && !gameOver && checkCollisions()) {
      crashes++;
      if (crashes >= MAX_CRASHES) {
        gameOver = true;
        ui.style.display = "none";
        message.style.display = "block";
      } else {
        // Start recovery speed reset
        recoveryStartTime = timestamp;
        displayedSpeed = 0;
      }
    }

    // Update UI
    ui.innerHTML = `Score: ${Math.floor(score)}<br>Crashes: ${crashes}/${MAX_CRASHES}`;

    if (!gameOver) requestAnimationFrame(gameLoop);
  }

  // Adjust canvas height on resize
  function onResize() {
    const h = window.innerHeight;
    gameDiv.style.height = h + "px";
    canvas.height = h;
  }
  window.addEventListener("resize", onResize);
  onResize();

  // Start game initially
  resetGame();
})();
</script>
</body>
</html>
