<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hanna - h4ks.com AI Overlord</title>
  <style>
    :root{
      --bg:#000;
      --orb:#6d9ff7; /* custom blue */
      --input-bg: rgba(255,255,255,0.04);
      --glass: rgba(255,255,255,0.06);
      --accent: #39b0ff;
      --accent-rgb: 57, 176, 255;
      --text-primary: #eaf6ff;
      --text-secondary: #9fdcff;
      --text-tertiary: #7aaedb;
    }
    
    /* Theme Variations */
    :root[data-theme="cyberpunk"] {
      --bg: #0a0a0a;
      --orb: #ff0080;
      --accent: #ff0080;
      --accent-rgb: 255, 0, 128;
      --glass: rgba(255, 0, 128, 0.1);
      --text-primary: #ff66b3;
      --text-secondary: #ff99cc;
      --text-tertiary: #cc6699;
    }
    
    :root[data-theme="nature"] {
      --bg: #0d1b0d;
      --orb: #4CAF50;
      --accent: #4CAF50;
      --accent-rgb: 76, 175, 80;
      --glass: rgba(76, 175, 80, 0.1);
      --text-primary: #a8e6a3;
      --text-secondary: #81c784;
      --text-tertiary: #66bb6a;
    }
    
    :root[data-theme="sunset"] {
      --bg: #1a0d0a;
      --orb: #ff6b35;
      --accent: #ff6b35;
      --accent-rgb: 255, 107, 53;
      --glass: rgba(255, 107, 53, 0.1);
      --text-primary: #ffcbb3;
      --text-secondary: #ffab80;
      --text-tertiary: #ff8a50;
    }
    
    :root[data-theme="galaxy"] {
      --bg: #0a0520;
      --orb: #9c27b0;
      --accent: #9c27b0;
      --accent-rgb: 156, 39, 176;
      --glass: rgba(156, 39, 176, 0.1);
      --text-primary: #e1bee7;
      --text-secondary: #ce93d8;
      --text-tertiary: #ba68c8;
    }
    
    :root[data-theme="retro"] {
      --bg: #1a1a00;
      --orb: #ffeb3b;
      --accent: #ffeb3b;
      --accent-rgb: 255, 235, 59;
      --glass: rgba(255, 235, 59, 0.1);
      --text-primary: #fff59d;
      --text-secondary: #fff176;
      --text-tertiary: #ffee58;
    }
    
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;overflow:hidden;transition:background 0.5s ease}
    .main-layout{display:grid;grid-template-columns:1fr;grid-template-rows:auto 1fr auto auto;height:100vh;position:relative;z-index:3}
    .main-layout.editor-open{grid-template-columns:1fr 50vw}
    
    .theme-selector-container {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
    }
    
    .theme-selector {
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    .theme-selector:hover {
      background: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .theme-selector option {
      background: var(--bg);
      color: var(--text-primary);
    }
    .stage{display:flex;flex-direction:column;align-items:center;justify-content:flex-end;height:100%;gap:20px;padding:24px;box-sizing:border-box;position:relative;z-index:3;pointer-events:auto}
    canvas{display:block;width:100%;height:100%;background:transparent;filter:blur(6px);grid-column:1;grid-row:1 / 5;z-index:0;pointer-events:none}

    .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;pointer-events:auto;grid-row:3;grid-column:1;padding:0 24px 16px 24px;z-index:4;position:relative}
    button{background:var(--glass);border:1px solid rgba(255,255,255,0.06);color:#eaf6ff;padding:8px 12px;border-radius:10px;cursor:pointer;backdrop-filter:blur(6px);pointer-events:auto}
    .input-row{display:flex;gap:10px;align-items:center;width:min(780px,92vw);pointer-events:auto;grid-row:4;grid-column:1;justify-self:center;padding:0 24px 24px 24px;z-index:4;position:relative}
    .text-input{flex:1;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:var(--input-bg);color:#eaf6ff;outline:none;font-size:16px;pointer-events:auto}
    .send{padding:12px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#2bb1ff22,#3aa0ff22);color:#eaf6ff;cursor:pointer;pointer-events:auto}
    .label{font-size:13px;color:#9fdcff;margin-bottom:6px;text-align:center;grid-row:1;grid-column:1;padding:24px 24px 0 24px;align-self:center;z-index:4;position:relative}

    .small-note{font-size:12px;color:#7aaedb;text-align:center;margin-top:6px}
    
    /* Chat area styling */
    .chat-area{
      grid-row: 2;
      grid-column: 1;
      padding: 20px;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 16px;
      pointer-events: auto;
      position: relative;
      z-index: 2;
    }
    
    /* Message bubbles with enhanced glass effect */
    .message{
      max-width:45%;
      padding:16px 20px;
      border-radius:20px;
      font-size:13px;
      line-height:1.5;
      position:relative;
      backdrop-filter:blur(20px);
      -webkit-backdrop-filter:blur(20px);
      border:1px solid rgba(255,255,255,0.15);
      box-shadow:0 8px 32px rgba(0,0,0,0.3), 
                 inset 0 1px 0 rgba(255,255,255,0.2),
                 0 1px 0 rgba(255,255,255,0.1);
      word-wrap:break-word;
      animation:messageSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events:auto;
    }
    
    @keyframes messageSlideIn {
      from { opacity: 0; transform: translateY(20px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    .message.user{
      background:linear-gradient(135deg, rgba(57,176,255,0.2), rgba(57,176,255,0.1));
      color:#eaf6ff;
      align-self:flex-end;
      margin-left:auto;
      border-color:rgba(57,176,255,0.4);
    }
    
    .message.user::before{
      content:'';
      position:absolute;
      top:16px;
      right:-8px;
      width:0;
      height:0;
      border-left:8px solid rgba(57,176,255,0.2);
      border-top:8px solid transparent;
      border-bottom:8px solid transparent;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .message.assistant{
      background:linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      color:#9fdcff;
      align-self:flex-start;
      margin-right:auto;
      border-color:rgba(159,220,255,0.3);
    }
    
    .message.assistant::before{
      content:'';
      position:absolute;
      top:16px;
      left:-8px;
      width:0;
      height:0;
      border-right:8px solid rgba(255,255,255,0.12);
      border-top:8px solid transparent;
      border-bottom:8px solid transparent;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    /* Typing indicator */
    .typing-indicator {
      max-width: 45%;
      padding: 16px 20px;
      border-radius: 20px;
      background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(159,220,255,0.3);
      align-self: flex-start;
      margin-right: auto;
      animation: messageSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: auto;
    }
    
    .typing-dots {
      display: flex;
      gap: 4px;
    }
    
    .typing-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #9fdcff;
      animation: typingDots 1.4s infinite ease-in-out;
    }
    
    .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
    .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes typingDots {
      0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
      40% { opacity: 1; transform: scale(1); }
    }
    
    .chat-toggle{position:fixed;top:20px;right:20px;background:var(--glass);border:1px solid rgba(255,255,255,0.06);color:#eaf6ff;padding:8px 12px;border-radius:8px;cursor:pointer;backdrop-filter:blur(6px);z-index:3;display:none}

    /* Windows Loading Spinner */
    .windows-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .windows-spinner.active {
      opacity: 1;
    }
    
    .windows-spinner::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid transparent;
      border-top: 2px solid #39b0ff;
      border-radius: 50%;
      animation: windowsSpin 1s linear infinite;
    }
    
    @keyframes windowsSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* subtle glow effect for the canvas container when orb is active */
    .glow{box-shadow:0 8px 40px rgba(57,176,255,0.06) inset, 0 6px 40px rgba(57,176,255,0.06)}

    /* Remove mobile canvas size restriction for fullscreen effect */
    
    /* Code block table styling */
    .code-block-table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 255, 0, 0.3);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    .code-block-header {
      background: linear-gradient(135deg, rgba(0, 30, 0, 0.9), rgba(0, 50, 0, 0.7));
      color: #00ff00;
      padding: 8px 12px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid rgba(0, 255, 0, 0.3);
      text-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
    }
    
    .code-block-content {
      background: rgba(0, 0, 0, 0.95);
      color: #00ff00;
      padding: 16px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
      text-shadow: 0 0 2px rgba(0, 255, 0, 0.3);
      border: none;
    }
    
    /* Syntax highlighting for common languages */
    .code-block-content .keyword {
      color: #ff6b6b;
      text-shadow: 0 0 2px rgba(255, 107, 107, 0.3);
    }
    
    .code-block-content .string {
      color: #4ecdc4;
      text-shadow: 0 0 2px rgba(78, 205, 196, 0.3);
    }
    
    .code-block-content .comment {
      color: #6c757d;
      font-style: italic;
    }
    
    .code-block-content .number {
      color: #feca57;
      text-shadow: 0 0 2px rgba(254, 202, 87, 0.3);
    }
    
    /* Enhanced Message Rendering Styles */
    .expandable-section {
      margin: 8px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }
    
    .expandable-section summary {
      padding: 12px 16px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.05);
      color: #9fdcff;
      font-weight: 500;
      border: none;
      outline: none;
      transition: background 0.2s ease;
    }
    
    .expandable-section summary:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .expandable-section .content {
      padding: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      animation: expandIn 0.3s ease-out;
    }
    
    @keyframes expandIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .msg-action-btn {
      display: inline-block;
      margin: 4px 8px 4px 0;
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(57,176,255,0.2), rgba(57,176,255,0.1));
      border: 1px solid rgba(57,176,255,0.4);
      border-radius: 6px;
      color: #eaf6ff;
      cursor: pointer;
      font-size: 12px;
      text-decoration: none;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }
    
    .msg-action-btn:hover {
      background: linear-gradient(135deg, rgba(57,176,255,0.3), rgba(57,176,255,0.2));
      border-color: rgba(57,176,255,0.6);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(57,176,255,0.2);
    }
    
    .msg-action-btn:active {
      transform: translateY(0);
    }
    
    .math-equation {
      margin: 12px 0;
      padding: 16px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      text-align: center;
      font-family: 'Times New Roman', serif;
      color: #eaf6ff;
      overflow-x: auto;
    }
    
    .mermaid-diagram {
      margin: 16px 0;
      padding: 16px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      text-align: center;
      overflow-x: auto;
    }
    
    .file-attachment {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 8px 0;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .file-attachment:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(57,176,255,0.3);
    }
    
    .file-icon {
      width: 32px;
      height: 32px;
      background: rgba(57,176,255,0.3);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    
    .file-info {
      flex: 1;
    }
    
    .file-name {
      font-weight: 500;
      color: #eaf6ff;
      margin-bottom: 2px;
    }
    
    .file-size {
      font-size: 11px;
      color: #9fdcff;
    }
    
    .download-btn {
      padding: 6px 12px;
      background: rgba(57,176,255,0.2);
      border: 1px solid rgba(57,176,255,0.4);
      border-radius: 4px;
      color: #eaf6ff;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .download-btn:hover {
      background: rgba(57,176,255,0.3);
    }
    
    .message-metadata {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 11px;
      color: #7aaedb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .message-tags {
      display: flex;
      gap: 4px;
    }
    
    .message-tag {
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      font-size: 10px;
    }
    
    /* Theme Selector Styles */
    .theme-selector {
      padding: 8px 12px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--text-primary);
      border-radius: 10px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      font-size: 12px;
      outline: none;
      transition: all 0.2s ease;
    }
    
    .theme-selector:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255,255,255,0.15);
    }
    
    .theme-selector option {
      background: var(--bg);
      color: var(--text-primary);
    }
    
    /* Demo Button Styles */
    .demo-trigger {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.1));
      border-color: rgba(255, 215, 0, 0.4);
    }
    
    .demo-trigger:hover {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 165, 0, 0.2));
      border-color: rgba(255, 215, 0, 0.6);
    }
    
    /* Voice Control Button */
    .voice-trigger {
      background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.1));
      border-color: rgba(138, 43, 226, 0.4);
    }
    
    .voice-trigger:hover {
      background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(75, 0, 130, 0.2));
      border-color: rgba(138, 43, 226, 0.6);
    }
    
    .voice-trigger.listening {
      background: linear-gradient(135deg, rgba(255, 69, 0, 0.3), rgba(255, 20, 147, 0.2));
      border-color: rgba(255, 69, 0, 0.6);
      animation: voicePulse 1s infinite ease-in-out;
    }
    
    @keyframes voicePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <div class="main-layout">
    <!-- Theme selector in top-left corner -->
    <div class="theme-selector-container">
      <select id="themeSelector" class="theme-selector">
        <option value="default">🌊 Ocean</option>
        <option value="cyberpunk">🌃 Cyberpunk</option>
        <option value="nature">🌲 Nature</option>
        <option value="sunset">🌅 Sunset</option>
        <option value="galaxy">🌌 Galaxy</option>
        <option value="retro">📺 Retro</option>
      </select>
    </div>
    

    
    <canvas id="runaCanvas"></canvas>
    
  <div class="label">Hanna — h4ks.com AI Overlord</div>

    <!-- Chat area -->
    <div class="chat-area" id="chatMessages"></div>

    <div class="controls">
    </div>

    <div class="input-row">
      <input id="userInput" class="text-input" placeholder="Ask Hanna anything..." />
      <button id="sendBtn" class="send">Send</button>
    </div>

  <!-- ...existing code... -->
  </div>

<script>
/*
  Runa Prototype
  - Canvas-based neon orb with trailing tail
  - States: idle, thinking, searching, pattern-* (scripts)
  - How to integrate with n8n: edit N8N_ENDPOINT and uncomment fetch in sendMessage()
*/

const canvas = document.getElementById('runaCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
let W, H, DPR;

function resize(){
  DPR = window.devicePixelRatio || 1;
  W = canvas.width = Math.floor(canvas.clientWidth * DPR);
  H = canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

// Config
const ORB_COLOR = '#6d9ff7';
const ORB_RADIUS = 6; // visual radius in CSS pixels (reduced from 12)
const TAIL_LENGTH = 75; // halved for better proportions
const FRICTION = 0.92;

// State machine
let state = 'idle';
let windowsLoadingAngle = 0; // Track angle for windows loading spinner
let errorStartTime = 0; // Track when error state started
let criticalErrorStartTime = 0; // Track when critical error state started
let transitionStartTime = 0; // Track transition timing
let transitionFromColor = ORB_COLOR; // Color to transition from
let transitionToColor = ORB_COLOR; // Color to transition to
let dvdVelocity = { x: 2, y: 1.5 }; // DVD bounce velocity
let pipesDirection = { x: 1, y: 0 }; // Current direction for pipes (right, down, left, up)
let pipesSpeed = 1.5; // Speed along the pipe
let pipesLastTurn = 0; // Time since last turn
let pipesSegmentLength = 0; // Current segment progress
let errorSparks = []; // Array to hold spark particles
let networkScanPulses = []; // Array to hold radar pulses
let networkNodes = []; // Array to hold discovered nodes
let networkDataPackets = []; // Data flowing between nodes
let networkSecurityAlerts = []; // Security threat indicators
let networkInterference = []; // Signal interference effects
let networkHealthPulses = []; // Health status indicators
let typewriterOrbs = []; // Multiple orbs for typewriter effect
let fadingTypewriterOrbs = []; // Orbs that are fading out when transitioning
let typewriterState = { cursor: { x: 0, y: 0, visible: true, blinkTime: 0 } };
let typewriterStartTime = 0; // When typewriter animation started
let companionTrails = [[], []]; // Separate trail arrays for companion orbs
let fadingCompanionTrails = [[], []]; // Trails for fading orbs
let companionLastTrailPos = [{x: 0, y: 0}, {x: 0, y: 0}]; // Last trail positions for companions
let networkScanStartTime = 0; // Track when network scan started

// New animation variables
let matrixRainDrops = []; // Array for matrix rain effect
let excitementBounces = []; // Array for excitement bounce particles
let sleepyFadePhase = 0; // Current phase of sleepy animation
let constellationStars = []; // Array of constellation stars
let constellationConnections = []; // Array of star connections
let galaxySpiralArms = []; // Array of spiral arm particles
let celebrationParticles = []; // Array of celebration particles

let orb = {
  x: W/2, y: H/2, vx:0, vy:0, ax:0, ay:0, r:ORB_RADIUS, trail:[], color: ORB_COLOR
};

// Theme System
let currentTheme = 'default';

// Theme definitions
const themes = {
  default: {
    orb: '#6d9ff7',
    name: 'Ocean'
  },
  cyberpunk: {
    orb: '#ff0080',
    name: 'Cyberpunk'
  },
  nature: {
    orb: '#4CAF50',
    name: 'Nature'
  },
  sunset: {
    orb: '#ff6b35',
    name: 'Sunset'
  },
  galaxy: {
    orb: '#9c27b0',
    name: 'Galaxy'
  },
  retro: {
    orb: '#ffeb3b',
    name: 'Retro'
  }
};

// Get current theme's orb color
function getCurrentThemeOrbColor() {
  return themes[currentTheme]?.orb || '#6d9ff7';
}

// Apply theme
function applyTheme(themeName) {
  currentTheme = themeName;
  document.documentElement.setAttribute('data-theme', themeName);
  
  // Update orb color if in states that should use theme color
  if(state === 'idle' || state === 'thinking' || state === 'searching' || state === 'typewriter') {
    orb.color = themes[themeName].orb;
  }
  
  // Save theme preference
  localStorage.setItem('runaTheme', themeName);
  
  console.log(`Theme changed to: ${themes[themeName].name}`);
}

// Helpers
function rand(min,max){return Math.random()*(max-min)+min}
function ease(t){return (--t)*t*t+1} // cubic ease out

// Color interpolation helper
function interpolateColor(color1, color2, t) {
  // Extract RGB values from hex colors
  const r1 = parseInt(color1.slice(1, 3), 16);
  const g1 = parseInt(color1.slice(3, 5), 16);
  const b1 = parseInt(color1.slice(5, 7), 16);
  
  const r2 = parseInt(color2.slice(1, 3), 16);
  const g2 = parseInt(color2.slice(3, 5), 16);
  const b2 = parseInt(color2.slice(5, 7), 16);
  
  // Interpolate
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  
  return `rgb(${r}, ${g}, ${b})`;
}

// update trail
function addTrail(x,y,alpha){
  orb.trail.unshift({x,y,a:alpha,color:orb.color});
  if(orb.trail.length>TAIL_LENGTH) orb.trail.pop();
}

// Add trail points more frequently for smoother lines
let lastTrailX = 0, lastTrailY = 0;
function addTrailPoint(x, y, alpha) {
  const distance = Math.sqrt((x - lastTrailX) ** 2 + (y - lastTrailY) ** 2);
  if (distance > 1.5 || orb.trail.length === 0) { // Add point every 1.5 pixels for smoother trail
    addTrail(x, y, alpha);
    lastTrailX = x;
    lastTrailY = y;
  }
}

function addCompanionTrailPoint(x, y, alpha, companionIndex) {
  const lastPos = companionLastTrailPos[companionIndex];
  const distance = Math.sqrt((x - lastPos.x) ** 2 + (y - lastPos.y) ** 2);
  if (distance > 1.5 || companionTrails[companionIndex].length === 0) {
    companionTrails[companionIndex].push({x, y, alpha, color: orb.color});
    if(companionTrails[companionIndex].length > 50) { // use same length as main orb trail
      companionTrails[companionIndex].shift();
    }
    lastPos.x = x;
    lastPos.y = y;
  }
}

// draw neon orb + trail
function draw(){
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

  // Police siren background for critical error
  if(state === 'critical-error') {
    const rotation = tick * 0.004; // 2x speed - gentle but noticeable
    const centerX = canvas.clientWidth / 2;
    const centerY = canvas.clientHeight / 2;
    const radius = Math.max(canvas.clientWidth, canvas.clientHeight);
    
    // Create rotating red/blue gradient
    const gradient = ctx.createLinearGradient(
      centerX + Math.cos(rotation) * radius,
      centerY + Math.sin(rotation) * radius,
      centerX + Math.cos(rotation + Math.PI) * radius,
      centerY + Math.sin(rotation + Math.PI) * radius
    );
    
    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)'); // red
    gradient.addColorStop(0.5, 'rgba(0, 0, 255, 0.3)'); // blue  
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)'); // red
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  }

  // draw trail
  if(orb.trail.length > 1) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Draw segments with proper fading
    for(let i = 0; i < orb.trail.length - 1; i++) {
      const p1 = orb.trail[i];
      const p2 = orb.trail[i + 1];
      const t = i / (orb.trail.length - 1);
      
      // Calculate alpha and thickness that properly fade
      const alpha = Math.pow(1 - t, 2); // quadratic fade for smoother transition
      const thickness = orb.r * 2 * (0.1 + 0.9 * (1 - t));
      
      if(alpha > 0.01) { // only draw if visible
        ctx.beginPath();
        ctx.globalAlpha = alpha * 0.8;
        ctx.strokeStyle = p1.color || orb.color; // use stored color or fallback to current orb color
        ctx.lineWidth = thickness;
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
      }
    }
    
    ctx.globalAlpha = 1; // reset alpha
  }

  // outer glow
  const g = ctx.createRadialGradient(orb.x, orb.y, orb.r*0.4, orb.x, orb.y, orb.r*6);
  if(orb.color === '#ff4444') {
    // Red glow for error state
    g.addColorStop(0, 'rgba(255,68,68,0.22)');
    g.addColorStop(0.6, 'rgba(255,68,68,0.08)');
    g.addColorStop(1, 'rgba(255,68,68,0)');
  } else if(orb.color === '#44ff44') {
    // Green glow
    g.addColorStop(0, 'rgba(68,255,68,0.22)');
    g.addColorStop(0.6, 'rgba(68,255,68,0.08)');
    g.addColorStop(1, 'rgba(68,255,68,0)');
  } else if(orb.color === '#ffff44') {
    // Yellow glow
    g.addColorStop(0, 'rgba(255,255,68,0.22)');
    g.addColorStop(0.6, 'rgba(255,255,68,0.08)');
    g.addColorStop(1, 'rgba(255,255,68,0)');
  } else if(orb.color === '#ff44ff') {
    // Magenta glow
    g.addColorStop(0, 'rgba(255,68,255,0.22)');
    g.addColorStop(0.6, 'rgba(255,68,255,0.08)');
    g.addColorStop(1, 'rgba(255,68,255,0)');
  } else if(orb.color === '#44ffff') {
    // Cyan glow
    g.addColorStop(0, 'rgba(68,255,255,0.22)');
    g.addColorStop(0.6, 'rgba(68,255,255,0.08)');
    g.addColorStop(1, 'rgba(68,255,255,0)');
  } else {
    // Normal blue glow
    g.addColorStop(0, 'rgba(57,176,255,0.22)');
    g.addColorStop(0.6, 'rgba(57,176,255,0.08)');
    g.addColorStop(1, 'rgba(57,176,255,0)');
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(orb.x, orb.y, orb.r*6, 0, Math.PI*2);
  ctx.fill();

  // core neon
  ctx.beginPath();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = orb.color; // use dynamic color
  ctx.globalAlpha = 1;
  ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI*2);
  ctx.fill();

  // sharp spec
  ctx.beginPath();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.arc(orb.x - orb.r*0.35, orb.y - orb.r*0.35, orb.r*0.28, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 1;
  
  // Draw network scan elements
  if(state === 'network-scan') {
    ctx.globalCompositeOperation = 'lighter';
    
    // Draw radar pulses
    for(let pulse of networkScanPulses) {
      const alpha = pulse.life / pulse.maxLife;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(57, 176, 255, ${alpha * 0.6})`;
      ctx.lineWidth = 2;
      ctx.globalAlpha = alpha;
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner pulse ring
      ctx.beginPath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
      ctx.lineWidth = 1;
      ctx.arc(pulse.x, pulse.y, pulse.radius * 0.8, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Draw discovered network nodes
    for(let node of networkNodes) {
      const nodeAge = tick - node.discoveredTime;
      const nodeAlpha = Math.min(1, nodeAge / 200) * Math.max(0, 1 - nodeAge / 8000);
      const nodePulse = Math.sin(tick * 0.01 + node.pulsePhase) * 0.3 + 0.7;
      
      if(node.type === 'server') {
        // Server nodes - larger, more prominent
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 200, 100, ${nodeAlpha * 0.8})`;
        ctx.globalAlpha = nodeAlpha * nodePulse;
        ctx.arc(node.x, node.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Server indicator ring
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 200, 100, ${nodeAlpha * 0.6})`;
        ctx.lineWidth = 1;
        ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        // Client nodes - smaller, blue
        ctx.beginPath();
        ctx.fillStyle = `rgba(100, 200, 255, ${nodeAlpha * 0.7})`;
        ctx.globalAlpha = nodeAlpha * nodePulse;
        ctx.arc(node.x, node.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Connection lines to center (faint)
      if(nodeAlpha > 0.5) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(57, 176, 255, ${nodeAlpha * 0.1})`;
        ctx.lineWidth = 1;
        ctx.globalAlpha = nodeAlpha * 0.3;
        ctx.moveTo(orb.x, orb.y);
        ctx.lineTo(node.x, node.y);
        ctx.stroke();
      }
    }
    
    // Draw data packets flowing between nodes
    for(let packet of networkDataPackets) {
      const currentX = packet.startX + (packet.endX - packet.startX) * packet.progress;
      const currentY = packet.startY + (packet.endY - packet.startY) * packet.progress;
      const alpha = packet.life / packet.maxLife;
      
      // Main packet dot
      ctx.beginPath();
      ctx.fillStyle = packet.color;
      ctx.globalAlpha = alpha * 0.9;
      ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Packet trail
      for(let i = 1; i <= 3; i++) {
        const trailProgress = Math.max(0, packet.progress - i * 0.05);
        const trailX = packet.startX + (packet.endX - packet.startX) * trailProgress;
        const trailY = packet.startY + (packet.endY - packet.startY) * trailProgress;
        const trailAlpha = alpha * (1 - i * 0.3);
        
        ctx.beginPath();
        ctx.fillStyle = packet.color;
        ctx.globalAlpha = trailAlpha * 0.5;
        ctx.arc(trailX, trailY, 3 - i, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Draw security alerts
    for(let alert of networkSecurityAlerts) {
      const alpha = alert.life / alert.maxLife;
      const pulseIntensity = Math.sin(tick * 0.2) * 0.5 + 0.5;
      
      if(alert.severity === 'critical') {
        // Critical alerts - red pulsing
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 50, 50, ${alpha * pulseIntensity * 0.8})`;
        ctx.lineWidth = 3;
        ctx.globalAlpha = alpha;
        ctx.arc(alert.x, alert.y, alert.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner danger zone
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 50, 50, ${alpha * pulseIntensity * 0.2})`;
        ctx.arc(alert.x, alert.y, alert.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Warning alerts - yellow
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 200, 50, ${alpha * 0.6})`;
        ctx.lineWidth = 2;
        ctx.globalAlpha = alpha;
        ctx.arc(alert.x, alert.y, alert.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // Draw network interference
    for(let interference of networkInterference) {
      const alpha = interference.life / interference.maxLife;
      ctx.globalAlpha = alpha * interference.intensity;
      
      if(interference.pattern === 'static') {
        // Static interference
        for(let i = 0; i < 20; i++) {
          const x = interference.x + (Math.random() - 0.5) * 60;
          const y = interference.y + (Math.random() - 0.5) * 60;
          ctx.beginPath();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + (Math.random() - 0.5) * 10, y + (Math.random() - 0.5) * 10);
          ctx.stroke();
        }
      } else {
        // Wave interference
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
        ctx.lineWidth = 2;
        const waveRadius = 30 + Math.sin(tick * 0.1) * 10;
        ctx.arc(interference.x, interference.y, waveRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // Draw network health pulses
    for(let healthPulse of networkHealthPulses) {
      const alpha = healthPulse.life / healthPulse.maxLife;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(0, 255, 136, ${alpha * 0.6})`;
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha;
      ctx.arc(healthPulse.x, healthPulse.y, healthPulse.radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
  }
  
  // Draw typewriter effect
  if(state === 'typewriter') {
    ctx.globalCompositeOperation = 'lighter';
    
    // Draw trails for companion orbs (same style as main orb)
    for(let i = 0; i < companionTrails.length; i++) {
      const trail = companionTrails[i];
      if(trail.length > 1) {
        ctx.globalCompositeOperation = 'lighter';
        for(let j = 1; j < trail.length; j++) {
          const prev = trail[j-1];
          const curr = trail[j];
          const progress = j / trail.length;
          const alpha = progress * 0.8; // fade along trail
          
          ctx.beginPath();
          ctx.strokeStyle = prev.color || orb.color; // use stored color or fallback
          ctx.lineWidth = ORB_RADIUS * 2 * alpha;
          ctx.globalAlpha = alpha;
          ctx.lineCap = 'round';
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }
    
    // Draw the two companion orbs (main orb is drawn normally)
    for(let i = 0; i < typewriterOrbs.length; i++) {
      let companionOrb = typewriterOrbs[i];
      
      // Only draw if the orb has started moving or oscillating
      if(companionOrb.splitProgress > 0 || companionOrb.currentAmplitude > 0) {
        // Outer glow (same as main orb)
        ctx.beginPath();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = companionOrb.alpha * 0.7;
        const g = ctx.createRadialGradient(companionOrb.x, companionOrb.y, 0, companionOrb.x, companionOrb.y, ORB_RADIUS * 6);
        g.addColorStop(0, 'rgba(57,176,255,0.22)');
        g.addColorStop(0.6, 'rgba(57,176,255,0.08)');
        g.addColorStop(1, 'rgba(57,176,255,0)');
        ctx.fillStyle = g;
        ctx.arc(companionOrb.x, companionOrb.y, ORB_RADIUS * 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Core neon
        ctx.beginPath();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = companionOrb.color;
        ctx.globalAlpha = companionOrb.alpha;
        ctx.arc(companionOrb.x, companionOrb.y, ORB_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Sharp spec highlight
        ctx.beginPath();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = companionOrb.alpha * 0.9;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.arc(companionOrb.x - ORB_RADIUS * 0.35, companionOrb.y - ORB_RADIUS * 0.35, ORB_RADIUS * 0.28, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // Draw fading typewriter orbs when transitioning away from typewriter state
  if(fadingTypewriterOrbs.length > 0) {
    // Update and draw fading trails
    for(let i = 0; i < fadingCompanionTrails.length; i++) {
      const trail = fadingCompanionTrails[i];
      if(trail.length > 0) {
        ctx.globalCompositeOperation = 'lighter';
        ctx.strokeStyle = getCurrentThemeOrbColor();
        
        for(let j = 1; j < trail.length; j++) {
          const curr = trail[j];
          const prev = trail[j-1];
          const alpha = (j / trail.length) * 0.8 * curr.alpha;
          
          ctx.beginPath();
          ctx.strokeStyle = prev.color || getCurrentThemeOrbColor(); // use stored color or fallback
          ctx.lineWidth = ORB_RADIUS * 2 * alpha;
          ctx.globalAlpha = alpha;
          ctx.lineCap = 'round';
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }
    
    // Draw fading orbs and update their fade
    for(let i = fadingTypewriterOrbs.length - 1; i >= 0; i--) {
      let fadingOrb = fadingTypewriterOrbs[i];
      
      // Update fade alpha (fade out over 2500ms for a very gentle fade)
      const fadeElapsed = tick - fadingOrb.fadeStartTime;
      fadingOrb.fadeAlpha = Math.max(0, 1 - (fadeElapsed / 2500));
      
      console.log(`Fading orb ${i}: fadeElapsed=${fadeElapsed}, fadeAlpha=${fadingOrb.fadeAlpha}`);
      
      // Remove completely faded orbs
      if(fadingOrb.fadeAlpha <= 0) {
        console.log(`Removing completely faded orb ${i}`);
        fadingTypewriterOrbs.splice(i, 1);
        continue;
      }
      
      // Draw fading orb with reduced alpha
      const finalAlpha = fadingOrb.alpha * fadingOrb.fadeAlpha;
      
      // Outer glow
      ctx.beginPath();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = finalAlpha * 0.7;
      const g = ctx.createRadialGradient(fadingOrb.x, fadingOrb.y, 0, fadingOrb.x, fadingOrb.y, ORB_RADIUS * 6);
      g.addColorStop(0, fadingOrb.color);
      g.addColorStop(0.3, 'rgba(57,176,255,0.3)');
      g.addColorStop(1, 'rgba(57,176,255,0)');
      ctx.fillStyle = g;
      ctx.arc(fadingOrb.x, fadingOrb.y, ORB_RADIUS * 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main orb
      ctx.beginPath();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = fadingOrb.color;
      ctx.globalAlpha = finalAlpha;
      ctx.arc(fadingOrb.x, fadingOrb.y, ORB_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Spec highlight
      ctx.beginPath();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = finalAlpha * 0.9;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.arc(fadingOrb.x - ORB_RADIUS * 0.35, fadingOrb.y - ORB_RADIUS * 0.35, ORB_RADIUS * 0.28, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Fade out trail points
    for(let i = 0; i < fadingCompanionTrails.length; i++) {
      const trail = fadingCompanionTrails[i];
      for(let j = trail.length - 1; j >= 0; j--) {
        trail[j].alpha *= 0.98; // Fade trail points
        if(trail[j].alpha < 0.05) {
          trail.splice(j, 1);
        }
      }
    }
    
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // Draw error sparks if in error states
  if((state === 'critical-error' || state === 'transition-to-idle') && errorSparks.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    for(let spark of errorSparks) {
      const alpha = spark.life / spark.maxLife;
      const sparkColors = ['#ff6666', '#ffaaaa', '#ffffff', '#ffff88'];
      const colorIndex = Math.floor(Math.random() * sparkColors.length);
      
      ctx.beginPath();
      ctx.fillStyle = sparkColors[colorIndex];
      ctx.globalAlpha = alpha * 0.8;
      ctx.arc(spark.x, spark.y, spark.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Add small spark lines
      ctx.beginPath();
      ctx.strokeStyle = sparkColors[colorIndex];
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha * 0.6;
      const lineLength = spark.size * 3;
      ctx.moveTo(spark.x - lineLength, spark.y);
      ctx.lineTo(spark.x + lineLength, spark.y);
      ctx.moveTo(spark.x, spark.y - lineLength);
      ctx.lineTo(spark.x, spark.y + lineLength);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  
  // Draw new animation effects
  if(state === 'matrix-rain' && matrixRainDrops.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    
    for(let drop of matrixRainDrops) {
      ctx.globalAlpha = drop.alpha;
      ctx.fillStyle = `rgba(0, 255, 65, ${drop.alpha})`;
      ctx.fillText(drop.char, drop.x, drop.y);
      
      // Add glow effect
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 5;
      ctx.fillText(drop.char, drop.x, drop.y);
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  if(state === 'excited' && excitementBounces.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    
    for(let particle of excitementBounces) {
      ctx.globalAlpha = particle.alpha;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Add sparkle effect
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(particle.x - particle.size * 2, particle.y);
      ctx.lineTo(particle.x + particle.size * 2, particle.y);
      ctx.moveTo(particle.x, particle.y - particle.size * 2);
      ctx.lineTo(particle.x, particle.y + particle.size * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  if(state === 'constellation') {
    ctx.globalCompositeOperation = 'lighter';
    
    // Draw constellation connections first
    for(let connection of constellationConnections) {
      if(connection.alpha > 0.01) {
        ctx.globalAlpha = connection.alpha;
        ctx.strokeStyle = `rgba(255, 255, 255, ${connection.alpha})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(connection.x1, connection.y1);
        ctx.lineTo(connection.x2, connection.y2);
        ctx.stroke();
      }
    }
    
    // Draw constellation stars
    for(let star of constellationStars) {
      const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
      const brightness = star.brightness * twinkle;
      
      ctx.globalAlpha = brightness;
      ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Star cross pattern
      ctx.strokeStyle = `rgba(255, 255, 255, ${brightness * 0.8})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      const crossSize = star.size * 2;
      ctx.moveTo(star.x - crossSize, star.y);
      ctx.lineTo(star.x + crossSize, star.y);
      ctx.moveTo(star.x, star.y - crossSize);
      ctx.lineTo(star.x, star.y + crossSize);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  if(state === 'galaxy-spiral' && galaxySpiralArms.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    
    for(let particle of galaxySpiralArms) {
      ctx.globalAlpha = particle.alpha;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Add glow
      ctx.shadowColor = particle.color;
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  if(state === 'celebration' && celebrationParticles.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    
    for(let particle of celebrationParticles) {
      ctx.save();
      ctx.translate(particle.x, particle.y);
      ctx.rotate(particle.rotation);
      ctx.globalAlpha = particle.alpha;
      ctx.fillStyle = particle.color;
      
      if(particle.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Square confetti
        ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
      }
      
      ctx.restore();
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // Draw custom animation particles (if any exist)
  if(state === 'custom-animation' && customAnimationState.particles) {
    ctx.globalCompositeOperation = 'lighter';
    
    for(let particle of customAnimationState.particles) {
      ctx.globalAlpha = particle.life / 100; // fade based on life
      ctx.fillStyle = particle.color || '#ffffff';
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
}

// Behavior implementations
let tick = 0;
function update(dt){
  tick += dt;
  // behavior per state
  if(state === 'idle'){
    // gentle breathing float around center
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2 - 10;
    const t = Math.sin(tick*0.0015);
    const targetX = cx + Math.cos(tick*0.0009) * 18;
    const targetY = cy + t * 6;
    orb.vx += (targetX - orb.x) * 0.02;
    orb.vy += (targetY - orb.y) * 0.02;
  } else if(state === 'thinking'){
    // orbit in place faster
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.18;
    const speed = 0.0028; // adjust spin speed
    const ang = tick * speed;
    const targetX = cx + Math.cos(ang) * radius;
    const targetY = cy + Math.sin(ang) * radius * 0.8; // slight ellipse
    orb.vx += (targetX - orb.x) * 0.08;
    orb.vy += (targetY - orb.y) * 0.08;
    // tail stronger
    addTrail(orb.x, orb.y, 0.9);
  } else if(state === 'searching'){
    // quick darts with some randomness
    if(Math.random() < 0.02){
      const tx = rand(40, canvas.clientWidth-40);
      const ty = rand(40, canvas.clientHeight-40);
      orb.vx += (tx - orb.x) * 0.12;
      orb.vy += (ty - orb.y) * 0.12;
    }
    orb.vx *= 0.96;
    orb.vy *= 0.96;
  } else if(state === 'windows-loading'){
    // Windows loading spinner behavior: circular motion with speed variation
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.15;
    
    // Base rotation speed (faster now)
    const baseSpeed = 0.2; // increased from 0.15 for even faster animation
    
    // Determine speed based on current position in the circle
    const normalizedAngle = windowsLoadingAngle % (Math.PI * 2);
    let speedMultiplier;
    
    if (normalizedAngle < Math.PI) {
      // Top half: speed up (0 to π)
      speedMultiplier = 1 + Math.sin(normalizedAngle) * 1.5; // speeds up to 2.5x
    } else {
      // Bottom half: slow down (π to 2π)
      speedMultiplier = 1 + Math.sin(normalizedAngle) * 0.3; // slows down to 0.7x
    }
    
    // Update angle with variable speed
    windowsLoadingAngle += baseSpeed * speedMultiplier;
    
    // Calculate position
    orb.x = cx + Math.cos(windowsLoadingAngle) * radius;
    orb.y = cy + Math.sin(windowsLoadingAngle) * radius;
    
    // Add trail with high alpha for strong tail effect
    addTrailPoint(orb.x, orb.y, 0.95);
  } else if(state === 'rainbow'){
    // Rainbow state: orb moves in a circle while cycling through cute pastel colors
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.2;
    const speed = 0.004; // moderate circular speed
    const ang = tick * speed;
    
    // Position the orb in a circle
    const targetX = cx + Math.cos(ang) * radius;
    const targetY = cy + Math.sin(ang) * radius * 0.7; // slightly elliptical
    orb.vx += (targetX - orb.x) * 0.08;
    orb.vy += (targetY - orb.y) * 0.08;
    
    // Cycle through cute pastel colors at a gentler pace
    const colorCycleSpeed = 0.002; // much slower color changes for gentle effect
    
    // Define cute but vibrant colors that show well through blur
    const pastelColors = [
      '#FF69B4', // hot pink (vibrant but still cute)
      '#FF8C69', // coral/salmon
      '#FFD700', // gold (vibrant yellow)
      '#32CD32', // lime green
      '#87CEEB', // sky blue (boosted)
      '#DA70D6', // orchid purple
      '#FF1493', // deep pink
      '#00CED1'  // dark turquoise
    ];
    
    // Calculate which color to use based on time
    const colorIndex = Math.floor((tick * colorCycleSpeed) % pastelColors.length);
    const nextColorIndex = (colorIndex + 1) % pastelColors.length;
    
    // Smooth transition between colors
    const colorProgress = ((tick * colorCycleSpeed) % 1);
    
    // Simple color interpolation between current and next pastel color
    if(colorProgress < 0.1) { // Only interpolate during transitions for smoother color holds
      const currentColor = pastelColors[colorIndex];
      const nextColor = pastelColors[nextColorIndex];
      
      // Extract RGB from hex
      const currentR = parseInt(currentColor.slice(1, 3), 16);
      const currentG = parseInt(currentColor.slice(3, 5), 16);
      const currentB = parseInt(currentColor.slice(5, 7), 16);
      
      const nextR = parseInt(nextColor.slice(1, 3), 16);
      const nextG = parseInt(nextColor.slice(3, 5), 16);
      const nextB = parseInt(nextColor.slice(5, 7), 16);
      
      const t = colorProgress / 0.1; // normalize to 0-1 for transition
      const r = Math.round(currentR + (nextR - currentR) * t);
      const g = Math.round(currentG + (nextG - currentG) * t);
      const b = Math.round(currentB + (nextB - currentB) * t);
      
      orb.color = `rgb(${r}, ${g}, ${b})`;
    } else {
      // Hold the current pastel color
      orb.color = pastelColors[colorIndex];
    }
    
    // Add strong trail for beautiful pastel effect
    addTrailPoint(orb.x, orb.y, 0.9);
  } else if(state === 'error'){
    // Error state: wobble side-to-side like a ruler hit on a desk, then transition
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - errorStartTime;
    
    if(elapsed < 1500) { // 1.5 seconds of wobbling
      // Wobble frequency and amplitude that dampens over time
      const frequency = 0.025; // how fast it wobbles
      const dampening = Math.max(0, 1 - (elapsed / 1500)); // fade out over 1.5s
      const amplitude = 25 * dampening; // how far it wobbles
      
      // Oscillating motion with dampening
      const wobbleX = Math.sin(elapsed * frequency) * amplitude * dampening;
      
      // Center the orb and add wobble
      orb.vx += (cx + wobbleX - orb.x) * 0.15;
      orb.vy += (cy - orb.y) * 0.15;
      
      // Set error color
      orb.color = '#ff4444'; // red color for error
      orb.r = ORB_RADIUS; // normal size during wobble
    } else {
      // Transition to critical error state
      setState('critical-error');
    }
  } else if(state === 'critical-error'){
    // EPIC pulsating red orb with sparks - HARDER BETTER FASTER STRONGER
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - criticalErrorStartTime;
    
    if(elapsed < 4500) { // 4.5 seconds of EPIC pulsating and sparks
      // Pulsating phase - HARDER BETTER FASTER STRONGER
      const pulseTime = elapsed;
      const pulseFreq = 0.003; // MUCH slower, more dramatic pulse
      const pulseIntensity = Math.sin(pulseTime * pulseFreq) * 0.5 + 0.5;
      
      // Keep orb centered
      orb.x = cx;
      orb.y = cy;
      orb.vx = 0;
      orb.vy = 0;
      
      // MASSIVELY grow the orb and make it pulse BIGGER
      const baseSize = ORB_RADIUS * 8; // 8x bigger base size
      const pulseSize = ORB_RADIUS * 6; // HUGE additional pulsing size
      orb.r = baseSize + pulseSize * pulseIntensity; // Can reach 14x normal size!
      
      // Pulsating red color - more dramatic and STRONGER
      const redIntensity = Math.floor(180 + pulseIntensity * 75); // deeper range
      const darkening = Math.floor(10 + pulseIntensity * 10); // pulsating darkness
      orb.color = `rgb(${redIntensity}, ${darkening}, ${darkening})`; // ultra intimidating red
      
      // Create MORE electrical sparks flying out from center
      if(Math.random() < 0.6) { // 60% chance each frame - MORE SPARKS
        const sparkAngle = Math.random() * Math.PI * 2;
        const sparkSpeed = 4 + Math.random() * 6; // FASTER sparks
        errorSparks.push({
          x: cx, // start from center
          y: cy, // start from center
          vx: Math.cos(sparkAngle) * sparkSpeed,
          vy: Math.sin(sparkAngle) * sparkSpeed,
          life: 30 + Math.random() * 20, // LONGER lasting sparks
          maxLife: 50,
          size: 2 + Math.random() * 3 // BIGGER sparks
        });
      }
      
      // Update sparks
      errorSparks = errorSparks.filter(spark => {
        spark.x += spark.vx;
        spark.y += spark.vy;
        spark.vx *= 0.99; // even less friction for LONGER sparks
        spark.vy *= 0.99;
        spark.life--;
        return spark.life > 0;
      });
    } else {
      // Start smooth transition back to idle
      transitionStartTime = tick;
      transitionFromColor = orb.color;
      transitionToColor = getCurrentThemeOrbColor();
      setState('transition-to-idle');
    }
  } else if(state === 'transition-to-idle'){
    // Smooth transition back to normal
    const elapsed = tick - transitionStartTime;
    const transitionDuration = 1000; // 1 second transition
    
    if(elapsed < transitionDuration) {
      const t = elapsed / transitionDuration;
      const easedT = ease(t); // smooth easing
      
      // Smooth color transition
      orb.color = interpolateColor(transitionFromColor, transitionToColor, easedT);
      
      // Smooth size transition
      const startSize = ORB_RADIUS * 8; // starting from large size
      const endSize = ORB_RADIUS;
      orb.r = startSize + (endSize - startSize) * easedT;
      
      // Keep centered during transition
      const cx = canvas.clientWidth/2;
      const cy = canvas.clientHeight/2;
      orb.x = cx;
      orb.y = cy;
      orb.vx = 0;
      orb.vy = 0;
      
      // Fade out remaining sparks
      errorSparks = errorSparks.filter(spark => {
        spark.x += spark.vx;
        spark.y += spark.vy;
        spark.vx *= 0.95;
        spark.vy *= 0.95;
        spark.life -= 2; // fade faster during transition
        return spark.life > 0;
      });
    } else {
      // Transition complete, go to idle
      orb.r = ORB_RADIUS;
      orb.color = getCurrentThemeOrbColor();
      errorSparks = [];
      setState('idle');
    }
  } else if(state === 'network-scan'){
    // Network scanning animation - radar pulses with node discovery
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - networkScanStartTime;
    
    // Initialize enhanced effects data
    if(!networkDataPackets) networkDataPackets = [];
    if(!networkSecurityAlerts) networkSecurityAlerts = [];
    if(!networkInterference) networkInterference = [];
    if(!networkHealthPulses) networkHealthPulses = [];
    
    // Keep orb centered and pulsing gently
    orb.x = cx;
    orb.y = cy;
    orb.vx = 0;
    orb.vy = 0;
    
    // Subtle blue pulsing for the scanning orb
    const scanPulse = Math.sin(elapsed * 0.008) * 0.3 + 0.7;
    orb.color = `rgb(${Math.floor(57 * scanPulse)}, ${Math.floor(176 * scanPulse)}, 255)`;
    
    // Send out radar pulses every 800ms
    if(elapsed % 800 < 50) { // brief window to create pulse
      networkScanPulses.push({
        x: cx,
        y: cy,
        radius: 0,
        maxRadius: Math.min(canvas.clientWidth, canvas.clientHeight) * 0.6,
        life: 100,
        maxLife: 100
      });
    }
    
    // Update radar pulses
    networkScanPulses = networkScanPulses.filter(pulse => {
      pulse.radius += 3; // pulse expansion speed
      pulse.life--;
      return pulse.life > 0 && pulse.radius < pulse.maxRadius;
    });
    
    // Randomly discover network nodes when pulses reach them
    for(let pulse of networkScanPulses) {
      if(pulse.radius > 50 && pulse.radius < 300 && Math.random() < 0.02) {
        const angle = Math.random() * Math.PI * 2;
        const distance = pulse.radius + (Math.random() - 0.5) * 40;
        
        // Only add if not too close to existing nodes
        const newX = cx + Math.cos(angle) * distance;
        const newY = cy + Math.sin(angle) * distance;
        let tooClose = false;
        
        for(let node of networkNodes) {
          const dist = Math.sqrt((newX - node.x) ** 2 + (newY - node.y) ** 2);
          if(dist < 30) tooClose = true;
        }
        
        if(!tooClose && networkNodes.length < 12) {
          networkNodes.push({
            x: newX,
            y: newY,
            discoveredTime: tick,
            pulsePhase: Math.random() * Math.PI * 2,
            type: Math.random() < 0.3 ? 'server' : 'client' // 30% servers, 70% clients
          });
        }
      }
    }
    
    // Remove nodes that are too old (keep scanning fresh)
    networkNodes = networkNodes.filter(node => (tick - node.discoveredTime) < 8000);
    
    // Spawn data packets between connected nodes
    if(networkNodes.length >= 2 && elapsed % 400 < 50) {
      const sourceNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      const targetNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      
      if(sourceNode !== targetNode) {
        networkDataPackets.push({
          startX: sourceNode.x,
          startY: sourceNode.y,
          endX: targetNode.x,
          endY: targetNode.y,
          progress: 0,
          speed: 0.02 + Math.random() * 0.03,
          color: Math.random() < 0.7 ? '#00ff88' : '#ff4444', // mostly green, some red for errors
          life: 100,
          maxLife: 100
        });
      }
    }
    
    // Update data packets
    networkDataPackets = networkDataPackets.filter(packet => {
      packet.progress += packet.speed;
      packet.life--;
      return packet.progress < 1.0 && packet.life > 0;
    });
    
    // Spawn occasional security alerts
    if(networkNodes.length > 3 && Math.random() < 0.001) {
      const alertNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      networkSecurityAlerts.push({
        x: alertNode.x,
        y: alertNode.y,
        radius: 5,
        maxRadius: 60,
        life: 120,
        maxLife: 120,
        severity: Math.random() < 0.3 ? 'critical' : 'warning'
      });
    }
    
    // Update security alerts
    networkSecurityAlerts = networkSecurityAlerts.filter(alert => {
      alert.radius += 1.2;
      alert.life--;
      return alert.life > 0 && alert.radius < alert.maxRadius;
    });
    
    // Spawn interference patterns occasionally
    if(Math.random() < 0.0008) {
      networkInterference.push({
        x: Math.random() * canvas.clientWidth,
        y: Math.random() * canvas.clientHeight,
        life: 60,
        maxLife: 60,
        intensity: Math.random() * 0.5 + 0.3,
        pattern: Math.random() < 0.5 ? 'static' : 'wave'
      });
    }
    
    // Update interference
    networkInterference = networkInterference.filter(interference => {
      interference.life--;
      return interference.life > 0;
    });
    
    // Create health pulses for stable connections
    if(networkNodes.length > 0 && elapsed % 1500 < 50) {
      for(let node of networkNodes) {
        if(Math.random() < 0.4) { // 40% chance per node
          networkHealthPulses.push({
            x: node.x,
            y: node.y,
            radius: 2,
            maxRadius: 25,
            life: 80,
            maxLife: 80
          });
        }
      }
    }
    
    // Update health pulses
    networkHealthPulses = networkHealthPulses.filter(pulse => {
      pulse.radius += 0.5;
      pulse.life--;
      return pulse.life > 0 && pulse.radius < pulse.maxRadius;
    });
  } else if(state === 'typewriter') {
    // Typewriter: existing orb stays center, two companions split left/right
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - typewriterStartTime;
    
    // Keep main orb in center with gentle oscillation (larger amplitude)
    orb.x = cx;
    orb.vx = 0;
    orb.vy = 0;
    
    // Main orb oscillates with larger amplitude but same period
    const mainOscillation = Math.sin(tick * 0.006) * 15; // slower and higher/lower
    orb.y = cy + mainOscillation;
    
    // Initialize companion trails
    if(companionTrails.length === 0) {
      companionTrails = [[], []]; // Two separate trail arrays
    }
    
    // Initialize two companion orbs if needed
    if(typewriterOrbs.length === 0) {
      for(let i = 0; i < 2; i++) {
        typewriterOrbs.push({
          x: cx, // start at center
          y: cy, // start at center
          targetX: cx + (i === 0 ? -60 : 60), // further apart: left and right
          targetY: cy,
          baseY: cy,
          oscillationSpeed: 0.006, // same as main orb but slower
          oscillationAmplitude: 10, // smaller amplitude than main orb
          phase: (i + 1) * Math.PI * 0.5, // phase offset from main orb
          damping: 0.999, // very slow damping
          currentAmplitude: 0, // starts with no oscillation
          color: orb.color, // same color as main orb
          alpha: 1,
          splitProgress: 0 // how far along the split animation
        });
      }
    }
    
    // Update each companion orb
    for(let i = 0; i < typewriterOrbs.length; i++) {
      let companionOrb = typewriterOrbs[i];
      
      // Animate the split (orbs moving to their positions)
      if(companionOrb.splitProgress < 1) {
        companionOrb.splitProgress = Math.min(1, companionOrb.splitProgress + 0.012); // slightly slower split
        const ease = 1 - Math.pow(1 - companionOrb.splitProgress, 3); // ease out
        companionOrb.x = cx + (companionOrb.targetX - cx) * ease;
      }
      
      // Start oscillation after a delay
      const oscillationDelay = (i + 1) * 300; // 300ms, 600ms delays
      if(elapsed > oscillationDelay) {
        // Gradual amplitude increase
        const timeInOscillation = elapsed - oscillationDelay;
        companionOrb.currentAmplitude = Math.min(companionOrb.oscillationAmplitude, timeInOscillation * 0.008);
        
        // Gentle up/down oscillation with very slow damping
        const oscillation = Math.sin((tick * companionOrb.oscillationSpeed) + companionOrb.phase) * companionOrb.currentAmplitude;
        companionOrb.y = companionOrb.baseY + oscillation;
        
        // Apply very subtle damping over time
        companionOrb.currentAmplitude *= companionOrb.damping;
        
        // Add trail points for this companion orb (using same system as main orb)
        addCompanionTrailPoint(companionOrb.x, companionOrb.y, 1.0, i);
      }
    }
  } else if(state === 'dvd-bounce'){
    // DVD Logo bounce - classic screensaver movement
    const margin = orb.r + 5; // keep orb away from edges
    
    // Move orb by velocity (direct position update, bypass physics)
    orb.x += dvdVelocity.x;
    orb.y += dvdVelocity.y;
    
    // Check for bounces and handle them separately
    let bounced = false;
    
    // Bounce off left/right walls
    if(orb.x <= margin) {
      dvdVelocity.x = Math.abs(dvdVelocity.x); // ensure positive
      orb.x = margin;
      bounced = true;
    } else if(orb.x >= canvas.clientWidth - margin) {
      dvdVelocity.x = -Math.abs(dvdVelocity.x); // ensure negative
      orb.x = canvas.clientWidth - margin;
      bounced = true;
    }
    
    // Bounce off top/bottom walls
    if(orb.y <= margin) {
      dvdVelocity.y = Math.abs(dvdVelocity.y); // ensure positive
      orb.y = margin;
      bounced = true;
    } else if(orb.y >= canvas.clientHeight - margin) {
      dvdVelocity.y = -Math.abs(dvdVelocity.y); // ensure negative
      orb.y = canvas.clientHeight - margin;
      bounced = true;
    }
    
    // Change color on any bounce
    if(bounced) {
      const colors = ['#39b0ff', '#ff4444', '#44ff44', '#ffff44', '#ff44ff', '#44ffff'];
      orb.color = colors[Math.floor(Math.random() * colors.length)];
    }
    
    // Reset physics velocities to prevent interference
    orb.vx = 0;
    orb.vy = 0;
    
    // Add trail
    addTrailPoint(orb.x, orb.y, 0.8);
  } else if(state === 'pipes'){
    // Pipes screensaver - move in straight lines with 90-degree turns
    const margin = 40; // increased margin for better wall detection
    const minSegmentLength = 40; // minimum distance before allowing a turn
    const maxSegmentLength = 120; // maximum distance before forcing a turn
    
    // Move in current direction
    orb.x += pipesDirection.x * pipesSpeed;
    orb.y += pipesDirection.y * pipesSpeed;
    pipesSegmentLength += pipesSpeed;
    
    // Check if we need to turn (hit wall or random turn)
    let shouldTurn = false;
    let availableDirections = [];
    
    // More aggressive wall detection
    if(orb.x <= margin && pipesDirection.x <= 0) shouldTurn = true;
    if(orb.x >= canvas.clientWidth - margin && pipesDirection.x >= 0) shouldTurn = true;
    if(orb.y <= margin && pipesDirection.y <= 0) shouldTurn = true;
    if(orb.y >= canvas.clientHeight - margin && pipesDirection.y >= 0) shouldTurn = true;
    
    // Random turn after minimum segment length
    if(pipesSegmentLength > minSegmentLength && Math.random() < 0.02) shouldTurn = true;
    
    // Force turn after maximum segment length
    if(pipesSegmentLength > maxSegmentLength) shouldTurn = true;
    
    if(shouldTurn) {
      // Find available directions (90-degree turns only, no backing up)
      const directions = [
        { x: 1, y: 0 },   // right
        { x: 0, y: 1 },   // down
        { x: -1, y: 0 },  // left
        { x: 0, y: -1 }   // up
      ];
      
      for(let dir of directions) {
        // Don't go backwards
        if(dir.x === -pipesDirection.x && dir.y === -pipesDirection.y) continue;
        
        // Check if this direction is safe (won't immediately hit wall)
        let futureX = orb.x + dir.x * 60; // look further ahead
        let futureY = orb.y + dir.y * 60;
        if(futureX > margin && futureX < canvas.clientWidth - margin && 
           futureY > margin && futureY < canvas.clientHeight - margin) {
          availableDirections.push(dir);
        }
      }
      
      // If no safe directions, allow backing up as last resort
      if(availableDirections.length === 0) {
        for(let dir of directions) {
          let futureX = orb.x + dir.x * 60;
          let futureY = orb.y + dir.y * 60;
          if(futureX > margin && futureX < canvas.clientWidth - margin && 
             futureY > margin && futureY < canvas.clientHeight - margin) {
            availableDirections.push(dir);
          }
        }
      }
      
      // Choose random available direction
      if(availableDirections.length > 0) {
        pipesDirection = availableDirections[Math.floor(Math.random() * availableDirections.length)];
        pipesSegmentLength = 0;
        
        // Change color on turn like classic pipes
        const colors = ['#39b0ff', '#ff4444', '#44ff44', '#ffff44', '#ff44ff', '#44ffff'];
        orb.color = colors[Math.floor(Math.random() * colors.length)];
      } else {
        // Emergency: teleport to center and pick new direction
        orb.x = canvas.clientWidth / 2;
        orb.y = canvas.clientHeight / 2;
        pipesDirection = directions[Math.floor(Math.random() * directions.length)];
        pipesSegmentLength = 0;
      }
    }
    
    // Keep within bounds with stronger constraints
    if(orb.x < margin) { orb.x = margin; pipesDirection.x = Math.max(0, pipesDirection.x); }
    if(orb.x > canvas.clientWidth - margin) { orb.x = canvas.clientWidth - margin; pipesDirection.x = Math.min(0, pipesDirection.x); }
    if(orb.y < margin) { orb.y = margin; pipesDirection.y = Math.max(0, pipesDirection.y); }
    if(orb.y > canvas.clientHeight - margin) { orb.y = canvas.clientHeight - margin; pipesDirection.y = Math.min(0, pipesDirection.y); }
    
    // Reset physics velocities
    orb.vx = 0;
    orb.vy = 0;
    
    // Add trail for pipe effect
    addTrailPoint(orb.x, orb.y, 0.9);
  } else if(state === 'matrix-rain') {
    // Matrix rain effect: orb creates digital rain
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Keep orb in center with subtle pulse
    orb.x = cx + Math.sin(tick * 0.005) * 8;
    orb.y = cy + Math.cos(tick * 0.003) * 5;
    orb.color = '#00ff41'; // Matrix green
    
    // Create new rain drops from the orb
    if(Math.random() < 0.3) {
      matrixRainDrops.push({
        x: orb.x + (Math.random() - 0.5) * 60,
        y: orb.y,
        speed: 2 + Math.random() * 4,
        char: String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96)), // Katakana chars
        alpha: 1,
        life: 200
      });
    }
    
    // Update rain drops
    matrixRainDrops = matrixRainDrops.filter(drop => {
      drop.y += drop.speed;
      drop.alpha *= 0.995;
      drop.life--;
      return drop.y < canvas.clientHeight + 50 && drop.alpha > 0.01 && drop.life > 0;
    });
    
    addTrailPoint(orb.x, orb.y, 0.8);
  } else if(state === 'excited') {
    // Excited: rapid bouncing with color shifts and particle trails
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Rapid bouncing motion
    const bounceFreq = 0.02; // Fast bouncing
    const bounceHeight = 40;
    const excitement = Math.sin(tick * bounceFreq);
    
    orb.x = cx + Math.sin(tick * 0.015) * 30; // side to side
    orb.y = cy + Math.abs(excitement) * bounceHeight - 20; // bouncing
    
    // Rapid color cycling
    const colorCycle = (tick * 0.01) % 6;
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
    orb.color = colors[Math.floor(colorCycle)];
    
    // Create excitement particles
    if(Math.random() < 0.4) {
      excitementBounces.push({
        x: orb.x + (Math.random() - 0.5) * 20,
        y: orb.y + (Math.random() - 0.5) * 20,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8,
        size: 2 + Math.random() * 4,
        color: orb.color,
        life: 40,
        alpha: 1
      });
    }
    
    // Update excitement particles
    excitementBounces = excitementBounces.filter(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vx *= 0.98;
      particle.vy *= 0.98;
      particle.alpha *= 0.95;
      particle.life--;
      return particle.life > 0 && particle.alpha > 0.01;
    });
    
    addTrailPoint(orb.x, orb.y, 0.9);
  } else if(state === 'sleepy') {
    // Sleepy: slow fade in/out with yawning motion
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Very slow, gentle movement
    orb.x = cx + Math.sin(tick * 0.0008) * 15;
    orb.y = cy + Math.cos(tick * 0.0005) * 8;
    
    // Slow fade in/out cycle
    const fadeSpeed = 0.001;
    const fade = (Math.sin(tick * fadeSpeed) + 1) / 2; // 0 to 1
    const sleepyBlue = Math.floor(100 + fade * 155); // 100-255 blue
    orb.color = `rgb(50, 50, ${sleepyBlue})`;
    
    // Adjust orb size for yawning effect
    orb.r = ORB_RADIUS + Math.sin(tick * 0.0003) * 2;
    
    addTrailPoint(orb.x, orb.y, 0.3 + fade * 0.4); // vary trail alpha with fade
  } else if(state === 'constellation') {
    // Constellation: forms star patterns with connecting lines
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Main orb moves in a gentle circle
    const angle = tick * 0.002;
    orb.x = cx + Math.cos(angle) * 80;
    orb.y = cy + Math.sin(angle) * 60;
    orb.color = '#ffffff'; // bright white like a star
    
    // Create constellation stars if we don't have enough
    if(constellationStars.length < 8) {
      const starAngle = (constellationStars.length / 8) * Math.PI * 2;
      const radius = 120 + Math.random() * 80;
      constellationStars.push({
        x: cx + Math.cos(starAngle) * radius,
        y: cy + Math.sin(starAngle) * radius * 0.7,
        brightness: 0,
        maxBrightness: 0.6 + Math.random() * 0.4,
        twinklePhase: Math.random() * Math.PI * 2,
        size: 2 + Math.random() * 3
      });
    }
    
    // Update star brightness
    constellationStars.forEach(star => {
      star.brightness = Math.min(star.maxBrightness, star.brightness + 0.01);
      star.twinklePhase += 0.05;
    });
    
    // Create connections between nearby stars
    constellationConnections = [];
    for(let i = 0; i < constellationStars.length; i++) {
      for(let j = i + 1; j < constellationStars.length; j++) {
        const star1 = constellationStars[i];
        const star2 = constellationStars[j];
        const distance = Math.sqrt((star1.x - star2.x) ** 2 + (star1.y - star2.y) ** 2);
        if(distance < 150) {
          constellationConnections.push({
            x1: star1.x, y1: star1.y,
            x2: star2.x, y2: star2.y,
            alpha: Math.min(star1.brightness, star2.brightness) * 0.5
          });
        }
      }
    }
    
    addTrailPoint(orb.x, orb.y, 0.7);
  } else if(state === 'galaxy-spiral') {
    // Galaxy spiral: orb traces spiral galaxy arms
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Main orb follows a spiral path
    const spiralTime = tick * 0.003;
    const spiralRadius = 20 + (spiralTime % 100) * 1.5;
    orb.x = cx + Math.cos(spiralTime) * spiralRadius;
    orb.y = cy + Math.sin(spiralTime) * spiralRadius * 0.7;
    orb.color = '#9b59b6'; // purple like a galactic core
    
    // Create spiral arm particles
    if(Math.random() < 0.2) {
      for(let arm = 0; arm < 3; arm++) {
        const armAngle = (spiralTime + arm * (Math.PI * 2 / 3)) % (Math.PI * 2);
        const armRadius = 30 + (Math.random() * 100);
        galaxySpiralArms.push({
          x: cx + Math.cos(armAngle) * armRadius,
          y: cy + Math.sin(armAngle) * armRadius * 0.7,
          angle: armAngle,
          radius: armRadius,
          alpha: 0.8,
          life: 120,
          color: arm === 0 ? '#e74c3c' : arm === 1 ? '#3498db' : '#f39c12'
        });
      }
    }
    
    // Update spiral arm particles
    galaxySpiralArms = galaxySpiralArms.filter(particle => {
      particle.angle += 0.02;
      particle.radius *= 1.01; // spiral outward
      particle.x = cx + Math.cos(particle.angle) * particle.radius;
      particle.y = cy + Math.sin(particle.angle) * particle.radius * 0.7;
      particle.alpha *= 0.995;
      particle.life--;
      return particle.life > 0 && particle.alpha > 0.01 && particle.radius < 200;
    });
    
    addTrailPoint(orb.x, orb.y, 0.8);
  } else if(state === 'celebration') {
    // Celebration: fireworks/confetti explosion from orb
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    
    // Orb jumps around excitedly
    const jumpTime = tick * 0.008;
    orb.x = cx + Math.sin(jumpTime * 1.3) * 50;
    orb.y = cy + Math.abs(Math.sin(jumpTime * 2)) * -30 - 10; // jump upward
    
    // Rainbow color cycling
    const hue = (tick * 0.005) % 360;
    orb.color = `hsl(${hue}, 100%, 50%)`;
    
    // Create celebration particles (fireworks/confetti)
    if(Math.random() < 0.5) {
      for(let i = 0; i < 5; i++) {
        const angle = (Math.PI * 2 / 5) * i + Math.random() * 0.5;
        const speed = 3 + Math.random() * 5;
        celebrationParticles.push({
          x: orb.x,
          y: orb.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - Math.random() * 2, // slight upward bias
          size: 2 + Math.random() * 4,
          color: `hsl(${Math.random() * 360}, 100%, 60%)`,
          shape: Math.random() < 0.5 ? 'circle' : 'square',
          rotation: 0,
          rotationSpeed: (Math.random() - 0.5) * 0.3,
          gravity: 0.1,
          life: 60 + Math.random() * 40,
          alpha: 1
        });
      }
    }
    
    // Update celebration particles
    celebrationParticles = celebrationParticles.filter(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vy += particle.gravity; // gravity
      particle.vx *= 0.995; // air resistance
      particle.rotation += particle.rotationSpeed;
      particle.alpha *= 0.98;
      particle.life--;
      return particle.life > 0 && particle.alpha > 0.01;
    });
    
    addTrailPoint(orb.x, orb.y, 0.9);
  } else if(state === 'custom-animation') {
    // Execute custom user-defined animation
    if(customAnimationFunction) {
      try {
        customAnimationFunction.call(customAnimationState, tick);
      } catch(error) {
        console.error('Custom animation error:', error);
        setState('idle'); // fallback to idle on error
      }
    } else {
      setState('idle'); // fallback if no custom function
    }
  } else if(state.startsWith('pattern-')){
    // pattern-driven: we will call pattern functions which set orb.x/y directly
    // see pattern controllers which update orb.x and orb.y each frame
  }

  // apply velocity
  orb.x += orb.vx;
  orb.y += orb.vy;
  // friction
  orb.vx *= FRICTION;
  orb.vy *= FRICTION;

  // constrain (but not for DVD bounce or pipes which handle their own boundaries)
  if(state !== 'dvd-bounce' && state !== 'pipes') {
    orb.x = Math.max(18, Math.min(canvas.clientWidth-18, orb.x));
    orb.y = Math.max(18, Math.min(canvas.clientHeight-18, orb.y));
  }

  // always add trail (small alpha for subtle tail)
  if(!state.startsWith('pattern-') && state !== 'dvd-bounce' && state !== 'pipes') addTrailPoint(orb.x, orb.y, 0.55);
}

// Performance Analytics
const performanceMonitor = {
  frameCount: 0,
  lastFPSUpdate: 0,
  fps: 0,
  lastLoggedFPS: 0,
  lastFPSLog: 0,
  
  update() {
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastFPSUpdate >= 1000) {
      this.fps = this.frameCount;
      this.frameCount = 0;
      this.lastFPSUpdate = now;
      
      // Only log FPS if significantly different or every 10 seconds
      if(Math.abs(this.fps - this.lastLoggedFPS) > 5 || (now - this.lastFPSLog) > 10000) {
        console.log(`FPS: ${this.fps}`);
        this.lastLoggedFPS = this.fps;
        this.lastFPSLog = now;
      }
    }
  }
};

// animation loop
let last = performance.now();
let rafId;
function loop(now){
  const dt = now - last;
  last = now;

  // Performance monitoring
  performanceMonitor.update();

  // call pattern updater if any
  if(patternActive && patterns[patternActive]) patterns[patternActive](now);
  
  // call custom animation if active
  if(state === 'custom-animation' && customAnimationFunction) {
    try {
      customAnimationFunction.call(customAnimationState, now);
    } catch(error) {
      console.error('Custom animation error:', error);
      setState('idle'); // fallback to idle on error
    }
  }
  
  update(dt);
  draw();
  rafId = requestAnimationFrame(loop);
}
rafId = requestAnimationFrame(loop);

// Patterns: each pattern should set orb.x and orb.y over time
let patternActive = null;
let patterns = {
  'pattern-heart': function(now){
    // parametric heart curve scaled & centered
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const scale = Math.min(canvas.clientWidth, canvas.clientHeight) * 2.0; // 10x bigger (from 0.2 to 2.0)
    const t = (now*0.00225) % (Math.PI*2); // 0.5x slower (from 0.0045 to 0.00225)
    // classic heart parametric (x = 16 sin^3 t, y = 13 cos t - 5 cos 2t -2 cos 3t - cos 4t)
    const s = t;
    const x = 16*Math.pow(Math.sin(s),3);
    const y = 13*Math.cos(s) - 5*Math.cos(2*s) - 2*Math.cos(3*s) - Math.cos(4*s);
    orb.x = cx + x * scale * 0.0125;
    orb.y = cy - y * scale * 0.0125;
    addTrailPoint(orb.x, orb.y, 0.92);
  }
};

// Controls to change state
const buttons = document.querySelectorAll('[data-state]');
buttons.forEach(b=>b.addEventListener('click', ()=>setState(b.dataset.state)));

function setState(s){
  console.log(`setState called: current state="${state}", new state="${s}", typewriterOrbs.length=${typewriterOrbs.length}`);
  
  // If we're leaving typewriter state, start fade-out animation BEFORE changing state
  if(state === 'typewriter' && s !== 'typewriter' && typewriterOrbs.length > 0) {
    console.log(`Starting fade-out transition: ${typewriterOrbs.length} orbs to fade`);
    // Move current typewriter orbs to fading array with fade properties
    fadingTypewriterOrbs = typewriterOrbs.map(orb => ({
      ...orb,
      fadeAlpha: 1.0,
      fadeStartTime: tick
    }));
    console.log(`Created ${fadingTypewriterOrbs.length} fading orbs`);
    // Copy trails to fading trails
    fadingCompanionTrails = [
      [...companionTrails[0]], 
      [...companionTrails[1]]
    ];
    
    // Clear active typewriter elements
    typewriterOrbs = [];
    companionTrails = [[], []];
  }
  
  state = s === 'idle' ? 'idle' : s;
  patternActive = null;
  
  // Reset windows loading angle when entering the state
  if(s === 'windows-loading'){
    windowsLoadingAngle = 0;
  }
  
  // Set error start time and reset color
  if(s === 'error'){
    errorStartTime = tick;
    orb.color = '#ff4444'; // red for error
    orb.r = ORB_RADIUS; // reset size
    errorSparks = []; // clear any existing sparks
  } else if(s === 'critical-error'){
    criticalErrorStartTime = tick;
    errorSparks = []; // clear any existing sparks
  } else if(s === 'network-scan'){
    networkScanStartTime = tick;
    networkScanPulses = []; // clear any existing pulses
    networkNodes = []; // clear any existing nodes
    networkDataPackets = []; // clear data packets
    networkSecurityAlerts = []; // clear alerts
    networkInterference = []; // clear interference
    networkHealthPulses = []; // clear health pulses
    orb.color = '#39b0ff'; // scanning blue
  } else if(s === 'typewriter') {
    typewriterStartTime = tick;
    typewriterOrbs = []; // clear existing orbs
    companionTrails = [[], []]; // clear existing trails
    companionLastTrailPos = [{x: 0, y: 0}, {x: 0, y: 0}]; // reset trail positions
    orb.color = getCurrentThemeOrbColor(); // reset main orb (it will be hidden during typewriter)
  } else if(s === 'transition-to-idle'){
    // Don't reset anything during transition - let it handle smoothly
  } else if(s === 'dvd-bounce') {
    orb.color = '#39b0ff'; // start with blue for DVD bounce
    // Reset velocity to ensure consistent start
    dvdVelocity = { x: 2, y: 1.5 };
  } else if(s === 'pipes') {
    orb.color = '#39b0ff'; // start with blue for pipes
    // Reset pipes state
    pipesDirection = { x: 1, y: 0 }; // start going right
    pipesSegmentLength = 0;
    pipesLastTurn = tick;
  } else if(s === 'matrix-rain') {
    orb.color = '#00ff41'; // Matrix green
    matrixRainDrops = []; // clear existing rain
  } else if(s === 'excited') {
    orb.color = '#ff6b6b'; // start with excited red
    excitementBounces = []; // clear existing particles
  } else if(s === 'sleepy') {
    orb.color = '#6b7db4'; // sleepy blue
    sleepyFadePhase = 0;
    orb.r = ORB_RADIUS; // reset size
  } else if(s === 'constellation') {
    orb.color = '#ffffff'; // bright white like a star
    constellationStars = []; // clear existing stars
    constellationConnections = []; // clear existing connections
  } else if(s === 'galaxy-spiral') {
    orb.color = '#9b59b6'; // purple galactic core
    galaxySpiralArms = []; // clear existing particles
  } else if(s === 'celebration') {
    orb.color = '#ff1493'; // start with hot pink
    celebrationParticles = []; // clear existing particles
  } else if(s === 'custom-animation') {
    // Custom animation state - don't reset anything, let the custom code handle it
    orb.color = orb.color || getCurrentThemeOrbColor(); // keep current color or theme default
  } else {
    orb.color = getCurrentThemeOrbColor(); // back to theme's default color
    orb.r = ORB_RADIUS; // reset size
  }
  
  // Handle Windows loading spinner
  if(s === 'windows-loading'){
    // Using the orb itself for windows loading animation
  } else {
    // No spinner element needed
  }
  
  // if a pattern, enable it
  if(s.startsWith('pattern-')){
    patternActive = s;
  }
  // visual feedback: highlight canvas briefly
  const canvas = document.getElementById('runaCanvas');
  canvas.animate([{filter:'blur(6px)'},{filter:'blur(6px) drop-shadow(0 0 20px rgba(57,176,255,0.3))'}],{duration:300,fill:'forwards',direction:'alternate'});
}

// Input / send (placeholder for n8n integration)
const N8N_ENDPOINT = 'https://n8n.h4ks.com/webhook/73387873-f205-445e-8fea-7c221694b08f/chat';
const userInput = document.getElementById('userInput');
const sendBtn = document.getElementById('sendBtn');
const chatContainer = document.getElementById('chatContainer');
const chatMessages = document.getElementById('chatMessages');

// Robust scroll to bottom function
function scrollToBottom() {
  // Use requestAnimationFrame to ensure DOM has updated
  requestAnimationFrame(() => {
    // Scroll to the absolute bottom with some extra padding
    chatMessages.scrollTop = chatMessages.scrollHeight;
  });
}

// Enhanced markdown parser with interactive elements support
function parseMarkdown(text) {
  return text
    // Bold: **text** or __text__
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/__(.*?)__/g, '<strong>$1</strong>')
    // Italic: *text* or _text_
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/_(.*?)_/g, '<em>$1</em>')
    // Inline code: `text` (only if not part of code block)
    .replace(/`(.*?)`/g, '<code style="background:rgba(255,255,255,0.1);padding:2px 4px;border-radius:3px;font-family:monospace;">$1</code>')
    // Math equations: $$equation$$
    .replace(/\$\$(.*?)\$\$/g, '<div class="math-equation">$1</div>')
    // Interactive buttons: [Button Text]{action:value}
    .replace(/\[(.*?)\]\{action:(.*?)\}/g, '<button class="msg-action-btn" data-action="$2">$1</button>')
    // File attachments: [📄 filename.txt (123 KB)]{file:download_url}
    .replace(/\[📄 (.*?) \((.*?)\)\]\{file:(.*?)\}/g, 
      '<div class="file-attachment" onclick="window.open(\'$3\', \'_blank\')">' +
      '<div class="file-icon">📄</div>' +
      '<div class="file-info"><div class="file-name">$1</div><div class="file-size">$2</div></div>' +
      '<button class="download-btn" onclick="event.stopPropagation(); window.open(\'$3\', \'_blank\')">Download</button>' +
      '</div>')
    // Line breaks
    .replace(/\n/g, '<br>')
    // Links: [text](url)
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color:#6d9ff7;text-decoration:underline;" target="_blank">$1</a>');
}

// Simple syntax highlighting function
function highlightSyntax(code, language) {
  let highlighted = code;
  
  // Apply basic syntax highlighting based on language
  switch(language.toLowerCase()) {
    case 'javascript':
    case 'js':
      highlighted = highlighted
        .replace(/\b(function|const|let|var|if|else|for|while|return|class|extends|import|export|async|await|try|catch|finally)\b/g, '<span class="keyword">$1</span>')
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>')
        .replace(/\/\/.*$/gm, '<span class="comment">$&</span>')
        .replace(/\b(\d+\.?\d*)\b/g, '<span class="number">$1</span>');
      break;
      
    case 'python':
    case 'py':
      highlighted = highlighted
        .replace(/\b(def|class|if|elif|else|for|while|return|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="keyword">$1</span>')
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>')
        .replace(/#.*$/gm, '<span class="comment">$&</span>')
        .replace(/\b(\d+\.?\d*)\b/g, '<span class="number">$1</span>');
      break;
      
    case 'html':
      highlighted = highlighted
        .replace(/(<\/?)([\w-]+)/g, '<span class="keyword">$1$2</span>')
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>');
      break;
      
    case 'css':
      highlighted = highlighted
        .replace(/([a-zA-Z-]+)(\s*:)/g, '<span class="keyword">$1</span>$2')
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>')
        .replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>')
        .replace(/\b(\d+\.?\d*)(px|em|rem|%|vh|vw|pt|pc|in|cm|mm|ex|ch|fr)?\b/g, '<span class="number">$1$2</span>');
      break;
      
    case 'bash':
    case 'shell':
    case 'sh':
      highlighted = highlighted
        .replace(/\b(if|then|else|elif|fi|for|do|done|while|case|esac|function|return|exit|break|continue|echo|cat|grep|sed|awk|sort|uniq|head|tail|ls|cd|pwd|mkdir|rmdir|rm|cp|mv|chmod|chown|sudo|su)\b/g, '<span class="keyword">$1</span>')
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>')
        .replace(/#.*$/gm, '<span class="comment">$&</span>')
        .replace(/\$[\w_]+/g, '<span class="number">$&</span>');
      break;
      
    default:
      // Generic highlighting for unknown languages
      highlighted = highlighted
        .replace(/(["'])((?:\\.|(?!\1)[^\\])*?)\1/g, '<span class="string">$1$2$1</span>')
        .replace(/\/\/.*$/gm, '<span class="comment">$&</span>')
        .replace(/#.*$/gm, '<span class="comment">$&</span>')
        .replace(/\b(\d+\.?\d*)\b/g, '<span class="number">$1</span>');
  }
  
  return highlighted;
}

// Helper function to safely set message content with markdown
function setMessageContent(element, content) {
  // Extract code blocks first to preserve them
  const codeBlocks = [];
  const placeholderPrefix = 'CODEBLOCKPLACEHOLDER';
  let hasRunaAnimation = false; // Track if we found a RunaAnimation block
  
  // Replace code blocks with placeholders
  let processedContent = content.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, language, code) => {
    codeBlocks.push({ language, code });
    // Check if this is a RunaAnimation block
    if (language && language.toLowerCase() === 'runaanimation') {
      hasRunaAnimation = true;
    }
    return `${placeholderPrefix}${codeBlocks.length - 1}_`;
  });
  
  // Sanitize the content (excluding code blocks)
  const sanitizedContent = processedContent
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
  
  // Parse markdown
  let finalContent = parseMarkdown(sanitizedContent);
  
  // Restore code blocks (they contain their own HTML)
  codeBlocks.forEach((block, index) => {
    const lang = block.language || 'code';
    const trimmedCode = block.code.trim();
    
    // Special handling for RunaAnimation blocks
    if (lang.toLowerCase() === 'runaanimation') {
      // Extract the animation name and trigger it
      const animationName = trimmedCode.toLowerCase();
      console.log(`RunaAnimation detected: "${animationName}" (original: "${block.code}")`);
      
      // Map animation names to valid states
      const animationMap = {
        'idle': 'idle',
        'thinking': 'thinking',
        'searching': 'searching',
        'windows-loading': 'windows-loading',
        'windows_loading': 'windows-loading', // underscore version
        'error': 'error',
        'critical-error': 'critical-error',
        'critical_error': 'critical-error', // underscore version
        'network-scan': 'network-scan',
        'network_scan': 'network-scan', // underscore version
        'typewriter': 'typewriter',
        'dvd-bounce': 'dvd-bounce',
        'dvd_bounce': 'dvd-bounce', // underscore version
        'pipes': 'pipes',
        'pattern-heart': 'pattern-heart',
        'pattern_heart': 'pattern-heart', // underscore version
        'heart': 'pattern-heart', // allow shorthand
        'rainbow': 'rainbow',
        'matrix-rain': 'matrix-rain',
        'matrix_rain': 'matrix-rain', // underscore version
        'matrix': 'matrix-rain', // allow shorthand
        'excited': 'excited',
        'sleepy': 'sleepy',
        'constellation': 'constellation',
        'stars': 'constellation', // allow shorthand
        'galaxy-spiral': 'galaxy-spiral',
        'galaxy_spiral': 'galaxy-spiral', // underscore version
        'galaxy': 'galaxy-spiral', // allow shorthand
        'celebration': 'celebration',
        'party': 'celebration', // allow shorthand
        'transition-to-idle': 'transition-to-idle',
        'transition_to_idle': 'transition-to-idle', // underscore version
        'custom-animation': 'custom-animation',
        'custom_animation': 'custom-animation' // underscore version
      };
      
      // Trigger the animation if it's a valid state
      if (animationMap[animationName]) {
        console.log(`Triggering animation: ${animationName} -> ${animationMap[animationName]}`);
        setTimeout(() => {
          setState(animationMap[animationName]);
        }, 100); // Small delay to ensure message is rendered
      } else {
        console.warn(`Unknown animation: "${animationName}". Available animations:`, Object.keys(animationMap));
      }
      
      // Don't render RunaAnimation blocks in the chat - just replace with empty string
      finalContent = finalContent.replace(`${placeholderPrefix}${index}_`, '');
    } else {
      // Normal code block handling
      const highlightedCode = highlightSyntax(trimmedCode, lang);
      
      const codeBlockHtml = `<table class="code-block-table">
        <tr>
          <td class="code-block-header">${lang}</td>
        </tr>
        <tr>
          <td class="code-block-content">${highlightedCode}</td>
        </tr>
      </table>`;
      
      // Replace the placeholder with the actual code block HTML
      finalContent = finalContent.replace(`${placeholderPrefix}${index}_`, codeBlockHtml);
    }
  });
  
  // Clean up any excess whitespace left behind by hidden RunaAnimation blocks
  if (hasRunaAnimation) {
    // Remove multiple consecutive newlines/breaks and trim
    finalContent = finalContent
      .replace(/(<br\s*\/?>){3,}/gi, '<br><br>') // Max 2 consecutive line breaks
      .replace(/^(<br\s*\/?>)+|(<br\s*\/?>)+$/gi, '') // Remove leading/trailing breaks
      .replace(/^\s+|\s+$/g, ''); // Trim whitespace from start and end
  }
  
  element.innerHTML = finalContent;
  
  // Add event listeners for interactive elements
  const actionButtons = element.querySelectorAll('.msg-action-btn');
  actionButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const action = btn.dataset.action;
      handleMessageAction(action);
    });
  });
  
  // Return whether we found a RunaAnimation block
  return hasRunaAnimation;
}

// Handle interactive message actions
function handleMessageAction(action) {
  console.log(`Message action triggered: ${action}`);
  
  // Parse action format: "trigger-animation:rainbow" or "show-info:details"
  const [actionType, actionValue] = action.split(':');
  
  switch(actionType) {
    case 'trigger-animation':
      if(actionValue) {
        setState(actionValue);
      }
      break;
    case 'show-info':
      console.log(`Showing info: ${actionValue}`);
      // Could open a modal or expand section
      break;
    case 'copy-text':
      navigator.clipboard.writeText(actionValue).then(() => {
        console.log('Text copied to clipboard');
      });
      break;
    default:
      console.log(`Unknown action type: ${actionType}`);
  }
}

// Add message to chat with improved styling and markdown support
function addMessage(content, isUser = false) {
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
  
  const hasRunaAnimation = setMessageContent(messageDiv, content);
  chatMessages.appendChild(messageDiv);
  
  // Scroll to bottom after message is added
  scrollToBottom();
  
  // Return whether this message contained a RunaAnimation
  return hasRunaAnimation;
}

// Add typing indicator
function showTypingIndicator() {
  const typingDiv = document.createElement('div');
  typingDiv.className = 'typing-indicator';
  typingDiv.id = 'typing-indicator';
  typingDiv.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  chatMessages.appendChild(typingDiv);
  
  // Scroll to bottom after typing indicator is added
  scrollToBottom();
  
  return typingDiv;
}

// Remove typing indicator
function removeTypingIndicator() {
  const indicator = document.getElementById('typing-indicator');
  if (indicator) {
    indicator.remove();
  }
}

sendBtn.addEventListener('click', async ()=>{
  const text = userInput.value.trim();
  if(!text) return;
  
  // Prepare message content
  let messageContent = text;
  
  // Add user message to chat (show only the user text, not the full content)
  addMessage(text, true);
  userInput.value = '';
  
  setState('thinking');
  
  // Show typing indicator
  const typingIndicator = showTypingIndicator();
  
  // If endpoint is configured, POST user input
  if(N8N_ENDPOINT){
    try{
      // Create a message element for streaming response
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message assistant';
      messageDiv.textContent = '';
      
      let streamedContent = '';
      let hasRunaAnimation = false; // Track if response contains RunaAnimation
      let lastItemTimestamp = 0; // Track timestamp for spacing between content blocks
      
      console.log('Sending POST request to:', N8N_ENDPOINT);
      
      setState('searching');
      
      // Remove typing indicator and add actual message
      removeTypingIndicator();
      chatMessages.appendChild(messageDiv);
      
      // Send POST request and handle streaming response
      const response = await fetch(N8N_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream' // Request SSE format
        },
        body: JSON.stringify({chatInput: messageContent})
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Error response body:', errorText);
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
      
      console.log('Response received, setting up stream reader');
      
      // Switch to typewriter animation when connection is established
      setState('typewriter');
      
      // Check if response has a body
      if (!response.body) {
        console.error('No response body available');
        messageDiv.textContent = 'Error: No response body';
        setState('idle');
        return;
      }
      
      // Read response as stream
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          console.log('Stream complete');
          // Only return to idle animation if no RunaAnimation was detected
          if (!hasRunaAnimation) {
            setState('idle');
          }
          break;
        }
        
        const chunk = decoder.decode(value, { stream: true });
        console.log('Raw chunk received:', JSON.stringify(chunk));
        
        buffer += chunk;
        
        // Split by double newlines (SSE format) or single newlines
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer
        
        for (const line of lines) {
          const trimmedLine = line.trim();
          
          // Skip SSE format prefixes
          if (trimmedLine.startsWith('data: ')) {
            const jsonData = trimmedLine.substring(6); // Remove "data: " prefix
            console.log('Processing SSE data:', JSON.stringify(jsonData));
            
            if (jsonData.trim()) {
              try {
                const data = JSON.parse(jsonData);
                console.log('Successfully parsed SSE chunk:', data);
                
                // Handle streaming format: {"type":"item","content":"word"}
                if (data.type === 'item' && data.content) {
                  const currentTimestamp = data.metadata?.timestamp || Date.now();
                  
                  // If there's a significant gap (more than 500ms) between items, add spacing
                  if (lastItemTimestamp > 0 && (currentTimestamp - lastItemTimestamp) > 500) {
                    // Add double newline for paragraph break
                    streamedContent += '\n\n';
                  }
                  
                  streamedContent += data.content;
                  lastItemTimestamp = currentTimestamp;
                  
                  hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
                  scrollToBottom();
                  console.log('Added content:', data.content, 'Total:', streamedContent);
                } else if (data.type === 'begin') {
                  console.log('Stream beginning');
                  // Keep typewriter animation during streaming
                } else if (data.type === 'end') {
                  console.log('Stream ending');
                  if (!hasRunaAnimation) {
                    setState('idle');
                  }
                } else if (data.output) {
                  // Handle n8n output format: {"output": "text"}
                  streamedContent = data.output;
                  hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
                  scrollToBottom();
                  console.log('Set messageDiv content to:', messageDiv.textContent);
                } else {
                  console.log('SSE data does not match expected format - keys:', Object.keys(data));
                }
              } catch (parseErr) {
                console.error('Failed to parse SSE JSON:', parseErr.message, jsonData);
              }
            }
          } else if (trimmedLine && !trimmedLine.startsWith(':')) {
            // Handle raw JSON lines (no SSE format)
            try {
              const data = JSON.parse(trimmedLine);
              console.log('Successfully parsed raw JSON chunk:', data);
              
              if (data.type === 'item' && data.content) {
                const currentTimestamp = data.metadata?.timestamp || Date.now();
                
                // If there's a significant gap (more than 500ms) between items, add spacing
                if (lastItemTimestamp > 0 && (currentTimestamp - lastItemTimestamp) > 500) {
                  // Add double newline for paragraph break
                  streamedContent += '\n\n';
                }
                
                streamedContent += data.content;
                lastItemTimestamp = currentTimestamp;
                
                hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
                scrollToBottom();
                console.log('Added content:', data.content, 'Total:', streamedContent);
              } else if (data.type === 'begin') {
                console.log('Stream beginning');
                // Keep typewriter animation during streaming
              } else if (data.type === 'end') {
                console.log('Stream ending');
                if (!hasRunaAnimation) {
                  setState('idle');
                }
              } else if (data.output) {
                streamedContent = data.output;
                hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
                scrollToBottom();
                console.log('Set messageDiv content to:', messageDiv.textContent);
              }
            } catch (parseErr) {
              console.log('Line is not JSON, skipping:', trimmedLine);
            }
          }
        }
      }
      
      // Process any remaining buffer content
      if (buffer.trim()) {
        console.log('Processing remaining buffer:', JSON.stringify(buffer));
        // Try to parse remaining buffer as JSON
        try {
          const data = JSON.parse(buffer.trim());
          if (data.type === 'item' && data.content) {
            const currentTimestamp = data.metadata?.timestamp || Date.now();
            
            // If there's a significant gap (more than 500ms) between items, add spacing
            if (lastItemTimestamp > 0 && (currentTimestamp - lastItemTimestamp) > 500) {
              // Add double newline for paragraph break
              streamedContent += '\n\n';
            }
            
            streamedContent += data.content;
            lastItemTimestamp = currentTimestamp;
            
            hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
            scrollToBottom();
          } else if (data.output) {
            streamedContent = data.output;
            hasRunaAnimation = setMessageContent(messageDiv, streamedContent) || hasRunaAnimation;
            scrollToBottom();
          }
        } catch (e) {
          console.log('Buffer is not JSON');
        }
      }
      
      // Only ensure we return to idle state if no RunaAnimation was detected
      if (!hasRunaAnimation) {
        setState('idle');
      }
      
      if (!streamedContent) {
        messageDiv.textContent = 'Response received (no content)';
        console.log('No content received, showing placeholder');
      }
      
    }catch(e){
      console.error('Streaming request failed', e);
      removeTypingIndicator();
      setState('critical-error');
      addMessage('Error: Could not setup streaming connection');
      await new Promise(r=>setTimeout(r, 2000));
      setState('idle');
    }
  } else {
    // demo: animate and show patterns depending on text
    setTimeout(() => removeTypingIndicator(), 500); // Remove typing indicator after short delay
    
    const lower = text.toLowerCase();
    if(lower.includes('heart')){
      setState('pattern-heart');
      await new Promise(r=>setTimeout(r,1700));
      addMessage("I'm drawing a heart pattern for you! ❤️");
    } else if(lower.includes('search')){
      setState('searching');
      await new Promise(r=>setTimeout(r,1200));
      addMessage("Searching through the network...");
    } else if(lower.includes('think') || lower.includes('loading')){
      setState('windows-loading');
      await new Promise(r=>setTimeout(r,2000));
      addMessage("Processing your request...");
    } else {
      setState('pattern-heart');
      await new Promise(r=>setTimeout(r,1200));
      addMessage("Hello! I can show you different animations. Try saying 'heart', 'search', or 'loading'!");
    }
    setState('idle');
  }
});

// Manual focus handler for input box
userInput.addEventListener('click', () => {
  userInput.focus();
});

// Handle Enter key to send message
userInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault(); // Prevent default form submission
    sendBtn.click(); // Trigger the send button click
  }
});

// start idle
setState('idle');

// initial placement
orb.x = canvas.clientWidth/2;
orb.y = canvas.clientHeight/2 - 10;
addTrailPoint(orb.x, orb.y, 0.9);

// Code Canvas Implementation
let customAnimationFunction = null;
let customAnimationState = {};


// Collapsible Category Toggle Function
function toggleCategory(categoryId) {
  const content = document.getElementById(categoryId);
  const header = content.parentElement.querySelector('.config-category-header');
  const toggle = header.querySelector('.category-toggle');
  
  // Check if this category is currently collapsed
  const isCurrentlyCollapsed = content.classList.contains('collapsed');
  
  if (isCurrentlyCollapsed) {
    // Before expanding this category, collapse all other categories
    const allCategories = document.querySelectorAll('.config-category-content');
    const allHeaders = document.querySelectorAll('.config-category-header');
    const allToggles = document.querySelectorAll('.category-toggle');
    
    allCategories.forEach(cat => cat.classList.add('collapsed'));
    allHeaders.forEach(head => head.classList.add('collapsed'));
    allToggles.forEach(tog => tog.textContent = '▶');
    
    // Now expand the clicked category
    content.classList.remove('collapsed');
    header.classList.remove('collapsed');
    toggle.textContent = '▼';
  } else {
    // If it's already expanded, just collapse it
    content.classList.add('collapsed');
    header.classList.add('collapsed');
    toggle.textContent = '▶';
  }
}

// Theme system initialization
document.addEventListener('DOMContentLoaded', () => {
  // Initialize theme selector
  const themeSelector = document.getElementById('themeSelector');
  if (themeSelector) {
    console.log('Theme selector found, adding event listener');
    themeSelector.addEventListener('change', (e) => {
      applyTheme(e.target.value);
    });

    // Load saved theme
    const savedTheme = localStorage.getItem('runaTheme');
    if(savedTheme && themes[savedTheme]) {
      themeSelector.value = savedTheme;
      applyTheme(savedTheme);
    } else {
      // Set default theme color if no saved theme
      orb.color = getCurrentThemeOrbColor();
    }
  }
});

// Demo Features Showcase
const showDemoBtn = document.getElementById('showDemo');

if (showDemoBtn) {
  showDemoBtn.addEventListener('click', () => {
    // Clear any existing messages
    chatMessages.innerHTML = '';
    
    // Add demo messages showcasing new features
    addMessage("Welcome to the enhanced Runa experience! 🌟", false);
  
  setTimeout(() => {
    addMessage("Here are some of the new interactive features:", false);
  }, 800);
  
  setTimeout(() => {
    const interactiveMsg = `Try these interactive elements:

[🌈 Rainbow Animation]{action:trigger-animation:rainbow} [🎆 Celebration]{action:trigger-animation:celebration} [⭐ Constellation]{action:trigger-animation:constellation}

**New Animation States:**
- Matrix Rain 💊
- Excited Bouncing 🎉  
- Sleepy Mode 😴
- Galaxy Spiral 🌌

\`\`\`javascript
// You can also create custom animations!
function myAnimation(now) {
  orb.x = canvas.width/2 + Math.sin(now*0.005)*100;
  orb.y = canvas.height/2 + Math.cos(now*0.003)*50;
  orb.color = '#ff6b6b';
}
\`\`\`

**Enhanced Features:**
- 🎨 Code Canvas for live animation editing
- 🎭 Multiple themes (try the dropdown above!)
- 📊 Performance monitoring
- 💾 Local storage for custom animations
- 🔗 Shareable animation codes

[📄 sample_file.txt (2.3 KB)]{file:data:text/plain;base64,SGVsbG8gV29ybGQh}

Try switching themes above to see different color schemes! ✨`;
    
    addMessage(interactiveMsg, false);
  }, 1600);
  
  setTimeout(() => {
    addMessage("```RunaAnimation\nmatrix-rain```", false);
  }, 2400);
  
  setTimeout(() => {
    addMessage("The RunaAnimation code blocks let you trigger animations directly from chat! Try typing your own messages with different animation names. 🚀", false);
  }, 3200);
});
}

// Voice Control System
let voiceRecognition = null;
let isListening = false;
const voiceToggleBtn = document.getElementById('voiceToggle');

// Initialize voice recognition if available
function initVoiceControl() {
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    voiceRecognition = new SpeechRecognition();
    
    voiceRecognition.continuous = false;
    voiceRecognition.interimResults = false;
    voiceRecognition.lang = 'en-US';
    
    voiceRecognition.onstart = () => {
      isListening = true;
      voiceToggleBtn.classList.add('listening');
      voiceToggleBtn.textContent = '🔴 Listening...';
      console.log('Voice recognition started');
    };
    
    voiceRecognition.onend = () => {
      isListening = false;
      voiceToggleBtn.classList.remove('listening');
      voiceToggleBtn.textContent = '🎤 Voice Control';
      console.log('Voice recognition ended');
    };
    
    voiceRecognition.onresult = (event) => {
      const command = event.results[0][0].transcript.toLowerCase().trim();
      console.log('Voice command received:', command);
      handleVoiceCommand(command);
    };
    
    voiceRecognition.onerror = (event) => {
      console.error('Voice recognition error:', event.error);
      isListening = false;
      voiceToggleBtn.classList.remove('listening');
      voiceToggleBtn.textContent = '🎤 Voice Control';
    };
    
    // Enable voice control button
    voiceToggleBtn.style.display = 'block';
  } else {
    console.log('Speech recognition not supported');
    voiceToggleBtn.style.display = 'none';
  }
}

// Handle voice commands
function handleVoiceCommand(command) {
  console.log(`Processing voice command: "${command}"`);
  
  // Animation commands
  const animationCommands = {
    'show heart': 'pattern-heart',
    'heart': 'pattern-heart',
    'rainbow': 'rainbow',
    'matrix': 'matrix-rain',
    'excited': 'excited',
    'party': 'celebration',
    'celebrate': 'celebration',
    'stars': 'constellation',
    'constellation': 'constellation',
    'galaxy': 'galaxy-spiral',
    'spiral': 'galaxy-spiral',
    'sleepy': 'sleepy',
    'sleep': 'sleepy',
    'bounce': 'dvd-bounce',
    'dvd': 'dvd-bounce',
    'pipes': 'pipes',
    'thinking': 'thinking',
    'search': 'searching',
    'idle': 'idle',
    'stop': 'idle',
    'error': 'error',
    'critical': 'critical-error',
    'network': 'network-scan',
    'scan': 'network-scan',
    'typewriter': 'typewriter'
  };
  
  // Theme commands
  const themeCommands = {
    'cyberpunk theme': 'cyberpunk',
    'nature theme': 'nature',
    'sunset theme': 'sunset',
    'galaxy theme': 'galaxy',
    'retro theme': 'retro',
    'default theme': 'default',
    'ocean theme': 'default'
  };
  
  // Check for animation commands
  for (const [phrase, animation] of Object.entries(animationCommands)) {
    if (command.includes(phrase)) {
      setState(animation);
      addMessage(`Voice command recognized: "${phrase}" → ${animation}`, false);
      return;
    }
  }
  
  // Check for theme commands
  for (const [phrase, theme] of Object.entries(themeCommands)) {
    if (command.includes(phrase)) {
      themeSelector.value = theme;
      applyTheme(theme);
      addMessage(`Theme changed via voice: ${themes[theme].name}`, false);
      return;
    }
  }
  
  // Special commands
  if (command.includes('open code canvas') || command.includes('code editor')) {
    codeCanvasModal.classList.add('active');
    addMessage('Code Canvas opened via voice command!', false);
    return;
  }
  
  if (command.includes('demo') || command.includes('show features')) {
    if (showDemoBtn) {
      showDemoBtn.click();
    }
    return;
  }
  
  // If no command matched
  addMessage(`Voice command not recognized: "${command}". Try saying "show heart", "rainbow", "matrix", "party", etc.`, false);
}

// Voice toggle button
voiceToggleBtn.addEventListener('click', () => {
  if (!voiceRecognition) {
    addMessage('Voice recognition not supported in this browser.', false);
    return;
  }
  
  if (isListening) {
    voiceRecognition.stop();
  } else {
    try {
      voiceRecognition.start();
    } catch (error) {
      console.error('Failed to start voice recognition:', error);
      addMessage('Failed to start voice recognition. Please try again.', false);
    }
  }
});

// Initialize voice control on page load
initVoiceControl();

</script>
</body>
</html>
