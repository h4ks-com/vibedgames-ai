<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Runa — Neon Orb Prototype</title>
  <style>
    :root{
      --bg:#000;
      --orb:#6d9ff7; /* custom blue */
      --input-bg: rgba(255,255,255,0.04);
      --glass: rgba(255,255,255,0.06);
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;overflow:hidden}
    .main-layout{display:grid;grid-template-rows:auto 1fr auto auto;height:100vh;position:relative;z-index:3}
    .stage{display:flex;flex-direction:column;align-items:center;justify-content:flex-end;height:100%;gap:20px;padding:24px;box-sizing:border-box;position:relative;z-index:3;pointer-events:auto}
    .canvas-wrap{position:fixed;top:0;left:0;width:100vw;height:100vh;background:transparent;z-index:0;pointer-events:none}
    canvas{display:block;width:100%;height:100%;background:transparent;filter:blur(12px)}

    .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;pointer-events:auto;grid-row:3;padding:0 24px}
    button{background:var(--glass);border:1px solid rgba(255,255,255,0.06);color:#eaf6ff;padding:8px 12px;border-radius:10px;cursor:pointer;backdrop-filter:blur(6px);pointer-events:auto}
    .input-row{display:flex;gap:10px;align-items:center;width:min(780px,92vw);pointer-events:auto;grid-row:4;justify-self:center;padding:0 24px 24px 24px}
    .text-input{flex:1;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:var(--input-bg);color:#eaf6ff;outline:none;font-size:16px;pointer-events:auto}
    .send{padding:12px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#2bb1ff22,#3aa0ff22);color:#eaf6ff;cursor:pointer;pointer-events:auto}
    .label{font-size:13px;color:#9fdcff;margin-bottom:6px;text-align:center;grid-row:1;padding:24px 24px 0 24px;align-self:center}

    .small-note{font-size:12px;color:#7aaedb;text-align:center;margin-top:6px}
    
    /* Chat area styling */
    .chat-area{
      grid-row: 2;
      padding: 20px;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 16px;
      pointer-events: auto;
      position: relative;
      z-index: 2;
    }
    
    /* Message bubbles with enhanced glass effect */
    .message{
      max-width:45%;
      padding:16px 20px;
      border-radius:20px;
      font-size:13px;
      line-height:1.5;
      position:relative;
      backdrop-filter:blur(20px);
      -webkit-backdrop-filter:blur(20px);
      border:1px solid rgba(255,255,255,0.15);
      box-shadow:0 8px 32px rgba(0,0,0,0.3), 
                 inset 0 1px 0 rgba(255,255,255,0.2),
                 0 1px 0 rgba(255,255,255,0.1);
      word-wrap:break-word;
      animation:messageSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events:auto;
    }
    
    @keyframes messageSlideIn {
      from { opacity: 0; transform: translateY(20px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    .message.user{
      background:linear-gradient(135deg, rgba(57,176,255,0.2), rgba(57,176,255,0.1));
      color:#eaf6ff;
      align-self:flex-end;
      margin-left:auto;
      border-color:rgba(57,176,255,0.4);
    }
    
    .message.user::before{
      content:'';
      position:absolute;
      top:16px;
      right:-8px;
      width:0;
      height:0;
      border-left:8px solid rgba(57,176,255,0.2);
      border-top:8px solid transparent;
      border-bottom:8px solid transparent;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .message.assistant{
      background:linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      color:#9fdcff;
      align-self:flex-start;
      margin-right:auto;
      border-color:rgba(159,220,255,0.3);
    }
    
    .message.assistant::before{
      content:'';
      position:absolute;
      top:16px;
      left:-8px;
      width:0;
      height:0;
      border-right:8px solid rgba(255,255,255,0.12);
      border-top:8px solid transparent;
      border-bottom:8px solid transparent;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    /* Typing indicator */
    .typing-indicator {
      max-width: 45%;
      padding: 16px 20px;
      border-radius: 20px;
      background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(159,220,255,0.3);
      align-self: flex-start;
      margin-right: auto;
      animation: messageSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: auto;
    }
    
    .typing-dots {
      display: flex;
      gap: 4px;
    }
    
    .typing-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #9fdcff;
      animation: typingDots 1.4s infinite ease-in-out;
    }
    
    .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
    .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes typingDots {
      0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
      40% { opacity: 1; transform: scale(1); }
    }
    
    .chat-toggle{position:fixed;top:20px;right:20px;background:var(--glass);border:1px solid rgba(255,255,255,0.06);color:#eaf6ff;padding:8px 12px;border-radius:8px;cursor:pointer;backdrop-filter:blur(6px);z-index:3;display:none}

    /* Windows Loading Spinner */
    .windows-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .windows-spinner.active {
      opacity: 1;
    }
    
    .windows-spinner::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid transparent;
      border-top: 2px solid #39b0ff;
      border-radius: 50%;
      animation: windowsSpin 1s linear infinite;
    }
    
    @keyframes windowsSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* subtle glow effect for the canvas container when orb is active */
    .glow{box-shadow:0 8px 40px rgba(57,176,255,0.06) inset, 0 6px 40px rgba(57,176,255,0.06)}

    /* Remove mobile canvas size restriction for fullscreen effect */
  </style>
</head>
<body>
  <div class="main-layout">
    <div class="label">Runa — Responsive UnrealIRCd Network Agent</div>

    <!-- Chat area -->
    <div class="chat-area" id="chatMessages"></div>

    <div class="controls">
      <button data-state="idle">Idle</button>
      <button data-state="thinking">Thinking</button>
      <button data-state="searching">Searching</button>
      <button data-state="windows-loading">Windows Loading</button>
      <button data-state="error">Error</button>
      <button data-state="critical-error">Critical Error</button>
      <button data-state="network-scan">Network Scan</button>
      <button data-state="typewriter">Typewriter</button>
      <button data-state="dvd-bounce">DVD Bounce</button>
      <button data-state="pipes">Pipes</button>
      <button data-state="pattern-heart">Heart</button>
    </div>

    <div class="input-row">
      <input id="userInput" class="text-input" placeholder="Talk to Runa" />
      <button id="sendBtn" class="send">Send</button>
    </div>
  </div>

  <div class="canvas-wrap glow" id="canvasWrap">
    <canvas id="runaCanvas"></canvas>
    <div class="windows-spinner" id="windowsSpinner"></div>
  </div>

<script>
/*
  Runa Prototype
  - Canvas-based neon orb with trailing tail
  - States: idle, thinking, searching, pattern-* (scripts)
  - How to integrate with n8n: edit N8N_ENDPOINT and uncomment fetch in sendMessage()
*/

const canvas = document.getElementById('runaCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
let W, H, DPR;

function resize(){
  DPR = window.devicePixelRatio || 1;
  W = canvas.width = Math.floor(canvas.clientWidth * DPR);
  H = canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

// Config
const ORB_COLOR = '#6d9ff7';
const ORB_RADIUS = 6; // visual radius in CSS pixels (reduced from 12)
const TAIL_LENGTH = 75; // halved for better proportions
const FRICTION = 0.92;

// State machine
let state = 'idle';
let windowsLoadingAngle = 0; // Track angle for windows loading spinner
let errorStartTime = 0; // Track when error state started
let criticalErrorStartTime = 0; // Track when critical error state started
let transitionStartTime = 0; // Track transition timing
let transitionFromColor = ORB_COLOR; // Color to transition from
let transitionToColor = ORB_COLOR; // Color to transition to
let dvdVelocity = { x: 2, y: 1.5 }; // DVD bounce velocity
let pipesDirection = { x: 1, y: 0 }; // Current direction for pipes (right, down, left, up)
let pipesSpeed = 1.5; // Speed along the pipe
let pipesLastTurn = 0; // Time since last turn
let pipesSegmentLength = 0; // Current segment progress
let errorSparks = []; // Array to hold spark particles
let networkScanPulses = []; // Array to hold radar pulses
let networkNodes = []; // Array to hold discovered nodes
let networkDataPackets = []; // Data flowing between nodes
let networkSecurityAlerts = []; // Security threat indicators
let networkInterference = []; // Signal interference effects
let networkHealthPulses = []; // Health status indicators
let typewriterOrbs = []; // Multiple orbs for typewriter effect
let fadingTypewriterOrbs = []; // Orbs that are fading out when transitioning
let typewriterState = { cursor: { x: 0, y: 0, visible: true, blinkTime: 0 } };
let typewriterStartTime = 0; // When typewriter animation started
let companionTrails = [[], []]; // Separate trail arrays for companion orbs
let fadingCompanionTrails = [[], []]; // Trails for fading orbs
let companionLastTrailPos = [{x: 0, y: 0}, {x: 0, y: 0}]; // Last trail positions for companions
let networkScanStartTime = 0; // Track when network scan started
let orb = {
  x: W/2, y: H/2, vx:0, vy:0, ax:0, ay:0, r:ORB_RADIUS, trail:[], color: ORB_COLOR
};

// Helpers
function rand(min,max){return Math.random()*(max-min)+min}
function ease(t){return (--t)*t*t+1} // cubic ease out

// Color interpolation helper
function interpolateColor(color1, color2, t) {
  // Extract RGB values from hex colors
  const r1 = parseInt(color1.slice(1, 3), 16);
  const g1 = parseInt(color1.slice(3, 5), 16);
  const b1 = parseInt(color1.slice(5, 7), 16);
  
  const r2 = parseInt(color2.slice(1, 3), 16);
  const g2 = parseInt(color2.slice(3, 5), 16);
  const b2 = parseInt(color2.slice(5, 7), 16);
  
  // Interpolate
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  
  return `rgb(${r}, ${g}, ${b})`;
}

// update trail
function addTrail(x,y,alpha){
  orb.trail.unshift({x,y,a:alpha});
  if(orb.trail.length>TAIL_LENGTH) orb.trail.pop();
}

// Add trail points more frequently for smoother lines
let lastTrailX = 0, lastTrailY = 0;
function addTrailPoint(x, y, alpha) {
  const distance = Math.sqrt((x - lastTrailX) ** 2 + (y - lastTrailY) ** 2);
  if (distance > 1.5 || orb.trail.length === 0) { // Add point every 1.5 pixels for smoother trail
    addTrail(x, y, alpha);
    lastTrailX = x;
    lastTrailY = y;
  }
}

function addCompanionTrailPoint(x, y, alpha, companionIndex) {
  const lastPos = companionLastTrailPos[companionIndex];
  const distance = Math.sqrt((x - lastPos.x) ** 2 + (y - lastPos.y) ** 2);
  if (distance > 1.5 || companionTrails[companionIndex].length === 0) {
    companionTrails[companionIndex].push({x, y, alpha});
    if(companionTrails[companionIndex].length > 50) { // use same length as main orb trail
      companionTrails[companionIndex].shift();
    }
    lastPos.x = x;
    lastPos.y = y;
  }
}

// draw neon orb + trail
function draw(){
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

  // Police siren background for critical error
  if(state === 'critical-error') {
    const rotation = tick * 0.004; // 2x speed - gentle but noticeable
    const centerX = canvas.clientWidth / 2;
    const centerY = canvas.clientHeight / 2;
    const radius = Math.max(canvas.clientWidth, canvas.clientHeight);
    
    // Create rotating red/blue gradient
    const gradient = ctx.createLinearGradient(
      centerX + Math.cos(rotation) * radius,
      centerY + Math.sin(rotation) * radius,
      centerX + Math.cos(rotation + Math.PI) * radius,
      centerY + Math.sin(rotation + Math.PI) * radius
    );
    
    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)'); // red
    gradient.addColorStop(0.5, 'rgba(0, 0, 255, 0.3)'); // blue  
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)'); // red
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  }

  // draw trail
  if(orb.trail.length > 1) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Draw segments with proper fading
    for(let i = 0; i < orb.trail.length - 1; i++) {
      const p1 = orb.trail[i];
      const p2 = orb.trail[i + 1];
      const t = i / (orb.trail.length - 1);
      
      // Calculate alpha and thickness that properly fade
      const alpha = Math.pow(1 - t, 2); // quadratic fade for smoother transition
      const thickness = orb.r * 2 * (0.1 + 0.9 * (1 - t));
      
      if(alpha > 0.01) { // only draw if visible
        ctx.beginPath();
        ctx.globalAlpha = alpha * 0.8;
        ctx.strokeStyle = orb.color;
        ctx.lineWidth = thickness;
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
      }
    }
    
    ctx.globalAlpha = 1; // reset alpha
  }

  // outer glow
  const g = ctx.createRadialGradient(orb.x, orb.y, orb.r*0.4, orb.x, orb.y, orb.r*6);
  if(orb.color === '#ff4444') {
    // Red glow for error state
    g.addColorStop(0, 'rgba(255,68,68,0.22)');
    g.addColorStop(0.6, 'rgba(255,68,68,0.08)');
    g.addColorStop(1, 'rgba(255,68,68,0)');
  } else if(orb.color === '#44ff44') {
    // Green glow
    g.addColorStop(0, 'rgba(68,255,68,0.22)');
    g.addColorStop(0.6, 'rgba(68,255,68,0.08)');
    g.addColorStop(1, 'rgba(68,255,68,0)');
  } else if(orb.color === '#ffff44') {
    // Yellow glow
    g.addColorStop(0, 'rgba(255,255,68,0.22)');
    g.addColorStop(0.6, 'rgba(255,255,68,0.08)');
    g.addColorStop(1, 'rgba(255,255,68,0)');
  } else if(orb.color === '#ff44ff') {
    // Magenta glow
    g.addColorStop(0, 'rgba(255,68,255,0.22)');
    g.addColorStop(0.6, 'rgba(255,68,255,0.08)');
    g.addColorStop(1, 'rgba(255,68,255,0)');
  } else if(orb.color === '#44ffff') {
    // Cyan glow
    g.addColorStop(0, 'rgba(68,255,255,0.22)');
    g.addColorStop(0.6, 'rgba(68,255,255,0.08)');
    g.addColorStop(1, 'rgba(68,255,255,0)');
  } else {
    // Normal blue glow
    g.addColorStop(0, 'rgba(57,176,255,0.22)');
    g.addColorStop(0.6, 'rgba(57,176,255,0.08)');
    g.addColorStop(1, 'rgba(57,176,255,0)');
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(orb.x, orb.y, orb.r*6, 0, Math.PI*2);
  ctx.fill();

  // core neon
  ctx.beginPath();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = orb.color; // use dynamic color
  ctx.globalAlpha = 1;
  ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI*2);
  ctx.fill();

  // sharp spec
  ctx.beginPath();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.arc(orb.x - orb.r*0.35, orb.y - orb.r*0.35, orb.r*0.28, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 1;
  
  // Draw network scan elements
  if(state === 'network-scan') {
    ctx.globalCompositeOperation = 'lighter';
    
    // Draw radar pulses
    for(let pulse of networkScanPulses) {
      const alpha = pulse.life / pulse.maxLife;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(57, 176, 255, ${alpha * 0.6})`;
      ctx.lineWidth = 2;
      ctx.globalAlpha = alpha;
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner pulse ring
      ctx.beginPath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
      ctx.lineWidth = 1;
      ctx.arc(pulse.x, pulse.y, pulse.radius * 0.8, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Draw discovered network nodes
    for(let node of networkNodes) {
      const nodeAge = tick - node.discoveredTime;
      const nodeAlpha = Math.min(1, nodeAge / 200) * Math.max(0, 1 - nodeAge / 8000);
      const nodePulse = Math.sin(tick * 0.01 + node.pulsePhase) * 0.3 + 0.7;
      
      if(node.type === 'server') {
        // Server nodes - larger, more prominent
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 200, 100, ${nodeAlpha * 0.8})`;
        ctx.globalAlpha = nodeAlpha * nodePulse;
        ctx.arc(node.x, node.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Server indicator ring
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 200, 100, ${nodeAlpha * 0.6})`;
        ctx.lineWidth = 1;
        ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        // Client nodes - smaller, blue
        ctx.beginPath();
        ctx.fillStyle = `rgba(100, 200, 255, ${nodeAlpha * 0.7})`;
        ctx.globalAlpha = nodeAlpha * nodePulse;
        ctx.arc(node.x, node.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Connection lines to center (faint)
      if(nodeAlpha > 0.5) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(57, 176, 255, ${nodeAlpha * 0.1})`;
        ctx.lineWidth = 1;
        ctx.globalAlpha = nodeAlpha * 0.3;
        ctx.moveTo(orb.x, orb.y);
        ctx.lineTo(node.x, node.y);
        ctx.stroke();
      }
    }
    
    // Draw data packets flowing between nodes
    for(let packet of networkDataPackets) {
      const currentX = packet.startX + (packet.endX - packet.startX) * packet.progress;
      const currentY = packet.startY + (packet.endY - packet.startY) * packet.progress;
      const alpha = packet.life / packet.maxLife;
      
      // Main packet dot
      ctx.beginPath();
      ctx.fillStyle = packet.color;
      ctx.globalAlpha = alpha * 0.9;
      ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Packet trail
      for(let i = 1; i <= 3; i++) {
        const trailProgress = Math.max(0, packet.progress - i * 0.05);
        const trailX = packet.startX + (packet.endX - packet.startX) * trailProgress;
        const trailY = packet.startY + (packet.endY - packet.startY) * trailProgress;
        const trailAlpha = alpha * (1 - i * 0.3);
        
        ctx.beginPath();
        ctx.fillStyle = packet.color;
        ctx.globalAlpha = trailAlpha * 0.5;
        ctx.arc(trailX, trailY, 3 - i, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Draw security alerts
    for(let alert of networkSecurityAlerts) {
      const alpha = alert.life / alert.maxLife;
      const pulseIntensity = Math.sin(tick * 0.2) * 0.5 + 0.5;
      
      if(alert.severity === 'critical') {
        // Critical alerts - red pulsing
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 50, 50, ${alpha * pulseIntensity * 0.8})`;
        ctx.lineWidth = 3;
        ctx.globalAlpha = alpha;
        ctx.arc(alert.x, alert.y, alert.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner danger zone
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 50, 50, ${alpha * pulseIntensity * 0.2})`;
        ctx.arc(alert.x, alert.y, alert.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Warning alerts - yellow
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 200, 50, ${alpha * 0.6})`;
        ctx.lineWidth = 2;
        ctx.globalAlpha = alpha;
        ctx.arc(alert.x, alert.y, alert.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // Draw network interference
    for(let interference of networkInterference) {
      const alpha = interference.life / interference.maxLife;
      ctx.globalAlpha = alpha * interference.intensity;
      
      if(interference.pattern === 'static') {
        // Static interference
        for(let i = 0; i < 20; i++) {
          const x = interference.x + (Math.random() - 0.5) * 60;
          const y = interference.y + (Math.random() - 0.5) * 60;
          ctx.beginPath();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + (Math.random() - 0.5) * 10, y + (Math.random() - 0.5) * 10);
          ctx.stroke();
        }
      } else {
        // Wave interference
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
        ctx.lineWidth = 2;
        const waveRadius = 30 + Math.sin(tick * 0.1) * 10;
        ctx.arc(interference.x, interference.y, waveRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // Draw network health pulses
    for(let healthPulse of networkHealthPulses) {
      const alpha = healthPulse.life / healthPulse.maxLife;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(0, 255, 136, ${alpha * 0.6})`;
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha;
      ctx.arc(healthPulse.x, healthPulse.y, healthPulse.radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
  }
  
  // Draw typewriter effect
  if(state === 'typewriter') {
    ctx.globalCompositeOperation = 'lighter';
    
    // Draw trails for companion orbs (same style as main orb)
    for(let i = 0; i < companionTrails.length; i++) {
      const trail = companionTrails[i];
      if(trail.length > 1) {
        ctx.globalCompositeOperation = 'lighter';
        for(let j = 1; j < trail.length; j++) {
          const prev = trail[j-1];
          const curr = trail[j];
          const progress = j / trail.length;
          const alpha = progress * 0.8; // fade along trail
          
          ctx.beginPath();
          ctx.strokeStyle = orb.color;
          ctx.lineWidth = ORB_RADIUS * 2 * alpha;
          ctx.globalAlpha = alpha;
          ctx.lineCap = 'round';
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }
    
    // Draw the two companion orbs (main orb is drawn normally)
    for(let i = 0; i < typewriterOrbs.length; i++) {
      let companionOrb = typewriterOrbs[i];
      
      // Only draw if the orb has started moving or oscillating
      if(companionOrb.splitProgress > 0 || companionOrb.currentAmplitude > 0) {
        // Outer glow (same as main orb)
        ctx.beginPath();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = companionOrb.alpha * 0.7;
        const g = ctx.createRadialGradient(companionOrb.x, companionOrb.y, 0, companionOrb.x, companionOrb.y, ORB_RADIUS * 6);
        g.addColorStop(0, 'rgba(57,176,255,0.22)');
        g.addColorStop(0.6, 'rgba(57,176,255,0.08)');
        g.addColorStop(1, 'rgba(57,176,255,0)');
        ctx.fillStyle = g;
        ctx.arc(companionOrb.x, companionOrb.y, ORB_RADIUS * 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Core neon
        ctx.beginPath();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = companionOrb.color;
        ctx.globalAlpha = companionOrb.alpha;
        ctx.arc(companionOrb.x, companionOrb.y, ORB_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Sharp spec highlight
        ctx.beginPath();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = companionOrb.alpha * 0.9;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.arc(companionOrb.x - ORB_RADIUS * 0.35, companionOrb.y - ORB_RADIUS * 0.35, ORB_RADIUS * 0.28, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // Draw fading typewriter orbs when transitioning away from typewriter state
  if(fadingTypewriterOrbs.length > 0) {
    // Update and draw fading trails
    for(let i = 0; i < fadingCompanionTrails.length; i++) {
      const trail = fadingCompanionTrails[i];
      if(trail.length > 0) {
        ctx.globalCompositeOperation = 'lighter';
        ctx.strokeStyle = ORB_COLOR;
        
        for(let j = 1; j < trail.length; j++) {
          const curr = trail[j];
          const prev = trail[j-1];
          const alpha = (j / trail.length) * 0.8 * curr.alpha;
          
          ctx.beginPath();
          ctx.lineWidth = ORB_RADIUS * 2 * alpha;
          ctx.globalAlpha = alpha;
          ctx.lineCap = 'round';
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }
    
    // Draw fading orbs and update their fade
    for(let i = fadingTypewriterOrbs.length - 1; i >= 0; i--) {
      let fadingOrb = fadingTypewriterOrbs[i];
      
      // Update fade alpha (fade out over 2500ms for a very gentle fade)
      const fadeElapsed = tick - fadingOrb.fadeStartTime;
      fadingOrb.fadeAlpha = Math.max(0, 1 - (fadeElapsed / 2500));
      
      console.log(`Fading orb ${i}: fadeElapsed=${fadeElapsed}, fadeAlpha=${fadingOrb.fadeAlpha}`);
      
      // Remove completely faded orbs
      if(fadingOrb.fadeAlpha <= 0) {
        console.log(`Removing completely faded orb ${i}`);
        fadingTypewriterOrbs.splice(i, 1);
        continue;
      }
      
      // Draw fading orb with reduced alpha
      const finalAlpha = fadingOrb.alpha * fadingOrb.fadeAlpha;
      
      // Outer glow
      ctx.beginPath();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = finalAlpha * 0.7;
      const g = ctx.createRadialGradient(fadingOrb.x, fadingOrb.y, 0, fadingOrb.x, fadingOrb.y, ORB_RADIUS * 6);
      g.addColorStop(0, fadingOrb.color);
      g.addColorStop(0.3, 'rgba(57,176,255,0.3)');
      g.addColorStop(1, 'rgba(57,176,255,0)');
      ctx.fillStyle = g;
      ctx.arc(fadingOrb.x, fadingOrb.y, ORB_RADIUS * 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main orb
      ctx.beginPath();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = fadingOrb.color;
      ctx.globalAlpha = finalAlpha;
      ctx.arc(fadingOrb.x, fadingOrb.y, ORB_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Spec highlight
      ctx.beginPath();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = finalAlpha * 0.9;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.arc(fadingOrb.x - ORB_RADIUS * 0.35, fadingOrb.y - ORB_RADIUS * 0.35, ORB_RADIUS * 0.28, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Fade out trail points
    for(let i = 0; i < fadingCompanionTrails.length; i++) {
      const trail = fadingCompanionTrails[i];
      for(let j = trail.length - 1; j >= 0; j--) {
        trail[j].alpha *= 0.98; // Fade trail points
        if(trail[j].alpha < 0.05) {
          trail.splice(j, 1);
        }
      }
    }
    
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // Draw error sparks if in error states
  if((state === 'critical-error' || state === 'transition-to-idle') && errorSparks.length > 0) {
    ctx.globalCompositeOperation = 'lighter';
    for(let spark of errorSparks) {
      const alpha = spark.life / spark.maxLife;
      const sparkColors = ['#ff6666', '#ffaaaa', '#ffffff', '#ffff88'];
      const colorIndex = Math.floor(Math.random() * sparkColors.length);
      
      ctx.beginPath();
      ctx.fillStyle = sparkColors[colorIndex];
      ctx.globalAlpha = alpha * 0.8;
      ctx.arc(spark.x, spark.y, spark.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Add small spark lines
      ctx.beginPath();
      ctx.strokeStyle = sparkColors[colorIndex];
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha * 0.6;
      const lineLength = spark.size * 3;
      ctx.moveTo(spark.x - lineLength, spark.y);
      ctx.lineTo(spark.x + lineLength, spark.y);
      ctx.moveTo(spark.x, spark.y - lineLength);
      ctx.lineTo(spark.x, spark.y + lineLength);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
}

// Behavior implementations
let tick = 0;
function update(dt){
  tick += dt;
  // behavior per state
  if(state === 'idle'){
    // gentle breathing float around center
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2 - 10;
    const t = Math.sin(tick*0.0015);
    const targetX = cx + Math.cos(tick*0.0009) * 18;
    const targetY = cy + t * 6;
    orb.vx += (targetX - orb.x) * 0.02;
    orb.vy += (targetY - orb.y) * 0.02;
  } else if(state === 'thinking'){
    // orbit in place faster
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.18;
    const speed = 0.0028; // adjust spin speed
    const ang = tick * speed;
    const targetX = cx + Math.cos(ang) * radius;
    const targetY = cy + Math.sin(ang) * radius * 0.8; // slight ellipse
    orb.vx += (targetX - orb.x) * 0.08;
    orb.vy += (targetY - orb.y) * 0.08;
    // tail stronger
    addTrail(orb.x, orb.y, 0.9);
  } else if(state === 'searching'){
    // quick darts with some randomness
    if(Math.random() < 0.02){
      const tx = rand(40, canvas.clientWidth-40);
      const ty = rand(40, canvas.clientHeight-40);
      orb.vx += (tx - orb.x) * 0.12;
      orb.vy += (ty - orb.y) * 0.12;
    }
    orb.vx *= 0.96;
    orb.vy *= 0.96;
  } else if(state === 'windows-loading'){
    // Windows loading spinner behavior: circular motion with speed variation
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.15;
    
    // Base rotation speed (twice as fast now)
    const baseSpeed = 0.1; // doubled from 0.05
    
    // Determine speed based on current position in the circle
    const normalizedAngle = windowsLoadingAngle % (Math.PI * 2);
    let speedMultiplier;
    
    if (normalizedAngle < Math.PI) {
      // Top half: speed up (0 to π)
      speedMultiplier = 1 + Math.sin(normalizedAngle) * 1.5; // speeds up to 2.5x
    } else {
      // Bottom half: slow down (π to 2π)
      speedMultiplier = 1 + Math.sin(normalizedAngle) * 0.3; // slows down to 0.7x
    }
    
    // Update angle with variable speed
    windowsLoadingAngle += baseSpeed * speedMultiplier;
    
    // Calculate position
    orb.x = cx + Math.cos(windowsLoadingAngle) * radius;
    orb.y = cy + Math.sin(windowsLoadingAngle) * radius;
    
    // Add trail with high alpha for strong tail effect
    addTrailPoint(orb.x, orb.y, 0.95);
  } else if(state === 'error'){
    // Error state: wobble side-to-side like a ruler hit on a desk, then transition
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - errorStartTime;
    
    if(elapsed < 1500) { // 1.5 seconds of wobbling
      // Wobble frequency and amplitude that dampens over time
      const frequency = 0.025; // how fast it wobbles
      const dampening = Math.max(0, 1 - (elapsed / 1500)); // fade out over 1.5s
      const amplitude = 25 * dampening; // how far it wobbles
      
      // Oscillating motion with dampening
      const wobbleX = Math.sin(elapsed * frequency) * amplitude * dampening;
      
      // Center the orb and add wobble
      orb.vx += (cx + wobbleX - orb.x) * 0.15;
      orb.vy += (cy - orb.y) * 0.15;
      
      // Set error color
      orb.color = '#ff4444'; // red color for error
      orb.r = ORB_RADIUS; // normal size during wobble
    } else {
      // Transition to critical error state
      setState('critical-error');
    }
  } else if(state === 'critical-error'){
    // EPIC pulsating red orb with sparks - HARDER BETTER FASTER STRONGER
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - criticalErrorStartTime;
    
    if(elapsed < 4500) { // 4.5 seconds of EPIC pulsating and sparks
      // Pulsating phase - HARDER BETTER FASTER STRONGER
      const pulseTime = elapsed;
      const pulseFreq = 0.003; // MUCH slower, more dramatic pulse
      const pulseIntensity = Math.sin(pulseTime * pulseFreq) * 0.5 + 0.5;
      
      // Keep orb centered
      orb.x = cx;
      orb.y = cy;
      orb.vx = 0;
      orb.vy = 0;
      
      // MASSIVELY grow the orb and make it pulse BIGGER
      const baseSize = ORB_RADIUS * 8; // 8x bigger base size
      const pulseSize = ORB_RADIUS * 6; // HUGE additional pulsing size
      orb.r = baseSize + pulseSize * pulseIntensity; // Can reach 14x normal size!
      
      // Pulsating red color - more dramatic and STRONGER
      const redIntensity = Math.floor(180 + pulseIntensity * 75); // deeper range
      const darkening = Math.floor(10 + pulseIntensity * 10); // pulsating darkness
      orb.color = `rgb(${redIntensity}, ${darkening}, ${darkening})`; // ultra intimidating red
      
      // Create MORE electrical sparks flying out from center
      if(Math.random() < 0.6) { // 60% chance each frame - MORE SPARKS
        const sparkAngle = Math.random() * Math.PI * 2;
        const sparkSpeed = 4 + Math.random() * 6; // FASTER sparks
        errorSparks.push({
          x: cx, // start from center
          y: cy, // start from center
          vx: Math.cos(sparkAngle) * sparkSpeed,
          vy: Math.sin(sparkAngle) * sparkSpeed,
          life: 30 + Math.random() * 20, // LONGER lasting sparks
          maxLife: 50,
          size: 2 + Math.random() * 3 // BIGGER sparks
        });
      }
      
      // Update sparks
      errorSparks = errorSparks.filter(spark => {
        spark.x += spark.vx;
        spark.y += spark.vy;
        spark.vx *= 0.99; // even less friction for LONGER sparks
        spark.vy *= 0.99;
        spark.life--;
        return spark.life > 0;
      });
    } else {
      // Start smooth transition back to idle
      transitionStartTime = tick;
      transitionFromColor = orb.color;
      transitionToColor = ORB_COLOR;
      setState('transition-to-idle');
    }
  } else if(state === 'transition-to-idle'){
    // Smooth transition back to normal
    const elapsed = tick - transitionStartTime;
    const transitionDuration = 1000; // 1 second transition
    
    if(elapsed < transitionDuration) {
      const t = elapsed / transitionDuration;
      const easedT = ease(t); // smooth easing
      
      // Smooth color transition
      orb.color = interpolateColor(transitionFromColor, transitionToColor, easedT);
      
      // Smooth size transition
      const startSize = ORB_RADIUS * 8; // starting from large size
      const endSize = ORB_RADIUS;
      orb.r = startSize + (endSize - startSize) * easedT;
      
      // Keep centered during transition
      const cx = canvas.clientWidth/2;
      const cy = canvas.clientHeight/2;
      orb.x = cx;
      orb.y = cy;
      orb.vx = 0;
      orb.vy = 0;
      
      // Fade out remaining sparks
      errorSparks = errorSparks.filter(spark => {
        spark.x += spark.vx;
        spark.y += spark.vy;
        spark.vx *= 0.95;
        spark.vy *= 0.95;
        spark.life -= 2; // fade faster during transition
        return spark.life > 0;
      });
    } else {
      // Transition complete, go to idle
      orb.r = ORB_RADIUS;
      orb.color = ORB_COLOR;
      errorSparks = [];
      setState('idle');
    }
  } else if(state === 'network-scan'){
    // Network scanning animation - radar pulses with node discovery
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - networkScanStartTime;
    
    // Initialize enhanced effects data
    if(!networkDataPackets) networkDataPackets = [];
    if(!networkSecurityAlerts) networkSecurityAlerts = [];
    if(!networkInterference) networkInterference = [];
    if(!networkHealthPulses) networkHealthPulses = [];
    
    // Keep orb centered and pulsing gently
    orb.x = cx;
    orb.y = cy;
    orb.vx = 0;
    orb.vy = 0;
    
    // Subtle blue pulsing for the scanning orb
    const scanPulse = Math.sin(elapsed * 0.008) * 0.3 + 0.7;
    orb.color = `rgb(${Math.floor(57 * scanPulse)}, ${Math.floor(176 * scanPulse)}, 255)`;
    
    // Send out radar pulses every 800ms
    if(elapsed % 800 < 50) { // brief window to create pulse
      networkScanPulses.push({
        x: cx,
        y: cy,
        radius: 0,
        maxRadius: Math.min(canvas.clientWidth, canvas.clientHeight) * 0.6,
        life: 100,
        maxLife: 100
      });
    }
    
    // Update radar pulses
    networkScanPulses = networkScanPulses.filter(pulse => {
      pulse.radius += 3; // pulse expansion speed
      pulse.life--;
      return pulse.life > 0 && pulse.radius < pulse.maxRadius;
    });
    
    // Randomly discover network nodes when pulses reach them
    for(let pulse of networkScanPulses) {
      if(pulse.radius > 50 && pulse.radius < 300 && Math.random() < 0.02) {
        const angle = Math.random() * Math.PI * 2;
        const distance = pulse.radius + (Math.random() - 0.5) * 40;
        
        // Only add if not too close to existing nodes
        const newX = cx + Math.cos(angle) * distance;
        const newY = cy + Math.sin(angle) * distance;
        let tooClose = false;
        
        for(let node of networkNodes) {
          const dist = Math.sqrt((newX - node.x) ** 2 + (newY - node.y) ** 2);
          if(dist < 30) tooClose = true;
        }
        
        if(!tooClose && networkNodes.length < 12) {
          networkNodes.push({
            x: newX,
            y: newY,
            discoveredTime: tick,
            pulsePhase: Math.random() * Math.PI * 2,
            type: Math.random() < 0.3 ? 'server' : 'client' // 30% servers, 70% clients
          });
        }
      }
    }
    
    // Remove nodes that are too old (keep scanning fresh)
    networkNodes = networkNodes.filter(node => (tick - node.discoveredTime) < 8000);
    
    // Spawn data packets between connected nodes
    if(networkNodes.length >= 2 && elapsed % 400 < 50) {
      const sourceNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      const targetNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      
      if(sourceNode !== targetNode) {
        networkDataPackets.push({
          startX: sourceNode.x,
          startY: sourceNode.y,
          endX: targetNode.x,
          endY: targetNode.y,
          progress: 0,
          speed: 0.02 + Math.random() * 0.03,
          color: Math.random() < 0.7 ? '#00ff88' : '#ff4444', // mostly green, some red for errors
          life: 100,
          maxLife: 100
        });
      }
    }
    
    // Update data packets
    networkDataPackets = networkDataPackets.filter(packet => {
      packet.progress += packet.speed;
      packet.life--;
      return packet.progress < 1.0 && packet.life > 0;
    });
    
    // Spawn occasional security alerts
    if(networkNodes.length > 3 && Math.random() < 0.001) {
      const alertNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
      networkSecurityAlerts.push({
        x: alertNode.x,
        y: alertNode.y,
        radius: 5,
        maxRadius: 60,
        life: 120,
        maxLife: 120,
        severity: Math.random() < 0.3 ? 'critical' : 'warning'
      });
    }
    
    // Update security alerts
    networkSecurityAlerts = networkSecurityAlerts.filter(alert => {
      alert.radius += 1.2;
      alert.life--;
      return alert.life > 0 && alert.radius < alert.maxRadius;
    });
    
    // Spawn interference patterns occasionally
    if(Math.random() < 0.0008) {
      networkInterference.push({
        x: Math.random() * canvas.clientWidth,
        y: Math.random() * canvas.clientHeight,
        life: 60,
        maxLife: 60,
        intensity: Math.random() * 0.5 + 0.3,
        pattern: Math.random() < 0.5 ? 'static' : 'wave'
      });
    }
    
    // Update interference
    networkInterference = networkInterference.filter(interference => {
      interference.life--;
      return interference.life > 0;
    });
    
    // Create health pulses for stable connections
    if(networkNodes.length > 0 && elapsed % 1500 < 50) {
      for(let node of networkNodes) {
        if(Math.random() < 0.4) { // 40% chance per node
          networkHealthPulses.push({
            x: node.x,
            y: node.y,
            radius: 2,
            maxRadius: 25,
            life: 80,
            maxLife: 80
          });
        }
      }
    }
    
    // Update health pulses
    networkHealthPulses = networkHealthPulses.filter(pulse => {
      pulse.radius += 0.5;
      pulse.life--;
      return pulse.life > 0 && pulse.radius < pulse.maxRadius;
    });
  } else if(state === 'typewriter') {
    // Typewriter: existing orb stays center, two companions split left/right
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const elapsed = tick - typewriterStartTime;
    
    // Keep main orb in center with gentle oscillation (larger amplitude)
    orb.x = cx;
    orb.vx = 0;
    orb.vy = 0;
    
    // Main orb oscillates with larger amplitude but same period
    const mainOscillation = Math.sin(tick * 0.006) * 15; // slower and higher/lower
    orb.y = cy + mainOscillation;
    
    // Initialize companion trails
    if(companionTrails.length === 0) {
      companionTrails = [[], []]; // Two separate trail arrays
    }
    
    // Initialize two companion orbs if needed
    if(typewriterOrbs.length === 0) {
      for(let i = 0; i < 2; i++) {
        typewriterOrbs.push({
          x: cx, // start at center
          y: cy, // start at center
          targetX: cx + (i === 0 ? -60 : 60), // further apart: left and right
          targetY: cy,
          baseY: cy,
          oscillationSpeed: 0.006, // same as main orb but slower
          oscillationAmplitude: 10, // smaller amplitude than main orb
          phase: (i + 1) * Math.PI * 0.5, // phase offset from main orb
          damping: 0.999, // very slow damping
          currentAmplitude: 0, // starts with no oscillation
          color: orb.color, // same color as main orb
          alpha: 1,
          splitProgress: 0 // how far along the split animation
        });
      }
    }
    
    // Update each companion orb
    for(let i = 0; i < typewriterOrbs.length; i++) {
      let companionOrb = typewriterOrbs[i];
      
      // Animate the split (orbs moving to their positions)
      if(companionOrb.splitProgress < 1) {
        companionOrb.splitProgress = Math.min(1, companionOrb.splitProgress + 0.012); // slightly slower split
        const ease = 1 - Math.pow(1 - companionOrb.splitProgress, 3); // ease out
        companionOrb.x = cx + (companionOrb.targetX - cx) * ease;
      }
      
      // Start oscillation after a delay
      const oscillationDelay = (i + 1) * 300; // 300ms, 600ms delays
      if(elapsed > oscillationDelay) {
        // Gradual amplitude increase
        const timeInOscillation = elapsed - oscillationDelay;
        companionOrb.currentAmplitude = Math.min(companionOrb.oscillationAmplitude, timeInOscillation * 0.008);
        
        // Gentle up/down oscillation with very slow damping
        const oscillation = Math.sin((tick * companionOrb.oscillationSpeed) + companionOrb.phase) * companionOrb.currentAmplitude;
        companionOrb.y = companionOrb.baseY + oscillation;
        
        // Apply very subtle damping over time
        companionOrb.currentAmplitude *= companionOrb.damping;
        
        // Add trail points for this companion orb (using same system as main orb)
        addCompanionTrailPoint(companionOrb.x, companionOrb.y, 1.0, i);
      }
    }
  } else if(state === 'dvd-bounce'){
    // DVD Logo bounce - classic screensaver movement
    const margin = orb.r + 5; // keep orb away from edges
    
    // Move orb by velocity (direct position update, bypass physics)
    orb.x += dvdVelocity.x;
    orb.y += dvdVelocity.y;
    
    // Check for bounces and handle them separately
    let bounced = false;
    
    // Bounce off left/right walls
    if(orb.x <= margin) {
      dvdVelocity.x = Math.abs(dvdVelocity.x); // ensure positive
      orb.x = margin;
      bounced = true;
    } else if(orb.x >= canvas.clientWidth - margin) {
      dvdVelocity.x = -Math.abs(dvdVelocity.x); // ensure negative
      orb.x = canvas.clientWidth - margin;
      bounced = true;
    }
    
    // Bounce off top/bottom walls
    if(orb.y <= margin) {
      dvdVelocity.y = Math.abs(dvdVelocity.y); // ensure positive
      orb.y = margin;
      bounced = true;
    } else if(orb.y >= canvas.clientHeight - margin) {
      dvdVelocity.y = -Math.abs(dvdVelocity.y); // ensure negative
      orb.y = canvas.clientHeight - margin;
      bounced = true;
    }
    
    // Change color on any bounce
    if(bounced) {
      const colors = ['#39b0ff', '#ff4444', '#44ff44', '#ffff44', '#ff44ff', '#44ffff'];
      orb.color = colors[Math.floor(Math.random() * colors.length)];
    }
    
    // Reset physics velocities to prevent interference
    orb.vx = 0;
    orb.vy = 0;
    
    // Add trail
    addTrailPoint(orb.x, orb.y, 0.8);
  } else if(state === 'pipes'){
    // Pipes screensaver - move in straight lines with 90-degree turns
    const margin = 40; // increased margin for better wall detection
    const minSegmentLength = 40; // minimum distance before allowing a turn
    const maxSegmentLength = 120; // maximum distance before forcing a turn
    
    // Move in current direction
    orb.x += pipesDirection.x * pipesSpeed;
    orb.y += pipesDirection.y * pipesSpeed;
    pipesSegmentLength += pipesSpeed;
    
    // Check if we need to turn (hit wall or random turn)
    let shouldTurn = false;
    let availableDirections = [];
    
    // More aggressive wall detection
    if(orb.x <= margin && pipesDirection.x <= 0) shouldTurn = true;
    if(orb.x >= canvas.clientWidth - margin && pipesDirection.x >= 0) shouldTurn = true;
    if(orb.y <= margin && pipesDirection.y <= 0) shouldTurn = true;
    if(orb.y >= canvas.clientHeight - margin && pipesDirection.y >= 0) shouldTurn = true;
    
    // Random turn after minimum segment length
    if(pipesSegmentLength > minSegmentLength && Math.random() < 0.02) shouldTurn = true;
    
    // Force turn after maximum segment length
    if(pipesSegmentLength > maxSegmentLength) shouldTurn = true;
    
    if(shouldTurn) {
      // Find available directions (90-degree turns only, no backing up)
      const directions = [
        { x: 1, y: 0 },   // right
        { x: 0, y: 1 },   // down
        { x: -1, y: 0 },  // left
        { x: 0, y: -1 }   // up
      ];
      
      for(let dir of directions) {
        // Don't go backwards
        if(dir.x === -pipesDirection.x && dir.y === -pipesDirection.y) continue;
        
        // Check if this direction is safe (won't immediately hit wall)
        let futureX = orb.x + dir.x * 60; // look further ahead
        let futureY = orb.y + dir.y * 60;
        if(futureX > margin && futureX < canvas.clientWidth - margin && 
           futureY > margin && futureY < canvas.clientHeight - margin) {
          availableDirections.push(dir);
        }
      }
      
      // If no safe directions, allow backing up as last resort
      if(availableDirections.length === 0) {
        for(let dir of directions) {
          let futureX = orb.x + dir.x * 60;
          let futureY = orb.y + dir.y * 60;
          if(futureX > margin && futureX < canvas.clientWidth - margin && 
             futureY > margin && futureY < canvas.clientHeight - margin) {
            availableDirections.push(dir);
          }
        }
      }
      
      // Choose random available direction
      if(availableDirections.length > 0) {
        pipesDirection = availableDirections[Math.floor(Math.random() * availableDirections.length)];
        pipesSegmentLength = 0;
        
        // Change color on turn like classic pipes
        const colors = ['#39b0ff', '#ff4444', '#44ff44', '#ffff44', '#ff44ff', '#44ffff'];
        orb.color = colors[Math.floor(Math.random() * colors.length)];
      } else {
        // Emergency: teleport to center and pick new direction
        orb.x = canvas.clientWidth / 2;
        orb.y = canvas.clientHeight / 2;
        pipesDirection = directions[Math.floor(Math.random() * directions.length)];
        pipesSegmentLength = 0;
      }
    }
    
    // Keep within bounds with stronger constraints
    if(orb.x < margin) { orb.x = margin; pipesDirection.x = Math.max(0, pipesDirection.x); }
    if(orb.x > canvas.clientWidth - margin) { orb.x = canvas.clientWidth - margin; pipesDirection.x = Math.min(0, pipesDirection.x); }
    if(orb.y < margin) { orb.y = margin; pipesDirection.y = Math.max(0, pipesDirection.y); }
    if(orb.y > canvas.clientHeight - margin) { orb.y = canvas.clientHeight - margin; pipesDirection.y = Math.min(0, pipesDirection.y); }
    
    // Reset physics velocities
    orb.vx = 0;
    orb.vy = 0;
    
    // Add trail for pipe effect
    addTrailPoint(orb.x, orb.y, 0.9);
  } else if(state.startsWith('pattern-')){
    // pattern-driven: we will call pattern functions which set orb.x/y directly
    // see pattern controllers which update orb.x and orb.y each frame
  }

  // apply velocity
  orb.x += orb.vx;
  orb.y += orb.vy;
  // friction
  orb.vx *= FRICTION;
  orb.vy *= FRICTION;

  // constrain (but not for DVD bounce or pipes which handle their own boundaries)
  if(state !== 'dvd-bounce' && state !== 'pipes') {
    orb.x = Math.max(18, Math.min(canvas.clientWidth-18, orb.x));
    orb.y = Math.max(18, Math.min(canvas.clientHeight-18, orb.y));
  }

  // always add trail (small alpha for subtle tail)
  if(!state.startsWith('pattern-') && state !== 'dvd-bounce' && state !== 'pipes') addTrailPoint(orb.x, orb.y, 0.55);
}

// animation loop
let last = performance.now();
let rafId;
function loop(now){
  const dt = now - last;
  last = now;

  // call pattern updater if any
  if(patternActive && patterns[patternActive]) patterns[patternActive](now);
  update(dt);
  draw();
  rafId = requestAnimationFrame(loop);
}
rafId = requestAnimationFrame(loop);

// Patterns: each pattern should set orb.x and orb.y over time
let patternActive = null;
let patterns = {
  'pattern-heart': function(now){
    // parametric heart curve scaled & centered
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    const scale = Math.min(canvas.clientWidth, canvas.clientHeight) * 2.0; // 10x bigger (from 0.2 to 2.0)
    const t = (now*0.00225) % (Math.PI*2); // 0.5x slower (from 0.0045 to 0.00225)
    // classic heart parametric (x = 16 sin^3 t, y = 13 cos t - 5 cos 2t -2 cos 3t - cos 4t)
    const s = t;
    const x = 16*Math.pow(Math.sin(s),3);
    const y = 13*Math.cos(s) - 5*Math.cos(2*s) - 2*Math.cos(3*s) - Math.cos(4*s);
    orb.x = cx + x * scale * 0.0125;
    orb.y = cy - y * scale * 0.0125;
    addTrailPoint(orb.x, orb.y, 0.92);
  }
};

// Controls to change state
const buttons = document.querySelectorAll('[data-state]');
buttons.forEach(b=>b.addEventListener('click', ()=>setState(b.dataset.state)));
const windowsSpinner = document.getElementById('windowsSpinner');

function setState(s){
  console.log(`setState called: current state="${state}", new state="${s}", typewriterOrbs.length=${typewriterOrbs.length}`);
  
  // If we're leaving typewriter state, start fade-out animation BEFORE changing state
  if(state === 'typewriter' && s !== 'typewriter' && typewriterOrbs.length > 0) {
    console.log(`Starting fade-out transition: ${typewriterOrbs.length} orbs to fade`);
    // Move current typewriter orbs to fading array with fade properties
    fadingTypewriterOrbs = typewriterOrbs.map(orb => ({
      ...orb,
      fadeAlpha: 1.0,
      fadeStartTime: tick
    }));
    console.log(`Created ${fadingTypewriterOrbs.length} fading orbs`);
    // Copy trails to fading trails
    fadingCompanionTrails = [
      [...companionTrails[0]], 
      [...companionTrails[1]]
    ];
    
    // Clear active typewriter elements
    typewriterOrbs = [];
    companionTrails = [[], []];
  }
  
  state = s === 'idle' ? 'idle' : s;
  patternActive = null;
  
  // Reset windows loading angle when entering the state
  if(s === 'windows-loading'){
    windowsLoadingAngle = 0;
  }
  
  // Set error start time and reset color
  if(s === 'error'){
    errorStartTime = tick;
    orb.color = '#ff4444'; // red for error
    orb.r = ORB_RADIUS; // reset size
    errorSparks = []; // clear any existing sparks
  } else if(s === 'critical-error'){
    criticalErrorStartTime = tick;
    errorSparks = []; // clear any existing sparks
  } else if(s === 'network-scan'){
    networkScanStartTime = tick;
    networkScanPulses = []; // clear any existing pulses
    networkNodes = []; // clear any existing nodes
    networkDataPackets = []; // clear data packets
    networkSecurityAlerts = []; // clear alerts
    networkInterference = []; // clear interference
    networkHealthPulses = []; // clear health pulses
    orb.color = '#39b0ff'; // scanning blue
  } else if(s === 'typewriter') {
    typewriterStartTime = tick;
    typewriterOrbs = []; // clear existing orbs
    companionTrails = [[], []]; // clear existing trails
    companionLastTrailPos = [{x: 0, y: 0}, {x: 0, y: 0}]; // reset trail positions
    orb.color = ORB_COLOR; // reset main orb (it will be hidden during typewriter)
  } else if(s === 'transition-to-idle'){
    // Don't reset anything during transition - let it handle smoothly
  } else if(s === 'dvd-bounce') {
    orb.color = '#39b0ff'; // start with blue for DVD bounce
    // Reset velocity to ensure consistent start
    dvdVelocity = { x: 2, y: 1.5 };
  } else if(s === 'pipes') {
    orb.color = '#39b0ff'; // start with blue for pipes
    // Reset pipes state
    pipesDirection = { x: 1, y: 0 }; // start going right
    pipesSegmentLength = 0;
    pipesLastTurn = tick;
  } else {
    orb.color = ORB_COLOR; // back to normal blue
    orb.r = ORB_RADIUS; // reset size
  }
  
  // Handle Windows loading spinner
  if(s === 'windows-loading'){
    // Hide the CSS spinner since we're using the orb itself
    windowsSpinner.classList.remove('active');
  } else {
    windowsSpinner.classList.remove('active');
  }
  
  // if a pattern, enable it
  if(s.startsWith('pattern-')){
    patternActive = s;
  }
  // visual feedback: highlight canvas wrap briefly
  const wrap = document.getElementById('canvasWrap');
  wrap.animate([{boxShadow:'0 8px 40px rgba(57,176,255,0.06) inset'},{boxShadow:'0 10px 60px rgba(57,176,255,0.16) inset'}],{duration:300,fill:'forwards',direction:'alternate'});
}

// Input / send (placeholder for n8n integration)
const N8N_ENDPOINT = 'http://mita:5678/webhook/afa2b548-acd5-4157-bc51-3fc77548017e/chat';
const userInput = document.getElementById('userInput');
const sendBtn = document.getElementById('sendBtn');
const chatContainer = document.getElementById('chatContainer');
const chatMessages = document.getElementById('chatMessages');

// Robust scroll to bottom function
function scrollToBottom() {
  // Use requestAnimationFrame to ensure DOM has updated
  requestAnimationFrame(() => {
    // Scroll to the absolute bottom with some extra padding
    chatMessages.scrollTop = chatMessages.scrollHeight;
  });
}

// Simple markdown parser
function parseMarkdown(text) {
  return text
    // Bold: **text** or __text__
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/__(.*?)__/g, '<strong>$1</strong>')
    // Italic: *text* or _text_
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/_(.*?)_/g, '<em>$1</em>')
    // Inline code: `text`
    .replace(/`(.*?)`/g, '<code style="background:rgba(255,255,255,0.1);padding:2px 4px;border-radius:3px;font-family:monospace;">$1</code>')
    // Line breaks
    .replace(/\n/g, '<br>')
    // Links: [text](url)
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color:#6d9ff7;text-decoration:underline;" target="_blank">$1</a>');
}

// Helper function to safely set message content with markdown
function setMessageContent(element, content) {
  const sanitizedContent = content
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
  
  element.innerHTML = parseMarkdown(sanitizedContent);
}

// Add message to chat with improved styling and markdown support
function addMessage(content, isUser = false) {
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
  
  setMessageContent(messageDiv, content);
  chatMessages.appendChild(messageDiv);
  
  // Scroll to bottom after message is added
  scrollToBottom();
}

// Add typing indicator
function showTypingIndicator() {
  const typingDiv = document.createElement('div');
  typingDiv.className = 'typing-indicator';
  typingDiv.id = 'typing-indicator';
  typingDiv.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  chatMessages.appendChild(typingDiv);
  
  // Scroll to bottom after typing indicator is added
  scrollToBottom();
  
  return typingDiv;
}

// Remove typing indicator
function removeTypingIndicator() {
  const indicator = document.getElementById('typing-indicator');
  if (indicator) {
    indicator.remove();
  }
}

sendBtn.addEventListener('click', async ()=>{
  const text = userInput.value.trim();
  if(!text) return;
  
  // Add user message to chat
  addMessage(text, true);
  userInput.value = '';
  
  setState('thinking');
  
  // Show typing indicator
  const typingIndicator = showTypingIndicator();
  
  // If endpoint is configured, POST user input
  if(N8N_ENDPOINT){
    try{
      // Create a message element for streaming response
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message assistant';
      messageDiv.textContent = '';
      
      let streamedContent = '';
      
      console.log('Sending request to:', N8N_ENDPOINT);
      console.log('Request body:', {text});
      
      // Use fetch with proper streaming for POST requests
      const response = await fetch(N8N_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/plain' // Don't expect JSON response
        },
        body: JSON.stringify({text})
      });
      
      console.log('Response status:', response.status);
      console.log('Response headers:', Object.fromEntries(response.headers.entries()));
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Error response body:', errorText);
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
      
      setState('searching');
      
      // Remove typing indicator and add actual message
      removeTypingIndicator();
      chatMessages.appendChild(messageDiv);
      
      // Check if response has a body
      if (!response.body) {
        console.error('No response body available');
        messageDiv.textContent = 'Error: No response body';
        setState('idle');
        return;
      }
      
      // Read response as stream of text, not JSON
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      
      console.log('Starting to read response stream...');
      
      while (true) {
        const { done, value } = await reader.read();
        console.log('Read chunk:', { done, valueLength: value?.length });
        
        if (done) {
          console.log('Stream complete');
          break;
        }
        
        const chunk = decoder.decode(value, { stream: true });
        console.log('Decoded chunk:', JSON.stringify(chunk));
        
        buffer += chunk;
        
        // Split by newlines and process each complete line
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer
        
        for (const line of lines) {
          const trimmedLine = line.trim();
          console.log('Processing line:', JSON.stringify(trimmedLine));
          
          if (trimmedLine) {
            try {
              const data = JSON.parse(trimmedLine);
              console.log('Parsed JSON:', data);
              console.log('JSON keys:', Object.keys(data));
              console.log('Has output property?', 'output' in data);
              console.log('Output value:', data.output);
              
              // Handle n8n output format: {"output": "text"}
              if (data.output) {
                streamedContent = data.output; // Use = not += since it's the complete response
                setMessageContent(messageDiv, streamedContent);
                scrollToBottom();
                console.log('Set messageDiv.textContent to:', messageDiv.textContent);
                console.log('MessageDiv element:', messageDiv);
                console.log('Is messageDiv visible?', messageDiv.offsetParent !== null);
              }
              // Handle streaming format: {"type":"item","content":"word"}
              else if (data.type === 'item' && data.content) {
                streamedContent += data.content;
                setMessageContent(messageDiv, streamedContent);
                scrollToBottom();
              } else if (data.type === 'begin') {
                setState('searching');
              } else if (data.type === 'end') {
                setState('idle');
              } else {
                console.log('JSON does not match expected format - keys:', Object.keys(data));
              }
            } catch (e) {
              console.log('Not JSON, treating as text:', trimmedLine);
              // Not JSON, might be plain text - just add it
              if (trimmedLine.length > 0) {
                streamedContent += trimmedLine + ' ';
                setMessageContent(messageDiv, streamedContent);
                scrollToBottom();
                console.log('Updated display with text:', streamedContent);
              }
            }
          }
        }
      }
      
      // Process any remaining buffer content
      if (buffer.trim()) {
        console.log('Processing remaining buffer:', JSON.stringify(buffer));
        try {
          const data = JSON.parse(buffer.trim());
          console.log('Buffer JSON:', data);
          console.log('Buffer JSON keys:', Object.keys(data));
          
          // Handle n8n output format: {"output": "text"}
          if (data.output) {
            streamedContent = data.output;
            setMessageContent(messageDiv, streamedContent);
            console.log('Set content from buffer:', data.output);
            console.log('MessageDiv after buffer update:', messageDiv.textContent);
          }
          // Handle streaming format: {"type":"item","content":"word"}
          else if (data.type === 'item' && data.content) {
            streamedContent += data.content;
            setMessageContent(messageDiv, streamedContent);
          } else {
            console.log('Buffer JSON does not match expected format - keys:', Object.keys(data));
          }
        } catch (e) {
          console.log('Buffer is not JSON, adding as text');
          streamedContent += buffer.trim();
          setMessageContent(messageDiv, streamedContent);
          console.log('Final content from buffer:', streamedContent);
        }
      }
      
      setState('idle');
      
      console.log('Final streamed content:', JSON.stringify(streamedContent));
      console.log('MessageDiv content:', messageDiv.textContent);
      
      if (!streamedContent) {
        messageDiv.textContent = 'Response received (no content)';
        console.log('No content received, showing placeholder');
      }
      
    }catch(e){
      console.error('SSE setup failed', e);
      removeTypingIndicator();
      setState('critical-error');
      addMessage('Error: Could not setup SSE connection');
      await new Promise(r=>setTimeout(r, 2000));
      setState('idle');
    }
  } else {
    // demo: animate and show patterns depending on text
    setTimeout(() => removeTypingIndicator(), 500); // Remove typing indicator after short delay
    
    const lower = text.toLowerCase();
    if(lower.includes('heart')){
      setState('pattern-heart');
      await new Promise(r=>setTimeout(r,1700));
      addMessage("I'm drawing a heart pattern for you! ❤️");
    } else if(lower.includes('search')){
      setState('searching');
      await new Promise(r=>setTimeout(r,1200));
      addMessage("Searching through the network...");
    } else if(lower.includes('think') || lower.includes('loading')){
      setState('windows-loading');
      await new Promise(r=>setTimeout(r,2000));
      addMessage("Processing your request...");
    } else {
      setState('pattern-heart');
      await new Promise(r=>setTimeout(r,1200));
      addMessage("Hello! I can show you different animations. Try saying 'heart', 'search', or 'loading'!");
    }
    setState('idle');
  }
});

// Manual focus handler for input box
userInput.addEventListener('click', () => {
  userInput.focus();
});

// Handle Enter key to send message
userInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault(); // Prevent default form submission
    sendBtn.click(); // Trigger the send button click
  }
});

// start idle
setState('idle');

// initial placement
orb.x = canvas.clientWidth/2;
orb.y = canvas.clientHeight/2 - 10;
addTrailPoint(orb.x, orb.y, 0.9);

</script>
</body>
</html>
