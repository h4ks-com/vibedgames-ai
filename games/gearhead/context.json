{
  "messages": [
    {
      "role": "user",
      "content": "simple line animation using JS showing a side view of a turning gear that can be connected to other gears the user selects with the mouse\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Interactive Turning Gears</title>\n<style>\n  body {\n    margin: 0;\n    overflow: hidden;\n    background: #222;\n    user-select: none;\n    font-family: sans-serif;\n  }\n  #canvas {\n    display: block;\n    background: #111;\n    cursor: crosshair;\n  }\n  #instructions {\n    position: fixed;\n    top: 10px;\n    left: 10px;\n    color: #eee;\n    background: rgba(30,30,30,0.8);\n    padding: 8px 12px;\n    border-radius: 6px;\n    font-size: 14px;\n    max-width: 300px;\n    line-height: 1.3;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<div id=\"instructions\">\n  Click anywhere to place a gear.<br/>\n  Drag a gear to move it.<br/>\n  Click on a gear to select it, then click another to connect them.<br/>\n  Connected gears turn in opposite directions.<br/>\n  Use mouse wheel over a gear to resize it.<br/>\n  Press <b>Delete</b> or <b>Backspace</b> to remove selected gear.<br/>\n  <br/>\n  Gears are shown side-view with simple line animation.\n</div>\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  let W, H;\n\n  // Resize canvas\n  function resize() {\n    W = window.innerWidth;\n    H = window.innerHeight;\n    canvas.width = W * devicePixelRatio;\n    canvas.height = H * devicePixelRatio;\n    canvas.style.width = W + 'px';\n    canvas.style.height = H + 'px';\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.scale(devicePixelRatio, devicePixelRatio);\n  }\n  window.addEventListener('resize', resize);\n  resize();\n\n  // Gear class\n  class Gear {\n    constructor(x, y, radius = 50, teeth = 12) {\n      this.x = x;\n      this.y = y;\n      this.radius = radius; // radius to gear base edge\n      this.teeth = teeth; // number of teeth\n      this.angle = 0; // current rotation angle in radians\n      this.angularVelocity = 0; // radians per frame\n      this.connected = []; // array of connected gears\n      this.selected = false;\n      this.dragging = false;\n      this.dragOffsetX = 0;\n      this.dragOffsetY = 0;\n    }\n    isPointInside(px, py) {\n      const dx = px - this.x;\n      const dy = py - this.y;\n      return Math.sqrt(dx*dx + dy*dy) <= this.radius + 8; // 8 px margin for teeth\n    }\n    // Connect gear to another gear\n    connectTo(other) {\n      if (other === this) return;\n      if (this.connected.includes(other)) return;\n      this.connected.push(other);\n      other.connected.push(this);\n      this.updateAngularVelocities();\n    }\n    disconnectFrom(other) {\n      this.connected = this.connected.filter(g => g !== other);\n      other.connected = other.connected.filter(g => g !== this);\n      this.updateAngularVelocities();\n    }\n    updateAngularVelocities() {\n      // We want to set angular velocities so connected gears rotate accordingly,\n      // opposite direction and proportional speed inverse to radius.\n      const visited = new Set();\n      const queue = [];\n      // start from this gear with angularVelocity if 0, assign a default\n      let startGear = gears[0] || this;\n      // If none have angular velocity set, give one a default spin\n      if (gears.every(g => g.angularVelocity === 0)) startGear.angularVelocity = 0.015;\n      queue.push(startGear);\n      visited.add(startGear);\n\n      while(queue.length){\n        const g = queue.shift();\n        for (let other of g.connected){\n          if (visited.has(other)) continue;\n          // opposite direction\n          other.angularVelocity = -g.angularVelocity * (g.radius / other.radius);\n          visited.add(other);\n          queue.push(other);\n        }\n      }\n    }\n    // Remove this gear from all connections\n    removeConnections() {\n      for (let other of this.connected) {\n        other.connected = other.connected.filter(g => g !== this);\n      }\n      this.connected = [];\n    }\n    draw(ctx) {\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      ctx.rotate(this.angle);\n\n      // Draw base circle\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = this.selected ? '#4af' : '#ddd';\n      ctx.fillStyle = '#333';\n      ctx.beginPath();\n      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Draw teeth - simple line style side-view gear teeth\n      const teethCount = this.teeth;\n      const toothWidth = (2 * Math.PI * this.radius) / (teethCount * 3);\n      const toothHeight = this.radius * 0.15;\n\n      for(let i=0; i<teethCount; i++){\n        const angleTooth = (i / teethCount) * Math.PI * 2;\n        // Tooth base start\n        const baseAngleStart = angleTooth - toothWidth/this.radius;\n        const baseAngleEnd = angleTooth + toothWidth/this.radius;\n\n        // Draw tooth outline\n        ctx.beginPath();\n        // Tooth base arc on base circle radius\n        ctx.moveTo(Math.cos(baseAngleStart)*this.radius, Math.sin(baseAngleStart)*this.radius);\n        ctx.lineTo(Math.cos(baseAngleStart)*(this.radius + toothHeight*0.3), Math.sin(baseAngleStart)*(this.radius + toothHeight*0.3));\n        ctx.lineTo(Math.cos(angleTooth)*(this.radius + toothHeight), Math.sin(angleTooth)*(this.radius + toothHeight));\n        ctx.lineTo(Math.cos(baseAngleEnd)*(this.radius + toothHeight*0.3), Math.sin(baseAngleEnd)*(this.radius + toothHeight*0.3));\n        ctx.lineTo(Math.cos(baseAngleEnd)*this.radius, Math.sin(baseAngleEnd)*this.radius);\n        ctx.closePath();\n\n        ctx.fillStyle = '#555';\n        ctx.fill();\n        ctx.strokeStyle = '#aaa';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n\n        // Simple animation detail: vertical \"line\" moves back and forth on each tooth to simulate motion\n        // We'll draw a vertical line sliding along the tooth height\n        ctx.strokeStyle = '#88c';\n        ctx.lineWidth = 2;\n        const slide = (Math.sin(this.angle * 10 + i) + 1)/2; // 0 to 1 oscillation\n        const lineX = Math.cos(angleTooth)* (this.radius + slide * toothHeight);\n        const lineY = Math.sin(angleTooth)* (this.radius + slide * toothHeight);\n        const baseX = Math.cos(angleTooth)* (this.radius + toothHeight*0.3);\n        const baseY = Math.sin(angleTooth)* (this.radius + toothHeight*0.3);\n        ctx.beginPath();\n        ctx.moveTo(baseX, baseY);\n        ctx.lineTo(lineX, lineY);\n        ctx.stroke();\n      }\n\n      // Draw center hole\n      ctx.beginPath();\n      ctx.fillStyle = '#111';\n      ctx.arc(0, 0, this.radius * 0.3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = '#666';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      ctx.restore();\n    }\n  }\n\n  // Global state\n  let gears = [];\n  let selectedGear = null;\n  let connectFromGear = null;\n  let dragGear = null;\n\n  // Helpers\n  function findGearAt(x, y) {\n    for(let i = gears.length - 1; i >= 0; i--){\n      if(gears[i].isPointInside(x, y)){\n        return gears[i];\n      }\n    }\n    return null;\n  }\n\n  // Mouse & interaction events\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const gear = findGearAt(mx, my);\n    if(gear){\n      // Drag start\n      dragGear = gear;\n      dragGear.dragging = true;\n      dragGear.dragOffsetX = mx - gear.x;\n      dragGear.dragOffsetY = my - gear.y;\n\n      // Select gear and prepare for connection or removal\n      if(selectedGear === gear){\n        // deselect on second click\n        selectedGear = null;\n        connectFromGear = null;\n      } else {\n        if(connectFromGear && connectFromGear !== gear){\n          // Connect gears\n          // Check if gears are touching or will be touching - we allow 'connection' even separated for demo, but ideally just if close\n          const dx = connectFromGear.x - gear.x;\n          const dy = connectFromGear.y - gear.y;\n          const dist = Math.sqrt(dx*dx + dy*dy);\n          const idealDist = connectFromGear.radius + gear.radius;\n          if(Math.abs(dist - idealDist) < 30){\n            connectFromGear.connectTo(gear);\n            connectFromGear = null;\n            selectedGear = null;\n          } else {\n            // Too far to connect, just select new gear\n            selectedGear = gear;\n            connectFromGear = gear;\n          }\n        } else {\n          selectedGear = gear;\n          connectFromGear = gear;\n        }\n      }\n    } else {\n      // Place new gear\n      const newGear = new Gear(mx, my, 50, 12);\n      gears.push(newGear);\n      selectedGear = newGear;\n      connectFromGear = newGear;\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    if(dragGear){\n      dragGear.dragging = false;\n      dragGear = null;\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    if(dragGear && dragGear.dragging){\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      dragGear.x = mx - dragGear.dragOffsetX;\n      dragGear.y = my - dragGear.dragOffsetY;\n\n      // When moving gear, ensure connected gears stay connected by repositioning connected gears accordingly\n      // We will reposition connected gears so their edges touch perfectly to this gear.\n      // To keep it simple, only update immediate connections without recursion.\n      for(let other of dragGear.connected){\n        const dx = other.x - dragGear.x;\n        const dy = other.y - dragGear.y;\n        const dist = Math.sqrt(dx*dx + dy*dy);\n        const desiredDist = dragGear.radius + other.radius;\n        if(dist === 0) continue; // avoid zero division\n        const diff = desiredDist - dist;\n        // move connected gear along vector to maintain touching\n        other.x += (dx / dist) * diff;\n        other.y += (dy / dist) * diff;\n      }\n    }\n  });\n\n  // Resize gear by mouse wheel over gear\n  canvas.addEventListener('wheel', (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const gear = findGearAt(mx, my);\n    if(gear){\n      const delta = e.deltaY > 0 ? -2 : 2;\n      gear.radius = Math.min(Math.max(10, gear.radius + delta), 100);\n      // After resizing, update angular velocities as ratio changed\n      for(let g of gears) g.updateAngularVelocities();\n    }\n  }, { passive: false });\n\n  // Keyboard events for deletion\n  window.addEventListener('keydown', e => {\n    if(selectedGear && (e.key === 'Delete' || e.key === 'Backspace')){\n      // Remove connections\n      selectedGear.removeConnections();\n      // Remove gear\n      gears = gears.filter(g => g !== selectedGear);\n      selectedGear = null;\n      connectFromGear = null;\n    }\n  });\n\n  // Animation loop\n  function animate(){\n    ctx.clearRect(0, 0, W, H);\n\n    // Update angles\n    for(let gear of gears){\n      gear.angle += gear.angularVelocity;\n    }\n\n    // Draw connections (visible lines between gear centers)\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'rgba(70, 130, 180, 0.6)';\n    for(let gear of gears){\n      for(let other of gear.connected){\n        if(gear.x < other.x || (gear.x === other.x && gear.y < other.y)){\n          ctx.beginPath();\n          ctx.moveTo(gear.x, gear.y);\n          ctx.lineTo(other.x, other.y);\n          ctx.stroke();\n        }\n      }\n    }\n\n    // Draw gears\n    for(let gear of gears){\n      gear.draw(ctx);\n    }\n\n    requestAnimationFrame(animate);\n  }\n\n  animate();\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}