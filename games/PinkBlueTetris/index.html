<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Pixel Dive: Neon Coin Quest - Enhanced</title>
<style>
  :root {
    --bg: #05061a;
    --panel: rgba(14,14,30,0.95);
    --text: #e9f0ff;
    --accent: #66e0ff;
    --coin: #ffd24d;
    --enemy: #ff4d4d;
    --player: #7aff8a;
    --bullet: #ffffff;
    --shadow: rgba(0,0,0,0.6);
  }
  * { box-sizing: border-box; }
  html, body { height:100%; margin:0; background: #04061a; font-family: Inter, Arial, sans-serif; color: var(--text); overflow:hidden; }
  .wrap { display:flex; align-items:center; justify-content:center; height:100%; padding:20px; position:relative; }
  canvas { width: min(92vw, 980px); height: auto; image-rendering: pixelated; border:2px solid rgba(255,255,255,.15); background:#0a0a12; border-radius:12px; box-shadow:0 12px 40px rgba(0,0,0,.5); }
  #hud { position:absolute; top:12px; left:12px; font-family: "Segoe UI", Arial, sans-serif; font-size:14px; padding:6px 10px; border-radius:6px; background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.15); backdrop-filter: blur(2px); }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background: rgba(5,6,15,0.65); visibility:hidden; opacity:0; transition: opacity .2s; }
  #overlay.active { visibility:visible; opacity:1; }
  .panel { background: linear-gradient(135deg, rgba(18,18,40,0.95), rgba(8,8,28,0.95)); border:1px solid rgba(255,255,255,0.15); padding: 28px 34px; border-radius:12px; text-align:center; max-width: 90vw; }
  .panel h1 { margin:0 0 8px 0; font-size:28px; letter-spacing:.5px; }
  .panel p { margin:6px 0 16px 0; font-size:14px; color:#d9dcff; }
  .btn { padding:10px 16px; border-radius:6px; border:none; cursor:pointer; font-weight:600; background: linear-gradient(135deg, #5d9cff, #3a64ff); color:white; box-shadow: 0 4px 12px rgba(61,105,240,.6); }
  .btn.secondary { background: linear-gradient(135deg, #2a2a2a, #1a1a1a); color:#ddd; }
  .row { display:flex; gap:12px; justify-content:center; align-items:center; margin-top:8px; }
  .mrow { display:flex; gap:12px; justify-content:center; align-items:center; margin:8px 0 0 0; }
  .chip { padding:6px 10px; border-radius:999px; background: rgba(255,255,255,.08); font-size:12px; border:1px solid rgba(255,255,255,.15); }
  @media (max-width: 700px) {
    .panel { padding:22px 20px; }
    .panel h1 { font-size:22px; }
  }
</style>
</head>
<body>
  <div class="wrap" style="position:relative;">
    <canvas id="game" width="800" height="600" tabindex="0"></canvas>
    <div id="hud">Score: 0 | Coins: 0 | Time: 0s | Lives: 3</div>
    <!-- Overlay for menus and settings -->
    <div id="overlay" aria-label="GameOverlay">
      <div class="panel" id="panel">
        <!-- dynamic content injected -->
      </div>
    </div>
  </div>

<script>
(function(){
  // Canvas and rendering
  const BASE_W = 800;
  const BASE_H = 600;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const overlay = document.getElementById('overlay');
  const panel = document.getElementById('panel');

  // Input
  const keys = {};
  const mouse = { x: BASE_W/2, y: BASE_H/2, down:false };

  // Game state
  let state = 'menu'; // 'menu','playing','paused','won','lost'
  let score = 0;
  let coinsTotal = 12;
  let coinsLeft = coinsTotal;
  let gameTime = 0;
  let lastTime = 0;

  // Difficulty and options
  let difficulty = 'Normal'; // Easy, Normal, Hard
  const difficulties = { Easy: 0.75, Normal: 1.0, Hard: 1.3 };
  let autoFire = true;
  let showParticles = true;
  let screenShake = 0;
  let highScore = 0;

  // Entities
  const player = { x: BASE_W/2, y: BASE_H/2, r: 12, baseSpeed: 170, speed: 170, angle: 0, lives: 3, shield: 0, invincible: 0, dashCooldown: 0, dashTime: 0, color: '#7aff8a' };
  const bullets = [];
  const enemies = [];
  const coins = [];
  const powerups = [];
  const particles = [];

  // Controls
  const input = { firing: false, canFire: true };

  // Constants
  const INVINCIBLE_MS = 1500;
  const BULLET_SPEED = 520;
  const SHOT_COOLDOWN = 0.15;
  const DASH_COOLDOWN = 1.4;
  const DASH_MS = 0.18;
  const STAR_COUNT = 80;

  // Init
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function rand(a,b){ return Math.random()*(b-a) + a; }
  function randInt(a,b){ return Math.floor(rand(a,b+1)); }

  // Local storage
  function loadScores(){
    const s = localStorage.getItem('coin_dive_high');
    if(s) highScore = parseInt(s,10) || 0;
  }
  function saveScores(){
    if(score > highScore){
      highScore = score;
      localStorage.setItem('coin_dive_high', String(highScore));
    }
  }

  // Spawners
  function spawnCoin(random=false){
    // place coins evenly distributed but with random jitter
    const pad = 40;
    const x = rand(pad, BASE_W - pad);
    const y = rand(pad, BASE_H - pad);
    coins.push({ x, y, r: 5, worth: 1 });
  }

  function spawnEnemy(){
    // spawn on edges
    const side = randInt(0,3);
    let x=0, y=0;
    switch(side){
      case 0: x = rand(0, BASE_W); y = -20; break;
      case 1: x = BASE_W + 20; y = rand(0, BASE_H); break;
      case 2: x = rand(0, BASE_W); y = BASE_H + 20; break;
      case 3: x = -20; y = rand(0, BASE_H); break;
    }
    const speed = rand(60, 110) * difficulties[difficulty];
    const e = { x, y, r: randInt(12, 16), speed, vx: 0, vy: 0, hp: 1, maxHp: 1, alive: true, type: 'basic', color: '#ff4d4d', aggroRange: 180 };
    // small chance of stronger enemy
    if(Math.random() < 0.15){
      e.r = 20;
      e.hp = 2;
      e.maxHp = 2;
      e.speed *= 0.9;
      e.type = 'grunt';
    }
    enemies.push(e);
  }

  function spawnPowerUpAt(x,y){
    const types = ['shield','rapid','double','blast'];
    const t = types[randInt(0, types.length-1)];
    powerups.push({ x, y, type: t, ttl: rand(9000,15000), collected:false });
  }

  // Input handlers
  window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const scaleX = BASE_W / rect.width;
    const scaleY = BASE_H / rect.height;
    const px = (e.clientX - rect.left) * scaleX;
    const py = (e.clientY - rect.top) * scaleY;
    mouse.x = clamp(px, 0, BASE_W);
    mouse.y = clamp(py, 0, BASE_H);
  });

  canvas.addEventListener('mousedown', ()=>{ mouse.down = true; });
  window.addEventListener('mouseup', ()=>{ mouse.down = false; });

  // Overlay UI
  function openMenu(){
    state = 'menu';
    panel.innerHTML = `
      <h1>Pixel Dive: Neon Coin Quest</h1>
      <p>Collect glowing coins, survive waves of enemies, and power up with awesome upgrades.</p>
      <div class="row">
        <button class="btn" id="startBtn">Start Game</button>
        <button class="btn secondary" id="settingsBtn">Settings</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <span class="chip">Difficulty: ${difficulty}</span>
        <span class="chip">High Score: ${highScore}</span>
      </div>
    `;
    overlay.classList.add('active');
    document.getElementById('startBtn').onclick = ()=>{ startGame(); };
    document.getElementById('settingsBtn').onclick = ()=>{ showSettings(); };
  }

  function showSettings(){
    panel.innerHTML = `
      <h1>Settings</h1>
      <div class="mrow">
        <span class="chip">Difficulty</span>
        <select id="diff" style="padding:6px 10px;border-radius:6px;background:#111;color:white;border:1px solid #333;">
          <option=${difficulty==='Easy'?'selected':''}>Easy</option>
          <option=${difficulty==='Normal'?'selected':''}>Normal</option>
          <option=${difficulty==='Hard'?'selected':''}>Hard</option>
        </select>
      </div>
      <div class="mrow" style="margin-top:6px;">
        <span class="chip">Auto-fire</span>
        <input type="checkbox" id="autoFire" ${autoFire?'checked':''} />
        <span class="chip">Particles</span>
        <input type="checkbox" id="particles" ${showParticles?'checked':''} />
        <span class="chip">Screen Shake</span>
        <input type="checkbox" id="shake" ${screenShake>0?'checked':''} />
      </div>
      <div class="row" style="margin-top:12px;">
        <button class="btn" id="applyBtn">Apply</button>
        <button class="btn secondary" id="backBtn" style="margin-left:8px;">Back</button>
      </div>
    `;
    overlay.classList.add('active');
    document.getElementById('applyBtn').onclick = ()=>{
      const d = document.getElementById('diff').value;
      difficulty = d;
      autoFire = document.getElementById('autoFire').checked;
      showParticles = document.getElementById('particles').checked;
      screenShake = document.getElementById('shake').checked ? 1 : 0;
      // Persist some values
      localStorage.setItem('coin_dive_diff', difficulty);
    };
    document.getElementById('backBtn').onclick = ()=>{ openMenu(); };
  }

  function startGame(){
    resetGame(true);
    overlay.classList.remove('active');
    state = 'playing';
    gameTime = 0;
    score = 0;
    coinsLeft = coinsTotal;
    bullets.length = 0;
    enemies.length = 0;
    coins.length = 0;
    powerups.length = 0;
    particles.length = 0;
    // populate world
    for(let i=0;i<coinsTotal;i++) spawnCoin();
    for(let i=0;i<8;i++) spawnEnemy();
    score = 0;
    hud.textContent = `Score: ${score} | Coins: ${coinsLeft} | Time: 0s | Lives: ${player.lives}`;
    // start loop
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Mechanics
  function collide(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    const r = a.r + b.r;
    return dx*dx + dy*dy <= r*r;
  }

  function spawnExplosion(x,y, color='#ffaa33', size=4, count=12, speed=80){
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = rand(20, speed);
      particles.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: rand(0.4,0.9), color, size: rand(1, size) });
    }
  }

  function dropPowerUp(x,y){
    if(Math.random() < 0.65) spawnPowerUpAt(x,y);
  }

  // Game loop
  function update(dt){
    if(state !== 'playing') return;

    gameTime += dt;
    // Movement
    let vx = 0, vy = 0;
    const s = player.speed;
    if(keys['w'] || keys['arrowup']) vy -= 1;
    if(keys['s'] || keys['arrowdown']) vy += 1;
    if(keys['a'] || keys['arrowleft']) vx -= 1;
    if(keys['d'] || keys['arrowright']) vx += 1;

    // dash
    if(keys[' ']) { // space to dash
      if(player.dashCooldown <= 0){
        player.dashCooldown = DASH_COOLDOWN;
        player.dashTime = DASH_MS;
        // boost: teleport a bit forward
        const ax = Math.cos(player.angle), ay = Math.sin(player.angle);
        player.x += ax * 60;
        player.y += ay * 60;
        player.x = clamp(player.x, player.r, BASE_W - player.r);
        player.y = clamp(player.y, player.r, BASE_H - player.r);
      }
    }

    if(player.dashTime > 0){
      player.dashTime -= dt;
      player.speed = s * 1.6;
    } else {
      player.speed = s;
    }
    if(player.dashCooldown > 0) player.dashCooldown -= dt;

    if(vx !== 0 || vy !== 0){
      const len = Math.hypot(vx, vy);
      vx /= len; vy /= len;
      player.x += vx * player.speed * dt;
      player.y += vy * player.speed * dt;
      player.x = clamp(player.x, player.r, BASE_W - player.r);
      player.y = clamp(player.y, player.r, BASE_H - player.r);
    }

    // aim
    player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

    // shooting
    if((mouse.down || autoFire) && player.invincible <= 0){
      if(state === 'playing' && bullets.length < 200){
        if(Date.now() - (bullets._lastShot || 0) > SHOT_COOLDOWN * 1000){
          bullets._lastShot = Date.now();
          const spread = (powerups.find(p => p.type==='double') ? 2 : 1);
          for(let i=0;i<spread;i++){
            const angle = player.angle;
            const off = (spread===2 ? (i===0?-0.08:0.08) : 0);
            const dx = Math.cos(angle + off) * BULLET_SPEED;
            const dy = Math.sin(angle + off) * BULLET_SPEED;
            bullets.push({ x: player.x + Math.cos(angle)* (player.r+2),
                           y: player.y + Math.sin(angle)*(player.r+2),
                           vx: dx, vy: dy, r: 2, life: 1.6, color: '#fff' });
          }
        }
      }
    }

    // Update bullets
    for(let i = bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if(b.life <= 0 || b.x < -10 || b.x > BASE_W+10 || b.y < -10 || b.y > BASE_H+10){
        bullets.splice(i,1);
      }
    }

    // Enemies
    for(let i=0; i<enemies.length; i++){
      const e = enemies[i];
      if(!e.alive) continue;
      // chase player
      const dx = player.x - e.x, dy = player.y - e.y;
      const dist = Math.hypot(dx, dy);
      const approach = Math.min(dist, e.speed * dt);
      if(dist > 0){
        e.vx = (dx/dist) * e.speed;
        e.vy = (dy/dist) * e.speed;
      } else {
        e.vx = e.vy = 0;
      }
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      // bounds
      e.x = clamp(e.x, e.r, BASE_W - e.r);
      e.y = clamp(e.y, e.r, BASE_H - e.r);

      // collision with player
      const hitPlayer = collide({x: player.x, y: player.y, r: player.r}, {x: e.x, y: e.y, r: e.r});
      if(hitPlayer){
        if(player.invincible <= 0 && player.shield <= 0){
          player.lives -= 1;
          player.invincible = INVINCIBLE_MS;
          // knockback
          const ang = Math.atan2(player.y - e.y, player.x - e.x);
          player.x += Math.cos(ang)*24;
          player.y += Math.sin(ang)*24;
          player.x = clamp(player.x, player.r, BASE_W - player.r);
          player.y = clamp(player.y, player.r, BASE_H - player.r);
          // shake
          screenShake = 12;
          if(player.lives <= 0){
            state = 'lost';
            saveScores();
            openMenu();
            panel.innerHTML = `<h1>Game Over</h1><p>Your score: ${score}</p><div class="row"><button class="btn" id="playAgain">Play Again</button><button class="btn secondary" id="menuBtn" style="margin-left:8px;">Main Menu</button></div>`;
            overlay.classList.add('active');
            document.getElementById('playAgain').onclick = ()=>{ startGame(); };
            document.getElementById('menuBtn').onclick = ()=>{ openMenu(); };
            return;
          }
        } else {
          // shield reduces damage
          if(player.shield > 0){
            player.shield -= 1;
            // small knockback
            const ang = Math.atan2(player.y - e.y, player.x - e.x);
            player.x += Math.cos(ang)*18;
            player.y += Math.sin(ang)*18;
          }
        }
      }

      // enemy HP
      if(dist < e.r + player.r){
        // nothing
      }
    }

    // Bullets vs Enemies
    for(let i = bullets.length-1; i>=0; i--){
      const b = bullets[i];
      for(let j = enemies.length-1; j>=0; j--){
        const e = enemies[j];
        if(!e.alive) continue;
        if(collide(b, e)){
          e.hp -= 1;
          bullets.splice(i,1);
          spawnExplosion(e.x, e.y, '#ffd6a6', 3, 8, 120);
          if(e.hp <= 0){
            e.alive = false;
            // rewards
            score += 5;
            spawnExplosion(e.x, e.y, '#ffb86c', 5, 14, 180);
            // drop coin sometimes
            if(Math.random() < 0.7){
              spawnPowerUpAt(e.x, e.y);
            }
            if(Math.random() < 0.6){
              // extra coin
              spawnCoin(true);
            }
          }
          break;
        }
      }
    }

    // Coins
    for(let i = coins.length-1; i>=0; i--){
      const c = coins[i];
      const dx = player.x - c.x, dy = player.y - c.y;
      if(dx*dx + dy*dy <= (player.r + c.r)*(player.r + c.r)){
        coins.splice(i,1);
        score += 2;
        coinsLeft--;
        spawnExplosion(player.x, player.y, '#ffe29a', 2, 8, 100);
        // spawn powerups occasionally
        if(Math.random() < 0.25){
          spawnPowerUpAt(player.x, player.y);
        }
        if(coinsLeft <= 0){
          // win
          state = 'won';
          saveScores();
          overlay.classList.add('active');
          panel.innerHTML = `<h1>You Win!</h1><p>Final score: ${score} • Time: ${Math.floor(gameTime)}s</p><div class="row"><button class="btn" id="playAgain">Play Again</button><button class="btn secondary" id="menuBtn" style="margin-left:8px;">Main Menu</button></div>`;
          document.getElementById('playAgain').onclick = ()=>{ startGame(); };
          document.getElementById('menuBtn').onclick = ()=>{ openMenu(); };
          return;
        }
      }
    }

    // Powerups
    for(let i = powerups.length-1; i>=0; i--){
      const p = powerups[i];
      // float slightly
      p.y += Math.sin((gameTime*4) + i)*0.5;
      // collision
      const dx = player.x - p.x, dy = player.y - p.y;
      if(dx*dx + dy*dy <= (player.r + 6)*(player.r + 6)){
        // apply effect
        if(p.type === 'shield'){
          player.shield = 1;
        } else if(p.type === 'rapid'){
          autoFire = true;
        } else if(p.type === 'double'){
          // handled by shots expansion
        } else if(p.type === 'blast'){
          // not implemented: screen-wide shock? we'll spawn burst
          for(let k=0;k<22;k++){
            const a = Math.random()*Math.PI*2;
            bullets.push({ x: player.x, y: player.y, vx: Math.cos(a)*420, vy: Math.sin(a)*420, r: 2, life: 0.6, color:'#fff' });
          }
        }
        powerups.splice(i,1);
        spawnExplosion(p.x, p.y, '#8df5ff', 4, 12, 120);
      }
    }

    // Powerup TTL
    for(let i = powerups.length-1; i>=0; i--){
      const p = powerups[i];
      p.ttl -= dt*1000;
      if(p.ttl <= 0){
        powerups.splice(i,1);
      }
    }

    // Particles
    if(showParticles){
      for(let i = particles.length-1; i>=0; i--){
        const pt = particles[i];
        pt.x += pt.vx * dt;
        pt.y += pt.vy * dt;
        pt.life -= dt;
        if(pt.life <= 0){
          particles.splice(i,1);
        }
      }
    }

    // Screen shake
    if(screenShake > 0){
      screenShake -= dt * 60;
      if(screenShake < 0) screenShake = 0;
    }

    // Player invincible timer
    if(player.invincible > 0){
      player.invincible -= dt*1000;
      if(player.invincible < 0) player.invincible = 0;
    }

    // HUD
    hud.textContent = `Score: ${score} | Coins: ${coinsLeft} | Time: ${Math.floor(gameTime)}s | Lives: ${player.lives} ${player.shield>0?'• Shield':''}`;
  }

  function render(){
    // Screen shake transform
    const shakeX = screenShake * (Math.random()*2-1);
    const shakeY = screenShake * (Math.random()*2-1);

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Background gradient and stars
    const g = ctx.createLinearGradient(0,0,0,BASE_H);
    g.addColorStop(0, '#0a0b1f');
    g.addColorStop(1, '#05061a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,BASE_W,BASE_H);

    // parallax stars
    for(let i=0;i<STAR_COUNT;i++){
      const t = i*93.3 + gameTime*0.4;
      const sx = ((Math.sin(t) * 0.5 + 0.5) * BASE_W) % BASE_W;
      const sy = ((Math.cos(t*1.3) * 0.5 + 0.5) * BASE_H) % BASE_H;
      ctx.fillStyle = 'rgba(150,180,255,0.08)';
      ctx.fillRect((sx+BASE_W)%BASE_W, (sy+BASE_H)%BASE_H, 2,2);
    }

    // coins
    for(const c of coins){
      ctx.fillStyle = '#ffd24d';
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#9a6a00';
      ctx.stroke();
    }

    // powerups
    for(const p of powerups){
      ctx.fillStyle = '#66d9ff';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(p.x-6, p.y-6, 12,12);
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px monospace';
      ctx.fillText(p.type.charAt(0).toUpperCase(), p.x-3, p.y+3);
    }

    // enemies
    for(const e of enemies){
      if(!e.alive) continue;
      ctx.fillStyle = e.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();
      // simple shading
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(e.x - e.r, e.y - e.r, e.r, 4);
    }

    // bullets
    ctx.fillStyle = '#fff';
    for(const b of bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      // trail
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx*0.02, b.y - b.vy*0.02);
      ctx.stroke();
    }

    // player
    // glow when invincible
    if(player.invincible > 0){
      const t = (player.invincible % 0.5) * 2;
      ctx.shadowColor = 'rgba(120,210,255,0.8)';
      ctx.shadowBlur = 14;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }
    ctx.fillStyle = player.shield>0 ? '#6af1ff' : '#7aff8a';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();

    // direction indicator
    ctx.strokeStyle = '#66e0ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(player.x + Math.cos(player.angle)*18, player.y + Math.sin(player.angle)*18);
    ctx.stroke();

    // if shield active, aura
    if(player.shield>0){
      ctx.strokeStyle = 'rgba(0,180,255,0.6)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r + 6, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();

    // overlay damage flash
    if(state === 'paused'){
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(0,0,BASE_W,BASE_H);
    }
  }

  // Main loop
  function loop(t){
    const now = t || performance.now();
    const dt = Math.min(0.033, (now - (lastTime||now))/1000);
    lastTime = now;

    update(dt);
    render();

    // if playing, continue
    if(state === 'playing'){ requestAnimationFrame(loop); }
  }

  // Start
  function resetGame(full=false){
    score = 0;
    gameTime = 0;
    coins.length = 0;
    enemies.length = 0;
    bullets.length = 0;
    powerups.length = 0;
    particles.length = 0;
    player.x = BASE_W/2;
    player.y = BASE_H/2;
    player.lives = 3;
    player.shield = 0;
    player.invincible = 0;
    player.dashCooldown = 0;
    player.speed = player.baseSpeed;
    coinsLeft = coinsTotal;
    // prepopulate coins
    for(let i=0;i<coinsTotal;i++) spawnCoin();
    // enemies
    for(let i=0;i<8;i++) spawnEnemy();
    // show menu if not full start
  }

  // UI boot
  loadScores();
  // determine if previously saved diff
  const savedDiff = localStorage.getItem('coin_dive_diff');
  if(savedDiff && difficulties[savedDiff]) difficulty = savedDiff;
  // init menu
  openMenu();

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      if(state === 'playing'){
        state = 'paused';
        panel.innerHTML = `<h1>Paused</h1><p>Press Resume to continue or Menu to quit.</p><div class="row"><button class="btn" id="resumeBtn">Resume</button><button class="btn secondary" id="menuBtn" style="margin-left:8px;">Main Menu</button></div>`;
        overlay.classList.add('active');
        document.getElementById('resumeBtn').onclick = ()=>{ overlay.classList.remove('active'); state = 'playing'; lastTime = performance.now(); requestAnimationFrame(loop); };
        document.getElementById('menuBtn').onclick = ()=>{ openMenu(); };
      } else if(state === 'menu' || state === 'lost' || state === 'won'){
        // do nothing
      }
    }
  });

  // Resize handling (keep crisp in DPR)
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = BASE_W * dpr;
    canvas.height = BASE_H * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Start by showing menu
  // already open by openMenu()

  // Minor: auto start after first interaction to avoid blocking
  let started = false;
  function ensureStart(){
    if(!started){
      started = true;
      // nothing yet
    }
  }
  canvas.addEventListener('click', () => {
    if(state === 'menu'){
      startGame();
    }
  }, {once:true});

  // Start game helper
  function startGame(){
    resetGame(true);
    state = 'playing';
    overlay.classList.remove('active');
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Initial
  // Build initial overlay with menu
  // (openMenu already called)
})();
</script>
</body>
</html>