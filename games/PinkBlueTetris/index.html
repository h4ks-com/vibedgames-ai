<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PinkBlueTetris Deluxe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0e0e12;
      --panel: #14161d;
      --panel2: #1e2230;
      --text: #e9e9f1;
      --muted: #a2a2a8;
      --accent: #7c5cff;
      --glow: 0 0 14px rgba(124,92,255,.9);
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 20% -10%, #2a1f3d 0%, transparent 40%),
                  radial-gradient(circle at 85% 10%, #0e3456 0%, transparent 40%),
                  linear-gradient(#111, #000);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto;
      color: var(--text);
      overflow: hidden;
    }
    @keyframes drift {
      0% { background-position: 0 0, 0 0; }
      100% { background-position: -200px 120px, 120px -60px; }
    }
    .wrapper {
      display: grid;
      grid-template-columns: 1fr 320px;
      grid-gap: 16px;
      height: 100%;
      padding: 16px;
      box-sizing: border-box;
    }
    .gameArea {
      position: relative;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 12px;
      background: linear-gradient(#0a0a0f, #0b0b11);
      border-radius: 12px;
      border: 1px solid #333;
      overflow: hidden;
      /* ambient parallax glow using CSS animation */
      animation: drift 22s linear infinite;
      background-attachment: fixed;
    }
    canvas {
      image-rendering: pixelated;
      background: #000;
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,.6);
    }
    .hud {
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #333;
      height: max-content;
      align-self: start;
      position: sticky;
      top: 16px;
      color: #fff;
      min-height: 120px;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px 0;
      letter-spacing: .5px;
      text-transform: uppercase;
      color: #ffd3e8;
      text-shadow: 0 2px 6px rgba(255,0,128,.25);
    }
    .stat {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .stat:last-child { border-bottom: none; }
    .label { color: var(--muted); font-size: 13px; }
    .value { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas; font-weight: bold; font-size: 14px; }
    .controls {
      display: grid; gap: 8px; margin-top: 12px;
      grid-template-columns: 1fr 1fr 1fr;
    }
    button, .toggle {
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #333;
      background: #1a1d28;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      text-align: center;
      transition: transform .04s ease;
    }
    button:active { transform: translateY(1px); }
    .toggle {
      display: inline-flex; align-items: center; justify-content: center;
      gap: 8px; user-select: none;
    }
    .legend {
      font-size: 12px; color: #cbd5e1;
      margin-top: 6px;
    }

    .panels {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 6px;
    }
    .miniPanel {
      padding: 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.08);
      background: rgba(20,20,28,.6);
    }
    .miniTitle { font-size: 12px; color: #cbd5e1; margin-bottom: 6px; text-align: center; }
    #nextCanvas, #holdCanvas { width: 100%; height: auto; display: block; margin: 0 auto; background: #000; border-radius: 6px; }
    .hint { margin-top: 6px; color: #c6ffd4; font-size: 12px; display: none; }

    @media (max-width: 1000px) {
      .wrapper { grid-template-columns: 1fr; height: auto; }
      .hud { position: static; margin-top: 8px; }
      .panels { grid-template-columns: 1fr; }
      #gameCanvas { width: 100%; height: auto; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="gameArea" id="playArea">
      <canvas id="gameCanvas" width="320" height="640" aria-label="PinkBlueTetris game canvas"></canvas>
    </div>
    <aside class="hud" aria-label="Game HUD">
      <h1>PinkBlueTetris Deluxe</h1>
      <div class="stat" title="Score">
        <span class="label">Score</span>
        <span class="value" id="scoreVal">0</span>
      </div>
      <div class="stat" title="Level">
        <span class="label">Level</span>
        <span class="value" id="levelVal">0</span>
      </div>
      <div class="stat" title="Lines Cleared">
        <span class="label">Lines</span>
        <span class="value" id="linesVal">0</span>
      </div>

      <div class="controls" aria-label="Game controls">
        <button id="startBtn" title="Start game">Start</button>
        <button id="pauseBtn" title="Pause game">Pause</button>
        <button id="holdBtn" title="Hold current piece (swap with hold)">Hold</button>
      </div>

      <div class="panels" aria-label="Next and Hold previews">
        <div class="miniPanel">
          <div class="miniTitle">Next</div>
          <canvas id="nextCanvas" width="96" height="96"></canvas>
        </div>
        <div class="miniPanel">
          <div class="miniTitle">Hold</div>
          <canvas id="holdCanvas" width="96" height="96"></canvas>
        </div>
      </div>

      <div class="hint" id="hintLegend" aria-live="polite">
        Ghost piece shows where the current piece would land.
      </div>

      <div class="toggle" id="hintToggle" role="checkbox" aria-checked="false" tabindex="0" title="Toggle hints (ghost piece)">
        Hints
      </div>
      <div class="toggle" id="cbToggle" role="checkbox" aria-checked="false" tabindex="0" title="Color-blind friendly palette">
        Color Blind
      </div>
    </aside>
  </div>

<script>
(function(){
  // Canvas and rendering setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  // Grid
  const COLS = 10;
  const ROWS = 20;
  const CELL = 32; // base cell size
  // Adjust canvas size
  canvas.width = COLS * CELL;
  canvas.height = ROWS * CELL;

  // Tetromino shapes (rotatable)
  // Each shape: defined as points, rotated about origin, then normalized
  const SHAPES = {
    I: [ [0,1], [1,1], [2,1], [3,1] ],
    O: [ [0,0], [1,0], [0,1], [1,1] ],
    T: [ [1,0], [0,1], [1,1], [2,1] ],
    S: [ [1,1], [2,1], [0,2], [1,2] ],
    Z: [ [0,1], [1,1], [1,2], [2,2] ],
    J: [ [0,0], [0,1], [1,1], [2,1] ],
    L: [ [2,0], [0,1], [1,1], [2,1] ]
  };
  const TYPE_ORDER = ['I','O','T','S','Z','J','L'];

  // Color palettes (default and color-blind friendly)
  const COLOR_SETS = [
    { // default pink/blue high-contrast
      name: 'default',
      colors: { I:'#4fc3f7', O:'#f06292', T:'#64b5f6', S:'#66e0a8', Z:'#66e0f6', J:'#f06292', L:'#4fc3f7' }
    },
    { // color-blind friendly palette
      name: 'cb',
      colors: { I:'#1e88e5', O:'#ffd54f', T:'#42a5f5', S:'#ff8f00', Z:'#00acc1', J:'#8e24aa', L:'#3949ab' }
    }
  ];
  let paletteIndex = 0;
  let COLORS = COLOR_SETS[paletteIndex].colors;

  // Game state
  const grid = Array.from({length: ROWS}, () => Array(COLS).fill(0)); // 0 empty, else color index (1..)
  let score = 0;
  let lines = 0;
  let level = 0;
  let playing = false;
  let gameOver = false;
  let showHints = true;

  // Hold and next
  let nextType = randType();
  let holdType = null;

  // Current piece
  let current = null; // { type, rot, x, y }

  // Timing
  let dropCounter = 0;
  let lastTime = 0;
  let dropInterval = 800; // ms

  // Particles for line clear
  let particles = [];

  // Audio
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
  }
  function playTone(freq, dur = 0.15, type = 'sine', vol = 0.15) {
    ensureAudio();
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = vol;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + dur);
  }
  function playLineClearSound(linesCleared) {
    ensureAudio();
    // simple tri-tone progression
    const base = 220;
    for (let i = 0; i < linesCleared; i++) {
      const freq = base * (1.2 + i * 0.2);
      setTimeout(() => playTone(freq, 0.08, 'triangle', 0.2), i * 60);
    }
  }

  // Helpers
  function randType() {
    return TYPE_ORDER[Math.floor(Math.random() * TYPE_ORDER.length)];
  }
  function colorFor(type) {
    return COLORS[type];
  }

  // Get blocks for a piece rotated rot times
  function getBlocks(type, rot) {
    let pts = SHAPES[type].map(p => [p[0], p[1]]);
    for (let i = 0; i < rot; i++) {
      pts = pts.map(([x,y]) => [-y, x]);
    }
    // normalize to min >= 0
    const minX = Math.min(...pts.map(p => p[0]));
    const minY = Math.min(...pts.map(p => p[1]));
    pts = pts.map(([x,y]) => [x - minX, y - minY]);
    return pts;
  }

  // collision test
  function isCollision(posX, posY, blocks) {
    for (let [dx, dy] of blocks) {
      const x = posX + dx;
      const y = posY + dy;
      if (x < 0 || x >= COLS) return true;
      if (y >= ROWS) return true;
      if (y >= 0 && grid[y][x] !== 0) return true;
    }
    return false;
  }

  // place piece
  function placePiece(posX, posY, blocks, colorKey) {
    for (let [dx, dy] of blocks) {
      const x = posX + dx;
      const y = posY + dy;
      if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
        grid[y][x] = colorKey;
      }
    }
  }

  // commit current piece and spawn next
  function spawnPiece() {
    current = { type: nextType, rot: 0, x: Math.floor(COLS / 2) - 2, y: -2 };
    nextType = randType();
    updateNextCanvas();
    // check collision on spawn
    const blocks = getBlocks(current.type, current.rot);
    if (isCollision(current.x, current.y, blocks)) {
      gameOver = true;
      playing = false;
    }
  }

  // clear full lines
  function clearLines() {
    let linesCleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (grid[y][x] === 0) continue outer;
      }
      grid.splice(y, 1);
      grid.unshift(Array(COLS).fill(0));
      linesCleared++;
      y++;
    }
    if (linesCleared > 0) {
      const pts = [0, 40, 100, 300, 1200];
      score += pts[linesCleared] * (level + 1);
      lines += linesCleared;
      updateLevel();
      // particles
      spawnLineParticles(linesCleared);
      playLineClearSound(linesCleared);
    }
  }

  // line clear particles
  function spawnLineParticles(linesCleared) {
    // create particles across cleared lines
    const colorKeys = [];
    // derive type from grid's line before deletion? We'll approximate by random colors from line
    const colors = Object.values(COLORS);
    const count = Math.max(8, linesCleared * COLS * 2);
    for (let i = 0; i < count; i++) {
      const x = Math.floor(Math.random() * COLS) + 0.5;
      const y = Math.floor(Math.random() * ROWS) + 0.5;
      const vel = (Math.random() * 2 - 1) * 0.05;
      const vx = vel;
      const vy = -Math.random() * 0.15 - 0.05;
      const color = colors[Math.floor(Math.random() * colors.length)];
      particles.push({ x, y, vx, vy, life: 1.0, maxLife: 1.0, color });
    }
  }

  // update level/speed
  function updateLevel() {
    const newLevel = Math.floor(lines / 10);
    if (newLevel !== level) {
      level = newLevel;
      dropInterval = Math.max(100, 800 - level * 60);
    }
  }

  // update / render
  function drawBlock(x, y, color, alpha=1) {
    const px = x * CELL;
    const py = y * CELL;
    // gradient-esque fill
    const g = ctx.createLinearGradient(px, py, px, py + CELL);
    g.addColorStop(0, color);
    // brighten a bit
    g.addColorStop(1, lightenColor(color, 0.75));
    ctx.fillStyle = g;
    ctx.globalAlpha = alpha;
    ctx.fillRect(px + 2, py + 2, CELL - 4, CELL - 4);
    ctx.globalAlpha = 1;
    // border glow
    ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 0.5, py + 0.5, CELL - 1, CELL - 1);
  }

  function lightenColor(hex, factor) {
    const r = parseInt(hex.substring(1,3),16);
    const g = parseInt(hex.substring(3,5),16);
    const b = parseInt(hex.substring(5,7),16);
    const nr = Math.min(255, Math.floor(r + (255 - r) * (1 - factor)));
    const ng = Math.min(255, Math.floor(g + (255 - g) * (1 - factor)));
    const nb = Math.min(255, Math.floor(b + (255 - b) * (1 - factor)));
    return `rgb(${nr},${ng},${nb})`;
  }

  function drawGhost(blocks, gx, gy, color) {
    for (let [dx, dy] of blocks) {
      const x = gx + dx;
      const y = gy + dy;
      if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
        ctx.fillStyle = hexToRgba(color, 0.25);
        ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
      }
    }
  }

  function hexToRgba(hex, a) {
    const r = parseInt(hex.substring(1,3),16);
    const g = parseInt(hex.substring(3,5),16);
    const b = parseInt(hex.substring(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // frame rendering
  function render(now = 0) {
    const dt = Math.max(0, now - lastTime);
    lastTime = now;

    if (playing && !gameOver) {
      dropCounter += dt;
      if (dropCounter > dropInterval) {
        dropCounter = 0;
        softDrop();
      }
    }

    // background wash
    ctx.clearRect(0,0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0, canvas.width, canvas.height);

    // draw settled blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const v = grid[y][x];
        if (v !== 0) {
          const type = TYPE_ORDER[v-1];
          drawBlock(x, y, colorFor(type));
        }
      }
    }

    // draw current piece
    if (current) {
      const blocks = getBlocks(current.type, current.rot);
      const color = colorFor(current.type);
      for (let [dx, dy] of blocks) {
        const x = current.x + dx;
        const y = current.y + dy;
        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
          drawBlock(x, y, color);
        }
      }
      // ghost
      if (showHints) {
        const blocksGhost = getBlocks(current.type, current.rot);
        let gy = current.y;
        while (!isCollision(current.x, gy + 1, blocksGhost)) gy++;
        drawGhost(blocksGhost, current.x, gy, color);
      }
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * (dt / 16);
      p.y += p.vy * (dt / 16);
      p.vy += 0.005; // gravity
      p.life -= dt / 1000;
      if (p.life <= 0) particles.splice(i,1);
      else {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillRect(p.x * CELL, p.y * CELL, 2, 2);
        ctx.globalAlpha = 1;
      }
    }

    // game over overlay
    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 10);
      ctx.fillText('Press Restart', canvas.width/2, canvas.height/2 + 20);
    }

    requestAnimationFrame(render);
  }

  // movement / rotation
  function move(dir) {
    if (!current || gameOver) return;
    const nx = current.x + dir;
    if (!isCollision(nx, current.y, getBlocks(current.type, current.rot))) {
      current.x = nx;
    }
  }
  function rotatePiece() {
    if (!current || gameOver) return;
    const newRot = (current.rot + 1) % 4;
    const blocks = getBlocks(current.type, newRot);
    const kicks = [
      [0,0], [-1,0], [1,0], [0,-1], [0,1],
      [-2,0], [2,0], [-1,-1], [1,-1], [-1,1], [1,1]
    ];
    for (let [kx, ky] of kicks) {
      const fx = current.x + kx;
      const fy = current.y + ky;
      if (!isCollision(fx, fy, blocks)) {
        current.x = fx;
        current.y = fy;
        current.rot = newRot;
        return;
      }
    }
  }

  // hard/soft drop
  function softDrop() {
    if (!current || gameOver) return;
    const blocks = getBlocks(current.type, current.rot);
    if (!isCollision(current.x, current.y + 1, blocks)) {
      current.y += 1;
    } else {
      // lock
      const colorKey = TYPE_ORDER.indexOf(current.type) + 1;
      placePiece(current.x, current.y, blocks, colorKey);
      clearLines();
      spawnPiece();
    }
  }
  function hardDrop() {
    if (!current || gameOver) return;
    const blocks = getBlocks(current.type, current.rot);
    while (!isCollision(current.x, current.y + 1, blocks)) current.y += 1;
    const colorKey = TYPE_ORDER.indexOf(current.type) + 1;
    placePiece(current.x, current.y, blocks, colorKey);
    clearLines();
    spawnPiece();
  }

  // manipulation: hold
  function holdPiece() {
    if (!current || gameOver) return;
    if (holdType === null) {
      holdType = current.type;
      // spawn next piece
      current = null;
      spawnPiece();
    } else {
      // swap
      const tmp = current.type;
      current.type = holdType;
      holdType = tmp;
      current.rot = 0;
      // new spawn pos
      current.x = Math.floor(COLS / 2) - 2;
      current.y = -2;
      // collision check
      if (isCollision(current.x, current.y, getBlocks(current.type, current.rot))) {
        gameOver = true;
        playing = false;
      }
    }
    updateHoldCanvas();
  }

  // palette / hint toggles
  function applyPalette(index) {
    paletteIndex = index % COLOR_SETS.length;
    COLORS = COLOR_SETS[paletteIndex].colors;
    updateNextCanvas(); updateHoldCanvas();
  }

  // mini canvases
  function drawMini(ctx2, type, colorMap) {
    // clear
    ctx2.clearRect(0,0, ctx2.canvas.width, ctx2.canvas.height);
    // block scaling
    const w = ctx2.canvas.width;
    const h = ctx2.canvas.height;
    const tile = Math.min(Math.floor(w/4), Math.floor(h/4));
    const offsetX = Math.floor((w - 4*tile)/2);
    const offsetY = Math.floor((h - 4*tile)/2);
    const blocks = SHAPES[type].map(p => [p[0], p[1]]);
    // normalize
    const minX = Math.min(...blocks.map(b => b[0]));
    const minY = Math.min(...blocks.map(b => b[1]));
    const norm = blocks.map(([x,y]) => [x - minX, y - minY]);
    // color
    const color = colorMap[type] || '#fff';
    for (let [dx, dy] of norm) {
      const x = offsetX + dx * tile;
      const y = offsetY + dy * tile;
      ctx2.fillStyle = color;
      ctx2.globalAlpha = 1;
      ctx2.fillRect(x+2, y+2, tile-4, tile-4);
      ctx2.strokeStyle = 'rgba(255,255,255,.25)';
      ctx2.lineWidth = 1;
      ctx2.strokeRect(x+2, y+2, tile-4, tile-4);
    }
  }

  function updateNextCanvas() {
    const c = document.getElementById('nextCanvas');
    const ctx2 = c.getContext('2d');
    drawMini(ctx2, nextType, COLORS);
  }

  function updateHoldCanvas() {
    const c = document.getElementById('holdCanvas');
    const ctx2 = c.getContext('2d');
    // draw empty if none
    ctx2.clearRect(0,0, c.width, c.height);
    if (!holdType) {
      // show muted placeholder
      ctx2.fillStyle = '#111';
      ctx2.fillRect(0,0,c.width,c.height);
      return;
    }
    drawMini(ctx2, holdType, COLORS);
  }

  // Keyboard/mouse controls
  let pressedHold = false;
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.code === 'ArrowLeft') { move(-1); e.preventDefault(); }
    if (e.code === 'ArrowRight') { move(1); e.preventDefault(); }
    if (e.code === 'ArrowUp') { rotatePiece(); e.preventDefault(); }
    if (e.code === 'ArrowDown') { softDrop(); e.preventDefault(); }
    if (e.code === 'Space') { hardDrop(); e.preventDefault(); }
    if (e.code === 'KeyC') { holdPiece(); e.preventDefault(); }
    if (e.code === 'KeyP') { togglePause(); e.preventDefault(); }
  });

  // mouse/touch controls can be added as needed (left/right swipe to move)
  // Button events
  document.getElementById('startBtn').addEventListener('click', () => {
    if (gameOver) resetGame();
    if (!playing) {
      playing = true;
      gameOver = false;
      lastTime = performance.now();
      requestAnimationFrame(render);
    }
  });
  document.getElementById('pauseBtn').addEventListener('click', () => togglePause());
  document.getElementById('holdBtn').addEventListener('click', holdPiece);

  // toggle hints and palette
  const hintToggle = document.getElementById('hintToggle');
  const cbToggle = document.getElementById('cbToggle');
  const hintLegend = document.getElementById('hintLegend');
  hintToggle.addEventListener('click', () => {
    showHints = !showHints;
    hintToggle.style.background = showHints ? '#2b2' : '#1a1d28';
    hintLegend.style.display = showHints ? 'block' : 'none';
  });
  cbToggle.addEventListener('click', () => {
    paletteIndex = (paletteIndex + 1) % COLOR_SETS.length;
    applyPalette(paletteIndex);
  });

  // game lifecycle helpers
  function togglePause() {
    if (gameOver) return;
    playing = !playing;
  }

  // reset game
  function resetGame() {
    for (let y = 0; y < ROWS; y++) grid[y].fill(0);
    score = 0; lines = 0; level = 0;
    dropInterval = 800;
    current = null; holdType = null;
    nextType = randType();
    gameOver = false;
    playing = false;
    particles = [];
    updateNextCanvas();
    updateHoldCanvas();
    // spawn initial
    spawnPiece();
  }

  // initial setup
  function setup() {
    applyPalette(paletteIndex);
    // initial next and hold canvases
    updateNextCanvas();
    updateHoldCanvas();
    // initial hold/next display
    spawnPiece();
    requestAnimationFrame(render);
  }

  // initialize
  setup();

  // Expose minimal API
  window.PinkBlueTetris = {
    start: () => {
      if (!playing && !gameOver) {
        playing = true;
        lastTime = performance.now();
        requestAnimationFrame(render);
      }
    },
    pause: () => togglePause(),
    reset: () => resetGame()
  };
})();
</script>
</body>
</html>