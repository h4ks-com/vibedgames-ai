<!DOCTYPE html>
<html>
<head>
<title>Pixel Map Search with User Input</title>
<style>
body {
  font-family: sans-serif;
  margin: 20px;
}

#spriteCanvas {
  border: 1px solid #000;
  cursor: pointer; /* Indicate it's interactive */
}

.pixel-map {
  width: 50px;
  height: 50px;
  border: 1px solid #ccc;
  margin: 5px;
  display: inline-block;
}

#results {
  margin-top: 20px;
}
</style>
</head>
<body>

<h1>Pixel Map Search with User Input</h1>

<h2>Draw Your Sprite (4x4):</h2>
<canvas id="spriteCanvas" width="64" height="64"></canvas>  <!-- Increased size for better drawing -->

<label for="functionSelect">Select Function:</label>
<select id="functionSelect">
  <option value="avgRed">Average Red</option>
  <option value="avgGreen">Average Green</option>
  <option value="avgBlue">Average Blue</option>
  <option value="totalPixels">Total Pixels</option>
  <option value="redPixelCount">Red Pixel Count</option>
  <option value="greenPixelCount">Green Pixel Count</option>
  <option value="bluePixelCount">Blue Pixel Count</option>
  <option value="brightness">Brightness</option>
  <option value="contrast">Contrast (simple)</option>
  <option value="randomValue">Random Value</option>
</select>

<button onclick="searchPixelMaps()">Search</button>

<div id="results">
  <h2>Results:</h2>
  <div id="pixelMapContainer"></div>
</div>

<script>
const canvas = document.getElementById('spriteCanvas');
const ctx = canvas.getContext('2d');
const pixelSize = 16; // 64 / 4 = 16 pixels per sprite "pixel"

let spriteData = []; // Stores the user-drawn sprite as a 4x4 array of RGB values

// Initialize spriteData with default (black) pixels
function initSpriteData() {
  spriteData = [];
  for (let i = 0; i < 4; i++) {
    spriteData[i] = [];
    for (let j = 0; j < 4; j++) {
      spriteData[i][j] = [0, 0, 0]; // Black by default
    }
  }
}
initSpriteData(); // Initialize on page load

// Function to draw the current spriteData on the canvas
function drawSprite() {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      ctx.fillStyle = `rgb(${spriteData[i][j][0]}, ${spriteData[i][j][1]}, ${spriteData[i][j][2]})`;
      ctx.fillRect(j * pixelSize, i * pixelSize, pixelSize, pixelSize);
    }
  }
}
drawSprite(); // Initial draw

// Event listener for drawing on the canvas
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);
canvas.addEventListener('mousemove', draw);

let isDrawing = false;

function startDrawing(e) {
  isDrawing = true;
  draw(e); // Draw immediately on mouse down
}

function stopDrawing(e) {
  isDrawing = false;
}

function draw(e) {
  if (!isDrawing) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const pixelX = Math.floor(x / pixelSize);
  const pixelY = Math.floor(y / pixelSize);

  if (pixelX >= 0 && pixelX < 4 && pixelY >= 0 && pixelY < 4) {
    // Set the pixel color (example: red - you can add a color picker)
    spriteData[pixelY][pixelX] = [255, 0, 0]; // Red
    drawSprite(); // Redraw the sprite
  }
}


// Function Definitions
const functions = {
  avgRed: (map) => map.flat().reduce((sum, pixel) => sum + pixel[0], 0) / (map.length * map[0].length),  // map[0].length ensures correct calculation for rectangular maps
  avgGreen: (map) => map.flat().reduce((sum, pixel) => sum + pixel[1], 0) / (map.length * map[0].length),
  avgBlue: (map) => map.flat().reduce((sum, pixel) => sum + pixel[2], 0) / (map.length * map[0].length),
  totalPixels: (map) => map.length * map[0].length,
  redPixelCount: (map) => map.flat().filter(pixel => pixel[0] > 128).length, // Example: Count red pixels > 128
  greenPixelCount: (map) => map.flat().filter(pixel => pixel[1] > 128).length,
  bluePixelCount: (map) => map.flat().filter(pixel => pixel[2] > 128).length,
  brightness: (map) => map.flat().reduce((sum, pixel) => sum + (pixel[0] + pixel[1] + pixel[2]) / 3, 0) / (map.length * map[0].length),
  contrast: (map) => { //Simple contrast calculation, not perfect
      const avgBrightness = functions.brightness(map);
      return map.flat().reduce((sum, pixel) => sum + Math.abs((pixel[0] + pixel[1] + pixel[2]) / 3 - avgBrightness), 0) / (map.length * map[0].length);
  },
  randomValue: (map) => Math.random() // Just for testing
};

function searchPixelMaps() {
  const selectedFunction = document.getElementById("functionSelect").value;
  const searchFunction = functions[selectedFunction];

  if (!searchFunction) {
    alert("Invalid function selected.");
    return;
  }

  const resultsContainer = document.getElementById("pixelMapContainer");
  resultsContainer.innerHTML = ""; // Clear previous results

    const value = searchFunction(spriteData);

    const mapElement = document.createElement("div");
    mapElement.classList.add("pixel-map");
    mapElement.title = `Value: ${value.toFixed(2)}`; // Show the value as a tooltip

    // Draw the pixel map (simplified for demonstration)
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            const pixel = spriteData[i][j];
            const pixelDiv = document.createElement("div");
            pixelDiv.style.width = "12px"; // Slightly smaller pixels for display
            pixelDiv.style.height = "12px";
            pixelDiv.style.backgroundColor = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
            pixelDiv.style.display = "inline-block"; // Display pixels horizontally
            mapElement.appendChild(pixelDiv);
        }
    }


    resultsContainer.appendChild(mapElement);
}


</script>

</body>
</html>
