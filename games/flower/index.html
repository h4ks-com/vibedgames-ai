<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Flower Game Replica</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to top, #654321, #87CEEB); /* Ground to Sky gradient */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/Tween.min.js"></script>
<script>
    // Initialize scene, camera, renderer
    const canvas = document.getElementById('gameCanvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
    );
    camera.position.set(0, 50, 150);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Handle window resize
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    // Add directional light for shadows
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Array to hold flowers
    const flowers = [];
    const flowerCount = 20;

    // Flower class
    class Flower {
        constructor(x, z) {
            this.group = new THREE.Group();

            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
            const stemMat = new THREE.MeshLambertMaterial({ color: 0x006400 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 1;
            this.group.add(stem);

            // Bloom
            const bloomGeo = new THREE.SphereGeometry(0.8, 16, 16);
            this.bloomMaterial = new THREE.MeshLambertMaterial({ color: 0xff69b4, transparent: true, opacity: 0.8 });
            this.bloom = new THREE.Mesh(bloomGeo, this.bloomMaterial);
            this.bloom.position.y = 3;
            this.bloom.scale.set(0.1, 0.1, 0.1);
            this.bloomScale = 0.1;
            this.group.add(this.bloom);

            // Petals - multiple small spheres around the bloom
            this.petals = [];
            const petalGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const petalMaterial = new THREE.MeshLambertMaterial({ color: 0xff69b4 });
            const petalCount = 8;
            for (let i = 0; i < petalCount; i++) {
                const petal = new THREE.Mesh(petalGeo, petalMaterial);
                const angle = (i / petalCount) * Math.PI * 2;
                petal.position.x = Math.cos(angle) * 1.2;
                petal.position.z = Math.sin(angle) * 1.2;
                petal.position.y = 0;
                this.bloom.add(petal);
                this.petals.push(petal);
            }

            this.group.position.x = x;
            this.group.position.z = z;
            scene.add(this.group);

            this.isBloomed = false;
        }

        bloom() {
            if (!this.isBloomed) {
                this.isBloomed = true;
                // Animate bloom size and opacity
                new TWEEN.Tween(this.bloom.scale)
                    .to({ x: 1.5, y: 1.5, z: 1.5 }, 500)
                    .start();
                new TWEEN.Tween(this.bloomMaterial)
                    .to({ opacity: 1 }, 500)
                    .start();
            }
        }
    }

    // Create flowers at random positions
    for (let i = 0; i < flowerCount; i++) {
        const x = (Math.random() - 0.5) * 150;
        const z = (Math.random() - 0.5) * 150;
        flowers.push(new Flower(x, z));
    }

    // Animate function
    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        renderer.render(scene, camera);
    }

    // Raycast for interactions
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    document.addEventListener('mousemove', (event) => {
        // Convert mouse to normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        // Update raycaster
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length > 0) {
            const point = intersects[0].point;
            // Bloom flowers within radius
            flowers.forEach(flower => {
                const dx = flower.group.position.x - point.x;
                const dz = flower.group.position.z - point.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 6) {
                    flower.bloom();
                }
            });
        }
    });

    // Animation loop
    animate();
</script>
</body>
</html>