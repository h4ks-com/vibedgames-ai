<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Roguelike</title>
<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  body {
    background: #111;
    color: #eee;
    font-family: 'Courier New', Courier, monospace;
    margin: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  #game {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
  }

  #map {
    background-color: #222;
    border: 2px solid #555;
    image-rendering: pixelated;
  }

  #sidebar {
    background: #222;
    width: 260px;
    padding: 10px;
    border-left: 2px solid #555;
    font-size: 14px;
    line-height: 1.4;
    display: flex;
    flex-direction: column;
  }

  #container {
    flex: 1;
    display: flex;
    max-width: 920px;
    margin: 8px auto;
    border: 2px solid #555;
    height: 400px;
    background: #222;
  }

  h1 {
    margin: 5px 0 10px 0;
    font-weight: normal;
    font-size: 22px;
    text-align: center;
    color: #ddd;
    text-shadow: 0 0 5px #0af;
  }

  #log {
    flex: 1;
    background: #111;
    margin-top: 7px;
    padding: 6px;
    border-radius: 3px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.3;
  }

  #stats {
    margin-bottom: 10px;
  }

  #inventory {
    background: #111;
    border-radius: 3px;
    max-height: 120px;
    overflow-y: auto;
    padding: 6px;
  }

  #instructions {
    font-size: 12px;
    color: #999;
    margin-top: 10px;
    user-select:none;
  }

  .item {
    cursor: pointer;
    user-select:none;
  }
  .item:hover {
    background: #0af4;
  }

  /* Scrollbar for log and inventory */
  #log::-webkit-scrollbar,
  #inventory::-webkit-scrollbar {
    width: 6px;
  }
  #log::-webkit-scrollbar-thumb,
  #inventory::-webkit-scrollbar-thumb {
    background: #0af8;
    border-radius: 3px;
  }
</style>
</head>
<body>
  <h1>Mini Roguelike</h1>
  <div id="container">
    <div id="game">
      <canvas id="map" width="400" height="400" tabindex="0"></canvas>
    </div>
    <div id="sidebar">
      <div id="stats"></div>
      <div><strong>Inventory</strong></div>
      <div id="inventory" tabindex="0" aria-label="Player Inventory">
      </div>
      <div id="instructions">
        Move: Arrow keys or WASD<br />
        Pick up item: E<br />
        Use item: Click item in inventory<br />
        Restart: R
      </div>
    </div>
  </div>
  <div id="log" aria-live="polite" aria-atomic="true"></div>

<script>
(() => {
  const canvas = document.getElementById('map');
  const ctx = canvas.getContext('2d');
  const statsDiv = document.getElementById('stats');
  const logDiv = document.getElementById('log');
  const invDiv = document.getElementById('inventory');

  // Map parameters
  const MAP_WIDTH = 20;
  const MAP_HEIGHT = 20;
  const TILE_SIZE = 20;

  canvas.width = MAP_WIDTH * TILE_SIZE;
  canvas.height = MAP_HEIGHT * TILE_SIZE;

  // Tiles:
  // '#' wall
  // '.' floor
  // 'D' door (maybe)
  // '@' player
  // items are on floor spaces

  // Game state
  let map = [];
  let player = { x: 1, y: 1, hp: 20, maxHp: 20, atk: 3, def: 1 };
  let messages = [];
  let inventory = [];
  let itemsOnMap = [];
  let monsters = [];
  let turnLocked = false;

  // Item defs
  const itemTypes = [
    {
      id: 'potion',
      name: 'Health Potion',
      description: 'Heals 8 HP',
      type: 'consumable',
      effect: (plyr) => {
        const heal = 8;
        plyr.hp = Math.min(plyr.maxHp, plyr.hp + heal);
        addMessage(`You drank a Health Potion and healed ${heal} HP.`);
      },
      color: '#e00',
      char: '!',
    },
    {
      id: 'sword',
      name: 'Sword',
      description: 'Increases attack by 2 when equipped.',
      type: 'equipment',
      slot: 'weapon',
      atkBonus: 2,
      color: '#aaa',
      char: '/',
    },
    {
      id: 'shield',
      name: 'Shield',
      description: 'Increases defense by 2 when equipped.',
      type: 'equipment',
      slot: 'offhand',
      defBonus: 2,
      color: '#0af',
      char: ']',
    },
    {
      id: 'scroll',
      name: 'Scroll of Fireball',
      description: 'Deals 10 damage to all monsters.',
      type: 'consumable',
      effect: (plyr) => {
        let hitAny = false;
        monsters.forEach(mon => {
          if (isAdjacent(plyr, mon)) {
            mon.hp -= 10;
            addMessage(`Fireball burns ${mon.name} for 10 damage!`);
            hitAny = true;
          }
        });
        if (!hitAny) {
          addMessage('Fireball fizzles. No monsters nearby.');
        }
        cleanupMonsters();
      },
      color: '#f90',
      char: '?',
    },
  ];

  // Player equipment
  let equipped = {
    weapon: null,
    offhand: null,
  };

  // Monster defs
  const monsterTypes = [
    { id: 'goblin', name: 'Goblin', hp: 10, atk: 2, def: 0, char: 'g', color: '#0f0' },
    { id: 'orc', name: 'Orc', hp: 16, atk: 4, def:1, char: 'o', color: '#fa0' },
  ];

  // Utils
  function addMessage(text) {
    messages.push(text);
    if (messages.length > 10) messages.shift();
    renderLog();
  }

  function renderLog() {
    logDiv.innerHTML = messages.map(m => `<div>${m}</div>`).join('');
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function rndInt(min,max) {
    return Math.floor(Math.random()*(max-min+1)) + min;
  }

  function shuffleArray(arr) {
    for(let i = arr.length -1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }

  function isFloor(x,y){
    if(x < 0 || y < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) return false;
    return map[y][x] === '.';
  }

  function isBlocked(x,y) {
    if (x < 0 || y < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) return true;
    if (map[y][x] === '#') return true;
    if (monsters.find(m => m.x === x && m.y === y)) return true;
    return false;
  }

  function isAdjacent(a,b) {
    return Math.abs(a.x-b.x) <= 1 && Math.abs(a.y-b.y) <= 1;
  }

  // Map generation: simple room with random inner walls
  function generateMap() {
    // Initialize all walls
    map = new Array(MAP_HEIGHT);
    for(let y=0;y<MAP_HEIGHT;y++){
      map[y] = new Array(MAP_WIDTH).fill('#');
    }

    // Create one big room inside border
    for(let y=1;y<MAP_HEIGHT-1;y++) {
      for(let x=1;x<MAP_WIDTH-1;x++) {
        map[y][x] = '.';
      }
    }

    // Place some random walls inside room
    let wallCount = 40;
    while (wallCount > 0) {
      const rx = rndInt(1, MAP_WIDTH-2);
      const ry = rndInt(1, MAP_HEIGHT-2);
      // Don't block player start
      if (rx === player.x && ry === player.y) continue;
      map[ry][rx] = '#';
      wallCount--;
    }
  }

  function placeItems() {
    itemsOnMap = [];
    let itemCount = 15;
    while(itemCount > 0) {
      const x = rndInt(1, MAP_WIDTH-2);
      const y = rndInt(1, MAP_HEIGHT-2);
      if(!isFloor(x,y)) continue;
      if(itemsOnMap.find(i => i.x === x && i.y === y)) continue;
      const itemType = itemTypes[rndInt(0,itemTypes.length-1)];
      itemsOnMap.push({ ...itemType, x, y });
      itemCount--;
    }
  }

  function placeMonsters() {
    monsters = [];
    let monCount = 8;
    while(monCount > 0) {
      const x = rndInt(1, MAP_WIDTH-2);
      const y = rndInt(1, MAP_HEIGHT-2);
      if(!isFloor(x,y)) continue;
      if(monsters.find(m => m.x === x && m.y === y)) continue;
      if(x === player.x && y === player.y) continue;
      const mtype = monsterTypes[rndInt(0, monsterTypes.length-1)];
      monsters.push({
        ...mtype,
        x, y,
        hp: mtype.hp,
      });
      monCount--;
    }
  }

  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw map
    for(let y=0;y<MAP_HEIGHT;y++) {
      for(let x=0;x<MAP_WIDTH;x++){
        const tile = map[y][x];
        if(tile === '#') {
          ctx.fillStyle = '#555';
          ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle = '#222';
          ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    // draw items
    itemsOnMap.forEach(item => {
      ctx.fillStyle = item.color;
      ctx.font = `${TILE_SIZE-4}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.char, item.x*TILE_SIZE + TILE_SIZE/2, item.y*TILE_SIZE + TILE_SIZE/2);
    });

    // draw monsters
    monsters.forEach(mon => {
      ctx.fillStyle = mon.color;
      ctx.font = `${TILE_SIZE-2}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(mon.char, mon.x*TILE_SIZE + TILE_SIZE/2, mon.y*TILE_SIZE + TILE_SIZE/2);
    });

    // draw player
    ctx.fillStyle = '#0af';
    ctx.font = `${TILE_SIZE-2}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('@', player.x*TILE_SIZE + TILE_SIZE/2, player.y*TILE_SIZE + TILE_SIZE/2);

    renderStats();
    renderInventory();
  }

  function renderStats() {
    const atkBonus = equipped.weapon ? equipped.weapon.atkBonus || 0 : 0;
    const defBonus = equipped.offhand ? equipped.offhand.defBonus || 0 : 0;
    const totalAtk = player.atk + atkBonus;
    const totalDef = player.def + defBonus;

    statsDiv.innerHTML = `
      <div><strong>HP:</strong> ${player.hp} / ${player.maxHp}</div>
      <div><strong>Attack:</strong> ${totalAtk} ${equipped.weapon ? `(+${equipped.weapon.atkBonus})` : ''}</div>
      <div><strong>Defense:</strong> ${totalDef} ${equipped.offhand ? `(+${equipped.offhand.defBonus})` : ''}</div>
    `;
  }

  function renderInventory() {
    invDiv.innerHTML = '';
    if (inventory.length === 0) {
      invDiv.textContent = 'Empty';
      return;
    }
    inventory.forEach((item, i) => {
      const div = document.createElement('div');
      div.className = 'item';
      div.tabIndex = 0;
      div.title = item.description;
      let label = '';
      if (item.type === 'equipment') {
        const eqSlot = equipped[item.slot] === item ? ' (Equipped)' : '';
        label = `${item.name}${eqSlot}`;
      } else {
        label = item.name;
      }
      div.textContent = label;
      div.style.color = item.color;
      div.dataset.invIndex = i;
      invDiv.appendChild(div);
    });
  }

  function movePlayer(dx, dy) {
    if(turnLocked) return;    
    const nx = player.x + dx;
    const ny = player.y + dy;
    if(nx < 0 || ny < 0 || nx >= MAP_WIDTH || ny >= MAP_HEIGHT) return;
    if(map[ny][nx] === '#') return;

    const targetMon = monsters.find(m => m.x === nx && m.y === ny);
    if(targetMon) {
      attackMonster(targetMon);
      endTurn();
      return;
    }

    player.x = nx;
    player.y = ny;

    // Check if stepped on item
    const itemHere = itemsOnMap.find(i => i.x === player.x && i.y === player.y);
    if (itemHere) {
      addMessage(`You see a ${itemHere.name} here.`);
    }

    endTurn();
  }

  function attackMonster(mon) {
    // Calculate player's total attack
    const atkBonus = equipped.weapon ? equipped.weapon.atkBonus || 0 : 0;
    const defBonusMon = mon.def || 0;
    const totalAtk = player.atk + atkBonus;
    // Damage = attack - defense (min 1)
    let dmg = totalAtk - defBonusMon;
    if(dmg < 1) dmg = 1;
    mon.hp -= dmg;
    addMessage(`You hit the ${mon.name} for ${dmg} damage.`);

    if (mon.hp <= 0) {
      addMessage(`The ${mon.name} dies!`);
      monsters = monsters.filter(m => m !== mon);
    }
  }

  function monstersAct() {
    monsters.forEach(mon => {
      if (mon.hp <= 0) return;

      // Simple AI: move towards player if close, else random move
      const distX = player.x - mon.x;
      const distY = player.y - mon.y;
      let moveX = 0, moveY = 0;

      if(Math.abs(distX) <= 5 && Math.abs(distY) <= 5) {
        // move closer
        moveX = distX === 0 ? 0 : distX / Math.abs(distX);
        moveY = distY === 0 ? 0 : distY / Math.abs(distY);
      } else {
        // random move
        const moves = [
          [1,0],[-1,0],[0,1],[0,-1],
          [1,1],[1,-1],[-1,1],[-1,-1],
          [0,0],
        ];
        const choice = moves[rndInt(0,moves.length-1)];
        moveX = choice[0];
        moveY = choice[1];
      }

      const nx = mon.x + moveX;
      const ny = mon.y + moveY;

      // Check if player is adjacent and in the direction monster wants to move
      if(nx === player.x && ny === player.y) {
        monsterAttack(mon);
        return;
      }

      // Move if floor and no monster there and no player
      if (isFloor(nx, ny) && !monsters.find(m => m.x === nx && m.y === ny) && !(player.x === nx && player.y === ny)) {
        mon.x = nx;
        mon.y = ny;
      }
    });
  }

  function monsterAttack(mon) {
    const atk = mon.atk || 1;
    const defBonus = equipped.offhand ? equipped.offhand.defBonus || 0 : 0;
    const totalDef = player.def + defBonus;
    let dmg = atk - totalDef;
    if(dmg < 1) dmg = 1;
    player.hp -= dmg;
    addMessage(`The ${mon.name} hits you for ${dmg} damage!`);

    if(player.hp <=0) {
      addMessage('You died! Press R to restart.');
      turnLocked = true;
    }
  }

  function endTurn() {
    turnLocked = true;
    monstersAct();
    cleanupMonsters();
    render();
    if(player.hp > 0) turnLocked = false;
  }

  function cleanupMonsters(){
    monsters = monsters.filter(m => m.hp > 0);
  }

  function pickUpItem() {
    if(turnLocked) return;
    const index = itemsOnMap.findIndex(i => i.x === player.x && i.y === player.y);
    if (index === -1) {
      addMessage('There is nothing here to pick up.');
      return;
    }
    const item = itemsOnMap[index];
    itemsOnMap.splice(index,1);
    inventory.push(item);
    addMessage(`You picked up a ${item.name}.`);
    render();
  }

  function useItem(index) {
    if (index < 0 || index >= inventory.length) return;
    const item = inventory[index];

    if(item.type === 'consumable') {
      item.effect(player);
      inventory.splice(index,1);
    } else if(item.type === 'equipment') {
      // Toggle equip/unequip
      if (equipped[item.slot] === item) {
        // Unequip
        equipped[item.slot] = null;
        addMessage(`You unequipped ${item.name}.`);
      } else {
        // Equip new
        equipped[item.slot] = item;
        addMessage(`You equipped ${item.name}.`);
      }
    }
    render();
  }

  // Keyboard input
  function onKeyDown(e) {
    if(turnLocked) {
      if(e.key.toLowerCase() === 'r') {
        init();
      }
      return;
    }
    switch(e.key) {
      case 'ArrowUp':
      case 'w':
      case 'W':
        movePlayer(0,-1);
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        movePlayer(0,1);
        break;
      case 'ArrowLeft':
      case 'a':
      case 'A':
        movePlayer(-1,0);
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        movePlayer(1,0);
        break;
      case 'e':
      case 'E':
        pickUpItem();
        break;
      case 'r':
      case 'R':
        init();
        break;
    }
  }

  // Clicking on inventory items to use
  invDiv.addEventListener('click', (e) => {
    const idx = e.target.dataset.invIndex;
    if(idx !== undefined) {
      useItem(+idx);
      endTurn();
    }
  });
  invDiv.addEventListener('keydown', e => {
    // Keyboard activation of inventory items (Enter or Space)
    if(e.key === 'Enter' || e.key === ' ') {
      const focused = document.activeElement;
      if(focused && focused.dataset.invIndex !== undefined) {
        e.preventDefault();
        useItem(+focused.dataset.invIndex);
        endTurn();
      }
    }
  });

  // Start / Reset game
  function init() {
    player = { x: 1, y: 1, hp: 20, maxHp: 20, atk: 3, def: 1 };
    inventory = [];
    equipped = {weapon:null, offhand:null};
    generateMap();
    placeItems();
    placeMonsters();
    messages = [];
    turnLocked = false;
    addMessage('Welcome to Mini Roguelike!');
    render();
  }

  // Initial setup
  init();

  // Event listeners
  window.addEventListener('keydown', onKeyDown);
  canvas.setAttribute('tabindex','0');
  canvas.focus();

})();
</script>
</body>
</html>
