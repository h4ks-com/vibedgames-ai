<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Base64 Image Viewer</title>
<style>
  :root{
    --bg1:#0f1724;
    --bg2:#071129;
    --card:#0b1220cc;
    --glass: rgba(255,255,255,0.04);
    --accent:#7c5cff;
    --muted:#9aa7c7;
    --success:#2ecc71;
    --danger:#ff6b6b;
    --glass-2: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 10% 10%, rgba(124,92,255,0.12), transparent), linear-gradient(180deg,var(--bg1),var(--bg2)); color:#e6eef8}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:48px;}
  .card{
    width:100%;
    max-width:1100px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    border-radius:16px;
    padding:22px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    display:grid;
    grid-template-columns: 1fr 420px;
    gap:20px;
  }
  header{grid-column:1 / -1; display:flex; align-items:center; justify-content:space-between; gap:12px;}
  .title{display:flex; align-items:center; gap:14px;}
  .logo{
    width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#50d6ff);display:flex;align-items:center;justify-content:center;font-weight:700;color:#051024;box-shadow:0 6px 18px rgba(92,66,255,0.12), inset 0 -4px 14px rgba(255,255,255,0.06);
  }
  h1{font-size:18px;margin:0}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  select, button{
    background:var(--glass); border:1px solid rgba(255,255,255,0.03); color:inherit; padding:10px 12px;border-radius:10px; font-size:13px;
  }
  button.primary{
    background: linear-gradient(90deg,var(--accent),#50d6ff);
    color:#031021; border:none; font-weight:600; box-shadow: 0 8px 24px rgba(92,66,255,0.16);
  }
  .left{
    display:flex; flex-direction:column; gap:12px;
  }
  textarea{
    width:100%; min-height:260px; resize:vertical; max-height:550px;
    padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
    color: #e9f0ff; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:13px;
  }
  .hint{font-size:12px;color:var(--muted)}
  .actions{display:flex;gap:8px;align-items:center}
  .right{
    padding:16px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), var(--glass-2));
    border:1px solid rgba(255,255,255,0.02); display:flex; flex-direction:column; gap:12px; align-items:stretch;
    min-height:360px;
  }
  .preview-wrap{display:flex;flex-direction:column;gap:8px;align-items:center; justify-content:center; flex:1; border-radius:10px; padding:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border:1px dashed rgba(255,255,255,0.03);}
  img#preview{max-width:100%; max-height:320px; border-radius:8px; box-shadow: 0 6px 20px rgba(2,6,23,0.6); background:#041022; display:block}
  .meta{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:999px; font-size:12px; color:var(--muted); border:1px solid rgba(255,255,255,0.02)}
  .error{color:var(--danger); font-weight:600}
  footer{grid-column:1 / -1; display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:6px}
  .small{font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
  a.link{color:var(--accent); text-decoration:none; font-weight:600}
  .kbd{background:#071024;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-size:12px}
  @media (max-width:960px){
    .card{grid-template-columns:1fr; padding:18px}
    .right{min-height:300px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="application" aria-label="Base64 Image Viewer">
    <header>
      <div class="title">
        <div class="logo">B6</div>
        <div>
          <h1>Base64 Image Viewer</h1>
          <p class="lead">Paste base64 or a data URL. Choose a format or let it auto-detect. Render safely.</p>
        </div>
      </div>
      <div class="controls" aria-hidden="false">
        <label class="muted" for="formatSelect">Format</label>
        <select id="formatSelect" title="Choose image format">
          <option value="auto">Auto detect</option>
          <option value="png">image/png</option>
          <option value="jpeg">image/jpeg</option>
          <option value="webp">image/webp</option>
          <option value="gif">image/gif</option>
          <option value="svg+xml">image/svg+xml</option>
          <option value="bmp">image/bmp</option>
          <option value="ico">image/x-icon</option>
        </select>
        <div class="actions">
          <button id="renderBtn" class="primary" title="Render the image">Render</button>
          <button id="clearBtn" title="Clear input">Clear</button>
        </div>
      </div>
    </header>

    <section class="left" aria-label="Input">
      <label class="hint">Paste base64 (raw) or a full data URL (data:image/...;base64,AAAA...)</label>
      <textarea id="b64input" placeholder="Paste base64 or data URL here..."></textarea>
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="hint">Drag & drop a small file here? Try pasting a data URL from clipboard.</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="sampleBtn" title="Insert a tiny sample PNG">Sample</button>
          <button id="pasteBtn" title="Paste from clipboard">Paste</button>
        </div>
      </div>
    </section>

    <aside class="right" aria-label="Preview & info">
      <div class="preview-wrap" id="previewWrap">
        <div style="display:flex;flex-direction:column;align-items:center;gap:8px;">
          <div class="muted">Preview</div>
          <div style="width:100%;display:flex;align-items:center;justify-content:center;padding:6px;">
            <img id="preview" alt="Decoded preview will appear here" />
          </div>
        </div>
      </div>

      <div class="meta" aria-live="polite" id="meta">
        <div class="chip" id="mimeChip">mime: —</div>
        <div class="chip" id="sizeChip">size: —</div>
        <div class="chip" id="dimChip">dims: —</div>
        <div class="chip" id="statusChip">status: idle</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;">
        <a id="dlLink" class="link" href="#" download="" style="display:none">Download image</a>
        <div style="display:flex;gap:8px;">
          <button id="copyDataUrl" title="Copy data URL" >Copy data URL</button>
          <button id="openInNew" title="Open image in new tab">Open</button>
        </div>
      </div>

    </aside>

    <footer>
      <div class="small muted">Max safe size: 50 MB. If render fails, nothing will be harmed — it just fails.</div>
      <div class="small muted">Built stylishly. No external libraries.</div>
    </footer>
  </div>
</div>

<script>
(() => {
  const MAX_BYTES = 50 * 1024 * 1024; // 50MB
  const input = document.getElementById('b64input');
  const renderBtn = document.getElementById('renderBtn');
  const clearBtn = document.getElementById('clearBtn');
  const sampleBtn = document.getElementById('sampleBtn');
  const pasteBtn = document.getElementById('pasteBtn');
  const formatSelect = document.getElementById('formatSelect');
  const preview = document.getElementById('preview');
  const mimeChip = document.getElementById('mimeChip');
  const sizeChip = document.getElementById('sizeChip');
  const dimChip = document.getElementById('dimChip');
  const statusChip = document.getElementById('statusChip');
  const dlLink = document.getElementById('dlLink');
  const copyBtn = document.getElementById('copyDataUrl');
  const openBtn = document.getElementById('openInNew');

  let lastObjectURL = null;
  let lastDataUrl = null;

  function setStatus(text, isError) {
    statusChip.textContent = 'status: ' + text;
    statusChip.classList.toggle('error', !!isError);
  }

  function clearPreview() {
    if (lastObjectURL) {
      URL.revokeObjectURL(lastObjectURL);
      lastObjectURL = null;
    }
    preview.src = '';
    mimeChip.textContent = 'mime: —';
    sizeChip.textContent = 'size: —';
    dimChip.textContent = 'dims: —';
    dlLink.style.display = 'none';
    dlLink.href = '#';
    lastDataUrl = null;
    setStatus('idle', false);
  }

  function normalizeBase64Input(text) {
    if (!text) return '';
    // Remove newlines and spaces
    return text.trim().replace(/\\s+/g, '');
  }

  function isDataUrl(s) {
    return s.startsWith('data:');
  }

  function splitDataUrl(dataUrl) {
    // returns {mime, isBase64, data}
    const match = /^data:([^;]+)?(;base64)?,(.*)$/.exec(dataUrl);
    if (!match) return null;
    return { mime: match[1] || null, isBase64: !!match[2], data: match[3] };
  }

  function base64ToUint8Array(b64) {
    // Validate approximately and decode using atob. atob may throw.
    // Limit size to avoid huge allocations.
    const cleaned = normalizeBase64Input(b64);
    if (!cleaned) throw new Error('No data');
    // length check: each 4 chars -> 3 bytes
    const estimated = Math.floor(cleaned.length / 4 * 3);
    if (estimated > MAX_BYTES) throw new Error('Data too large (>50MB)');
    let binary;
    try {
      binary = atob(cleaned);
    } catch (e) {
      throw new Error('Invalid base64');
    }
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
  }

  function detectMimeFromBytes(bytes) {
    if (!bytes || bytes.length < 4) return null;
    // PNG
    if (bytes.length >= 8 && bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47 && bytes[4] === 0x0D && bytes[5] === 0x0A && bytes[6] === 0x1A && bytes[7] === 0x0A) {
      return 'image/png';
    }
    // JPEG
    if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
      return 'image/jpeg';
    }
    // GIF
    if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46) {
      return 'image/gif';
    }
    // BMP
    if (bytes[0] === 0x42 && bytes[1] === 0x4D) {
      return 'image/bmp';
    }
    // ICO (starts with 00 00 01 00 or 00 00 02 00)
    if (bytes[0] === 0x00 && bytes[1] === 0x00 && (bytes[2] === 0x01 || bytes[2] === 0x02) && bytes[3] === 0x00) {
      return 'image/x-icon';
    }
    // WEBP: 'RIFF'....'WEBP' at bytes 0-3 and 8-11
    if (bytes.length >= 12 && bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46 &&
        bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50) {
      return 'image/webp';
    }
    // SVG: try decode start as UTF-8 text and look for '<svg' or '<?xml'
    try {
      const snippet = new TextDecoder('utf-8').decode(bytes.subarray(0, Math.min(bytes.length, 200)));
      const trimmed = snippet.trimStart().toLowerCase();
      if (trimmed.startsWith('<svg') || trimmed.startsWith('<?xml') || trimmed.includes('<svg')) {
        return 'image/svg+xml';
      }
    } catch(e){}
    return null;
  }

  function chosenMimeFromSelect(value) {
    if (!value) return null;
    if (value === 'auto') return null;
    if (value === 'svg+xml') return 'image/svg+xml';
    if (value === 'ico') return 'image/x-icon';
    return 'image/' + value;
  }

  function createBlobUrlFromBytes(bytes, mime) {
    const blob = new Blob([bytes.buffer], { type: mime || 'application/octet-stream' });
    return URL.createObjectURL(blob);
  }

  function prepareAndRender(rawInput, formatOverride) {
    clearPreview();
    setStatus('processing', false);

    if (!rawInput) {
      setStatus('no input', true);
      return;
    }

    rawInput = rawInput.trim();
    try {
      // If full data URL provided, preserve data part and mime
      if (isDataUrl(rawInput)) {
        const parsed = splitDataUrl(rawInput);
        if (!parsed) throw new Error('Malformed data URL');
        const b64 = parsed.data;
        if (!parsed.isBase64) {
          throw new Error('Input data URL is not base64-encoded');
        }
        const bytes = base64ToUint8Array(b64);
        let mimeDetected = parsed.mime || detectMimeFromBytes(bytes) || 'application/octet-stream';
        if (formatOverride && formatOverride !== 'auto') {
          mimeDetected = chosenMimeFromSelect(formatOverride) || mimeDetected;
        }
        const url = createBlobUrlFromBytes(bytes, mimeDetected);
        lastObjectURL = url;
        lastDataUrl = 'data:' + mimeDetected + ';base64,' + b64;
        showResult(url, mimeDetected, bytes.length, bytes);
        return;
      }

      // Otherwise treat as raw base64
      const b64raw = normalizeBase64Input(rawInput);
      const bytes = base64ToUint8Array(b64raw);
      let mimeDetected = detectMimeFromBytes(bytes);
      if (formatOverride && formatOverride !== 'auto') {
        mimeDetected = chosenMimeFromSelect(formatOverride) || mimeDetected;
      }
      if (!mimeDetected) {
        // default to binary blob with chosen format or octet-stream
        mimeDetected = chosenMimeFromSelect(formatOverride) || 'application/octet-stream';
      }
      const url = createBlobUrlFromBytes(bytes, mimeDetected);
      lastObjectURL = url;
      lastDataUrl = 'data:' + mimeDetected + ';base64,' + b64raw;
      showResult(url, mimeDetected, bytes.length, bytes);
    } catch (err) {
      clearPreview();
      setStatus('error: ' + err.message, true);
      mimeChip.textContent = 'mime: —';
      sizeChip.textContent = 'size: —';
      dimChip.textContent = 'dims: —';
    }
  }

  function showResult(objectUrl, mime, byteLength, bytes) {
    mimeChip.textContent = 'mime: ' + mime;
    sizeChip.textContent = 'size: ' + prettyBytes(byteLength);
    dimChip.textContent = 'dims: loading...';
    setStatus('rendering', false);

    preview.onload = () => {
      dimChip.textContent = 'dims: ' + preview.naturalWidth + '×' + preview.naturalHeight;
      setStatus('done', false);
      dlLink.style.display = 'inline';
      dlLink.href = objectUrl;
      const ext = mime.split('/')[1].replace('+xml','');
      dlLink.download = 'image.' + (ext || 'bin');
      copyBtn.disabled = false;
      openBtn.disabled = false;
    };
    preview.onerror = () => {
      // Some MIME types may not display as <img>. If it's svg text, try data URL fallback.
      dimChip.textContent = 'dims: —';
      setStatus('failed to render as <img>', true);

      // try fallback: if we have bytes and it's probably SVG text, create data URL
      if (mime === 'image/svg+xml' && bytes) {
        try {
          const text = new TextDecoder('utf-8').decode(bytes);
          const dataurl = 'data:' + mime + ';base64,' + btoa(unescape(encodeURIComponent(text)));
          preview.src = dataurl;
          lastDataUrl = dataurl;
          setStatus('rendered via data URL', false);
          return;
        } catch(e){}
      }

      // final fail: show nothing
      preview.src = '';
      dlLink.style.display = 'none';
      copyBtn.disabled = true;
      openBtn.disabled = true;
    };

    // Try to set src to blob URL
    preview.src = objectUrl;
  }

  function prettyBytes(n){
    if (n < 1024) return n + ' B';
    if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
    if (n < 1024*1024*1024) return (n/1024/1024).toFixed(2) + ' MB';
    return (n/1024/1024/1024).toFixed(2) + ' GB';
  }

  // Buttons
  renderBtn.addEventListener('click', () => {
    prepareAndRender(input.value, formatSelect.value);
  });

  clearBtn.addEventListener('click', () => {
    input.value = '';
    clearPreview();
  });

  sampleBtn.addEventListener('click', () => {
    // tiny 1x1 transparent PNG base64
    const tinyPng = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAnsB9p7lF2kAAAAASUVORK5CYII=';
    input.value = tinyPng;
  });

  pasteBtn.addEventListener('click', async () => {
    try {
      const text = await navigator.clipboard.readText();
      if (!text) return;
      input.value = text;
    } catch (e) {
      alert('Clipboard read failed: ' + e.message);
    }
  });

  copyBtn.addEventListener('click', async () => {
    if (!lastDataUrl) {
      setStatus('nothing to copy', true);
      return;
    }
    try {
      await navigator.clipboard.writeText(lastDataUrl);
      setStatus('copied', false);
    } catch (e) {
      setStatus('copy failed', true);
    }
  });

  openBtn.addEventListener('click', () => {
    if (!lastObjectURL) {
      setStatus('nothing to open', true);
      return;
    }
    window.open(lastObjectURL, '_blank', 'noopener');
  });

  // Drag and drop small file into textarea
  input.addEventListener('dragover', (e) => {
    e.preventDefault();
  });
  input.addEventListener('drop', (e) => {
    e.preventDefault();
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    if (f.size > MAX_BYTES) {
      setStatus('file too large', true);
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      // reader.result is an ArrayBuffer or data URL depending on method
      // We'll read as data URL to paste into textarea
      input.value = reader.result;
    };
    reader.readAsDataURL(f);
  });

  // Keyboard: Ctrl+Enter to render
  input.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      renderBtn.click();
    }
  });

  // init
  clearPreview();
  setStatus('ready', false);
})();
</script>
</body>
</html>