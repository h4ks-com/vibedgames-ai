<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VibeIRC Federated Clone - Demo (Expanded)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #141b22;
      --panel-2: #1e2a34;
      --text: #e6f2ff;
      --muted: #98a6af;
      --accent: #6be675;
      --accent2: #6bd0f9;
      --error: #ff6b6b;
      --chip: #2a393f;
      --shadow: 0 12px 28px rgba(0,0,0,.25);
      --glow: 0 0 0 rgba(0,0,0,0);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: Inter, system-ui, Arial, sans-serif; background: radial-gradient(circle at 20% -10%, rgba(107,230,117,.15), transparent 40%), linear-gradient(135deg, #0b0f14 0%, #0b0f14 60%, #0b0f14 100%); color: var(--text); }
    h1 { font-size: 16px; margin: 0 0 6px; font-weight: 700; }
    /* Layout */
    .app { display: grid; grid-template-columns: 280px 1fr 420px; gap: 12px; padding: 12px; height: 100vh; overflow: hidden; }
    /* Panels */
    .panel { background: linear-gradient(#111315, #0d131b); border-radius: 12px; padding: 12px; box-shadow: var(--shadow); border: 1px solid #1c2530; display: flex; flex-direction: column; overflow: hidden; }
    .panel-header { display: flex; align-items: center; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,.08); margin-bottom: 6px; }
    .panel h2 { font-size: 14px; margin: 0 0 6px; color: #cbd5e1; }
    .section { padding: 8px; border-radius: 10px; background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.05); margin-bottom: 8px; }
    .server-list { display: grid; gap: 6px; max-height: 340px; overflow: auto; padding-right: 4px; }
    .server-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; border-radius: 8px; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.06); }
    .server-item .name { font-weight: 600; display:flex; align-items: center; gap:6px; }
    .badge { padding: 2px 8px; border-radius: 999px; font-size: 11px; background: #2f4a3d; color: #c6ffd6; }
    .dot { width: 8px; height: 8px; border-radius: 50%; display:inline-block; }
    .user-list { font-family: ui-monospace, SFMono-Regular, monospace; font-size: 12px; padding: 6px 2px; display: grid; gap: 4px; }
    .user { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border-radius: 6px; background: rgba(255,255,255,.03); }
    .chat { display: flex; flex-direction: column; height: 100%; min-width: 0; }
    .chat-header { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; border-radius: 8px; background: rgba(20,26,34,.92); border: 1px solid rgba(255,255,255,.08); }
    .messages { flex: 1; padding: 10px; overflow: auto; background: linear-gradient(#0b1117, #0a0f14); border-radius: 8px; border: 1px solid rgba(255,255,255,.08); margin-top: 8px; display: flex; flex-direction: column; gap: 8px; }
    .message { padding: 6px 8px; border-radius: 6px; background: rgba(96, 190, 150, .15); border: 1px solid rgba(107,230,117,.4); align-self: flex-start; animation: pop .18s ease-out; }
    .message .from { font-weight: 700; font-size: 12px; margin-right: 6px; color:#a9f0c1; }
    .message .time { font-size: 11px; color: #b7cbdc; margin-left: 6px; }
    .input-area { display: flex; gap: 6px; padding-top: 8px; }
    input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(0,0,0,.25); color: #fff; outline: none; }
    button { padding: 9px 12px; border-radius: 8px; border: none; background: #2b9efc; color: white; font-weight: 700; cursor: pointer; transition: transform .15s ease, background .2s ease; }
    button.secondary { background: #313a44; color: #e5f0ff; }
    button:hover { transform: translateY(-1px); }
    .status { font-size: 12px; color: var(--muted); }
    .divider { height: 1px; background: rgba(255,255,255,.08); margin: 8px 0; }
    .toolbar { display:flex; gap:6px; flex-wrap: wrap; align-items: center; }
    .token { font-family: ui-monospace, SFMono-Regular, monospace; font-size: 11px; padding: 4px 8px; border-radius: 6px; background: #1e2a34; color: #8bd4ff; border: 1px solid #2b4a62; }
    .toast { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); background: #11141a; color: #eafff7; padding: 10px 14px; border-radius: 8px; border: 1px solid #2c6; }
    .pulse { animation: pulse 1.0s infinite; }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.03); opacity: .85; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes pop { from { transform: scale(0.95); } to { transform: scale(1); } }

    /* Confetti (CSS-based lightweight) */
    .confetti-piece {
      position: fixed;
      width: 8px;
      height: 12px;
      pointer-events: none;
      animation: confettiFall 2s ease-out forwards;
      z-index: 9999;
    }
    @keyframes confettiFall {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(760px) rotate(720deg); opacity: 0; }
    }

    /* Theme toggle (simple) */
    .theme-toggle { display:flex; align-items:center; gap:8px; }
    .switch {
      width: 48px; height: 26px; border-radius: 999px; background: #2a2a2a; position: relative; cursor: pointer; border:1px solid #4a4a4a;
    }
    .switch .knob { width: 22px; height: 22px; background: white; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: left .2s ease; }
    .switch.on { background: linear-gradient(135deg, #4ade80, #22c55e); }
    .switch.on .knob { left: 24px; }
    /* Animations toggle off state */
    .no-animations * { animation: none !important; transition: none !important; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <!-- Left: Servers & Presence -->
    <section class="panel" id="leftPanel">
      <div class="panel-header">
        <h2>Servers</h2>
        <div class="toolbar">
          <div class="theme-toggle" title="Animation toggle">
            <span>Anim</span>
            <div id="animToggle" class="switch" role="switch" aria-checked="true"><span class="knob"></span></div>
          </div>
        </div>
      </div>

      <div class="section" style="display:flex; flex-direction:column; gap:8px;">
        <div class="toolbar" style="flex-direction:column; align-items:flex-start; gap:6px;">
          <div class="section" style="width:100%;">
            <strong>Token</strong>
            <div id="tokenDisplay" class="token" style="margin-top:6px; word-break: break-all;">Not connected</div>
          </div>
          <div style="width:100%; display:flex; gap:6px;">
            <button id="btnNewServer" style="flex:1;">New Server</button>
            <button id="btnAudits" style="flex:1;" class="secondary">Audits</button>
          </div>
          <div style="width:100%; display:flex; gap:6px;">
            <button id="btnExport" style="flex:1;" class="secondary">Export Logs</button>
            <button id="btnImport" style="flex:1;" class="secondary">Import Logs</button>
          </div>
        </div>
        <div class="section" style="display:flex; gap:6px; align-items:center;">
          <input id="adminServerName" placeholder="Server name" style="flex:1; padding:6px; border-radius:6px; border:1px solid #2a2a2a; background:#0b0f14; color:#fff;">
          <button id="btnCreateServer">Create Server</button>
        </div>
      </div>

      <div class="server-list" id="serverList"></div>
    </section>

    <!-- Center: Chat View -->
    <section class="panel chat" id="centerPanel">
      <div class="chat-header" id="chatHeader">
        <div id="headerServerChannel" style="font-weight:700;">No server connected</div>
        <div class="status" id="presenceIndicator">Offline</div>
      </div>

      <div class="section" style="display:flex; gap:6px; align-items:center;">
        <div><strong>Channel:</strong></div>
        <select id="channelSelector" style="flex:1; padding:6px; border-radius:6px; border:1px solid #2a2a2a; background:#111;"></select>
        <button id="btnJoinChannel" class="secondary" style="padding:8px 12px; border-radius:6px;">Join</button>
      </div>

      <div class="messages" id="messages" aria-live="polite"></div>

      <div class="input-area">
        <input type="text" id="inputBox" placeholder="Type a message. Use /join, /msg, /nick, /who, /redirect..." />
        <button id="btnSend">Send</button>
      </div>

      <div id="typingIndicator" class="panel" style="display:none; margin-top:8px; padding:8px; background: rgba(0,0,0,.2); border:1px solid rgba(255,255,255,.15); border-radius: 8px;">
        <span id="typingText" style="opacity:.9;">Someone is typing...</span>
      </div>
    </section>

    <!-- Right: Admin & Plugins -->
    <section class="panel" id="rightPanel">
      <h2>Admin & Plugins</h2>

      <div class="section">
        <strong>Admin</strong>
        <div class="divider"></div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button id="btnAddPulse" class="secondary">Add Pulse Module</button>
          <button id="btnResetDemo" class="secondary" title="Reset demo data">Reset Demo</button>
        </div>
      </div>

      <div class="section">
        <strong>Vibe Modules</strong>
        <div id="pluginList" class="user-list" style="max-height:200px; overflow:auto;"></div>
        <div class="divider"></div>
        <button id="btnInstallPulse" class="secondary" style="width:100%;">Install Pulse Module</button>
      </div>

      <div class="section" style="flex:1; min-height:0; overflow:auto;">
        <strong>Audit Log</strong>
        <div id="auditLog" class="user-list" style="font-family: ui-monospace, monospace; font-size:12px; height: 240px; overflow:auto;"></div>
      </div>
    </section>
  </div>

  <div id="toast" class="toast" style="display:none;"></div>

  <script>
/* Expanded VibeIRC-like demo with federation features, plugins, and animations */

// Data models
class Channel {
  constructor(name, isPublic = true) {
    this.name = name;
    this.isPublic = isPublic;
    this.acl = { allowed: [], banned: [] };
    this.messages = []; // history
    this.members = new Set();
    this.redirects = {}; // channel->server
  }
  addMessage(msg) {
    this.messages.push(msg);
    if (this.messages.length > 400) this.messages.shift();
  }
}

class Message {
  constructor(fromUser, text, ts, channel, isPrivate = false, toUser = null) {
    this.fromUser = fromUser;
    this.text = text;
    this.ts = ts;
    this.channel = channel;
    this.isPrivate = isPrivate;
    this.toUser = toUser;
  }
}

class User {
  constructor(username, nickname = null, token = null) {
    this.username = username;
    this.nickname = nickname || username;
    this.token = token;
    this.serverName = null;
    this.connected = false;
  }
}

class Server {
  constructor(name) {
    this.name = name;
    this.channels = {}; // name -> Channel
    this.users = {}; // username -> User (present on this server)
    this.redirects = {}; // channelName -> targetServerName
    this.audit = [];
  }
  ensureChannel(name) {
    if (!this.channels[name]) this.channels[name] = new Channel(name, true);
    return this.channels[name];
  }
  createChannel(name, isPublic = true) {
    const ch = new Channel(name, isPublic);
    this.channels[name] = ch;
    this.log(`Channel created: ${name} on ${this.name}`);
    return ch;
  }
  log(a) {
    const e = { ts: Date.now(), entry: a };
    this.audit.push(e);
    pushAudit(a);
  }
  setNick(user, newNick) {
    user.nickname = newNick;
    this.log(`${user.username} changed nickname to ${newNick} on ${this.name}`);
  }
  joinChannel(user, channelName) {
    const ch = this.ensureChannel(channelName);
    if (!this.channelAllowed(user, ch)) {
      this.log(`join denied: ${user.username} to ${channelName} on ${this.name}`);
      return false;
    }
    ch.members.add(user.username);
    user.serverName = this.name;
    user.connected = true;
    this.users[user.username] = user;
    this.notifyPresence(user, true);
    // deliver offline messages (not used in this simplified demo)
    addMessageToUI(user, channelName, 'joined channel');
    this.log(`${user.username} joined ${channelName} on ${this.name}`);
    return true;
  }
  leaveChannel(user, channelName) {
    const ch = this.channels[channelName];
    if (ch) ch.members.delete(user.username);
    this.notifyPresence(user, false);
  }
  channelAllowed(user, ch) {
    if (ch.isPublic) return true;
    if (ch.acl.allowed.length === 0) return true;
    return ch.acl.allowed.includes(user.username);
  }
  sendLocalMessage(user, channelName, text) {
    const ch = this.ensureChannel(channelName);
    // Route if redirect rule exists
    const target = this.redirects[channelName];
    if (target && federation.network) {
      federation.route(this.name, target, channelName, { from: user.username, content: text });
      ch.addMessage({ fromUser: user.username, text: text, ts: Date.now(), channel: channelName, redirected: true });
      addMessageToUI(user, channelName, text + ' (redirected)');
      this.log(`redirected message from ${user.username} on ${this.name} to ${target}:${channelName}`);
      return;
    }
    const m = new Message(user.username, text, Date.now(), channelName, false, null);
    ch.addMessage({ fromUser: user.username, text, ts: m.ts, channel: channelName });
    addMessageToUI(user, channelName, text);
  }
  receiveNetworkMessage(channelName, messageObj, fromServerName) {
    const ch = this.ensureChannel(channelName);
    const payload = {
      from: fromServerName,
      text: messageObj.content,
      ts: Date.now(),
      channel: channelName
    };
    ch.addMessage(payload);
    this.log(`net-msg on ${channelName} from ${fromServerName}: ${messageObj.content}`);
    // update UI
    refreshUI();
  }
  routeTo(targetServerName, channelName) {
    this.redirects[channelName] = targetServerName;
    this.log(`redirect set: ${channelName} -> ${targetServerName} on ${this.name}`);
  }
  kick(userToKick) { /* for demo: simply log */ this.log(`kick ${userToKick.username} on ${this.name}`); }
  ban(userToBan) { this.log(`ban ${userToBan.username} on ${this.name}`); }
  notifyPresence(user, online) { refreshUI(); }
}

// Federation / Network
class Federation {
  constructor() {
    this.servers = {};
  }
  register(s) {
    this.servers[s.name] = s;
    federation.network = this;
  }
  route(fromServerName, toServerName, channelName, messageObj) {
    const to = this.servers[toServerName];
    if (!to) {
      pushToast('Unknown server ' + toServerName);
      return;
    }
    to.receiveNetworkMessage(channelName, messageObj, fromServerName);
  }
}
const federation = new Federation();

// Global state
const STATE = {
  servers: {}, // name -> Server
  currentUser: null,
  currentServer: null,
  currentChannel: null,
  vibeModules: []
};

// UI helpers
function pushToast(text) {
  const t = document.getElementById('toast');
  t.textContent = text;
  t.style.display = 'block';
  clearTimeout(t._t);
  t._t = setTimeout(() => { t.style.display = 'none'; }, 1800);
}
function addMessageToUI(user, channelName, text) {
  const el = document.createElement('div');
  el.className = 'message';
  const when = new Date().toLocaleTimeString();
  el.innerHTML = `<span class="from">${user.nickname} @ ${when}</span><span>${escapeHtml(text)}</span>`;
  document.getElementById('messages').appendChild(el);
  el.scrollIntoView({ behavior: 'smooth', block: 'end' });
}
function escapeHtml(s) {
  return s.replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'
  }[c]));
}
function updateChatHeader() {
  const h = STATE.currentServer ? STATE.currentServer + ' / ' + (STATE.currentChannel || '') : 'No server connected';
  document.getElementById('headerServerChannel').textContent = h;
}
function refreshUI() {
  // presence indicator
  const connected = !!STATE.currentServer;
  document.getElementById('presenceIndicator').textContent = connected ? 'Online' : 'Offline';
  updateChatHeader();
}
function renderServerList() {
  const list = document.getElementById('serverList');
  list.innerHTML = '';
  Object.values(STATE.servers).forEach(s => {
    const div = document.createElement('div');
    div.className = 'server-item';
    div.innerHTML = `
      <div class="name" style="display:flex; align-items:center; gap:6px;">
        <span class="dot" style="background:${s.name==='Aurora'?'#4ade80':'#888'}"></span>
        <span>${s.name}</span>
      </div>
      <div style="display:flex; gap:6px;">
        <button class="joinServer" data-server="${s.name}" style="padding:6px 10px; border-radius:6px;">Connect</button>
      </div>
    `;
    list.appendChild(div);
  });
  list.querySelectorAll('.joinServer').forEach(btn => {
    btn.addEventListener('click', () => connectToServer(btn.getAttribute('data-server')));
  });
}
function renderChannelsForServer(server) {
  const sel = document.getElementById('channelSelector');
  sel.innerHTML = '';
  Object.values(server.channels).forEach(ch => {
    const opt = document.createElement('option');
    opt.value = ch.name;
    opt.textContent = ch.name;
    sel.appendChild(opt);
  });
}
function ensureUserOnServer(username, serverName) {
  const srv = STATE.servers[serverName];
  if (!srv) return null;
  let user = new User(username);
  user.token = 'tok-' + username + '-' + Date.now().toString(36);
  srv.users[username] = user;
  user.serverName = srv.name;
  user.connected = true;
  STATE.currentUser = user;
  STATE.currentServer = srv.name;
  return user;
}
function connectToServer(serverName) {
  const srv = STATE.servers[serverName];
  if (!srv) {
    pushToast('Server not found');
    return;
  }
  let user = STATE.currentUser;
  if (!user || user.serverName !== serverName) {
    const uname = 'Guest' + Math.floor(Math.random() * 999);
    user = ensureUserOnServer(uname, serverName);
  }
  STATE.currentUser = user;
  STATE.currentServer = serverName;
  // join lobby by default
  srv.joinChannel(user, 'lobby');
  STATE.currentChannel = 'lobby';
  // UI updates
  document.getElementById('tokenDisplay').textContent = user.token;
  renderChannelsForServer(srv);
  renderServerList();
  refreshUI();
  document.getElementById('headerServerChannel').textContent = serverName + ' / lobby';
  addMessageToUI(user, 'lobby', 'Connected to ' + serverName);
  // simulate remote activity
  simulateTypingAndRemoteMessage(srv, user);
}
function simulateTypingAndRemoteMessage(server, user) {
  // After a short delay, simulate another member typing and sending a message
  setTimeout(() => {
    // Show typing indicator
    showTypingIndicator('Astra');
    // After a bit, post a message
    setTimeout(() => {
      const ch = server.ensureChannel('lobby');
      const m = new Message('Astra', 'Welcome to ' + server.name + ' lobby!', Date.now(), 'lobby');
      ch.addMessage({ fromUser: 'Astra', text: m.text, ts: m.ts, channel: 'lobby' });
      addMessageToUI({ nickname: 'Astra', username: 'astra' }, 'lobby', m.text);
      hideTypingIndicator();
    }, 1200);
  }, 1200);
}
function showTypingIndicator(name) {
  const t = document.getElementById('typingIndicator');
  const txt = document.getElementById('typingText');
  txt.textContent = name + ' is typing...';
  t.style.display = 'block';
}
function hideTypingIndicator() {
  const t = document.getElementById('typingIndicator');
  t.style.display = 'none';
}
function escapeRegExp(str) { return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

// Admin & Plugins
class VibeModuleAPI {
  constructor() {
    this.modules = [];
  }
  registerModule(m) {
    this.modules.push(m);
    if (typeof m.onRegister === 'function') m.onRegister();
    return m.api;
  }
  trigger(event, data) {
    this.modules.forEach(m => {
      if (typeof m.handleEvent === 'function') m.handleEvent(event, data);
    });
  }
}
const VIBE = new VibeModuleAPI();

function createPulseModule() {
  return {
    name: 'PulseBeat',
    onRegister() {},
    handleEvent(event, data) {
      if (event === 'messagePost') {
        // simple page glow
        document.body.style.boxShadow = 'inset 0 0 0 0 rgba(107,230,117,.0)';
        document.body.animate([{ boxShadow: 'inset 0 0 0 0 rgba(0,0,0,0)' },
                               { boxShadow: 'inset 0 0 0 12px rgba(107,230,117,.25)' },
                               { boxShadow: 'inset 0 0 0 0 rgba(0,0,0,0)' }], { duration: 800, iterations: 1 });
      }
    }
  };
}
function renderPlugins() {
  const list = document.getElementById('pluginList');
  list.innerHTML = '';
  if (VIBE.modules.length === 0) {
    const p = document.createElement('div');
    p.className = 'user';
    p.textContent = 'No modules installed';
    list.appendChild(p);
  } else {
    VIBE.modules.forEach(md => {
      const d = document.createElement('div');
      d.className = 'user';
      d.textContent = md.name;
      list.appendChild(d);
    });
  }
}
function installPulseModule() {
  const m = createPulseModule();
  VIBE.registerModule(m);
  pushToast('Pulse module installed');
  renderPlugins();
}
function addAudit(line) {
  const div = document.getElementById('auditLog');
  const el = document.createElement('div');
  el.textContent = `[${new Date().toLocaleTimeString()}] ${line}`;
  div.prepend(el);
}
function exportLogs() {
  const exportObj = {};
  Object.values(STATE.servers).forEach(s => {
    exportObj[s.name] = {
      channels: Object.values(s.channels).reduce((acc, ch) => {
        acc[ch.name] = ch.messages;
        return acc;
      }, {})
    };
  });
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'vibe_logs.json';
  a.click();
  URL.revokeObjectURL(a.href);
}
function importLogs(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      // merge into STATE
      Object.entries(data).forEach(([srvName, srvData]) => {
        let srv = STATE.servers[srvName];
        if (!srv) {
          srv = new Server(srvName);
          STATE.servers[srvName] = srv;
        }
        Object.entries(srvData.channels || {}).forEach(([chName, msgs]) => {
          const ch = srv.ensureChannel(chName);
          msgs.forEach(m => ch.addMessage({
            fromUser: m.fromUser || 'system',
            text: m.text || '',
            ts: m.ts || Date.now(),
            channel: chName
          }));
        });
      });
      renderServerList();
      pushToast('Logs imported');
      refreshUI();
    } catch (err) {
      pushToast('Invalid log file');
    }
  };
  reader.readAsText(file);
}

// Events
document.getElementById('btnNewServer').addEventListener('click', () => {
  const name = document.getElementById('adminServerName').value.trim();
  if (!name) return;
  if (STATE.servers[name]) { pushToast('Server already exists'); return; }
  const srv = new Server(name);
  srv.createChannel('lobby', true);
  STATE.servers[name] = srv;
  federation.register(srv);
  addAudit('Admin: created server ' + name);
  renderServerList();
  renderChannelsForServer(srv);
  document.getElementById('adminServerName').value = '';
});
document.getElementById('btnCreateServer').addEventListener('click', () => {
  document.getElementById('btnNewServer').click();
});
document.getElementById('btnAddPulse').addEventListener('click', () => {
  installPulseModule();
});
document.getElementById('btnInstallPulse').addEventListener('click', () => {
  installPulseModule();
});
document.getElementById('btnJoinChannel').addEventListener('click', () => {
  const user = STATE.currentUser;
  const srvName = STATE.currentServer;
  if (!user || !srvName) { pushToast('Connect to a server first'); return; }
  const srv = STATE.servers[srvName];
  const chName = document.getElementById('channelSelector').value;
  if (!chName) { pushToast('Select a channel'); return; }
  srv.joinChannel(user, chName);
  STATE.currentChannel = chName;
  document.getElementById('headerServerChannel').textContent = srvName + ' / ' + chName;
  renderChannelsForServer(srv);
  refreshUI();
});
document.getElementById('btnSend').addEventListener('click', () => {
  const user = STATE.currentUser;
  if (!user || !STATE.currentServer) {
    pushToast('Not connected to a server');
    return;
  }
  const srv = STATE.servers[STATE.currentServer];
  const channel = STATE.currentChannel || 'lobby';
  const text = document.getElementById('inputBox').value.trim();
  if (!text) return;
  if (text.startsWith('/')) {
    handleCommand(user, srv, text);
  } else {
    srv.sendLocalMessage(user, channel, text);
    VIBE.trigger('messagePost', { server: srv.name, channel, user, text });
  }
  document.getElementById('inputBox').value = '';
  // simple confetti on message
  if (!document.body.classList.contains('no-animations')) spawnConfetti();
});
document.getElementById('inputBox').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') document.getElementById('btnSend').click();
});

// Channel & command handling
function handleCommand(user, server, raw) {
  const parts = raw.slice(1).split(' ');
  const cmd = parts[0];
  const arg = parts.slice(1).join(' ');
  switch (cmd) {
    case 'join': {
      const ch = arg || 'lobby';
      server.joinChannel(user, ch);
      STATE.currentChannel = ch;
      document.getElementById('headerServerChannel').textContent = server.name + ' / ' + ch;
      renderChannelsForServer(server);
      addMessageToUI(user, ch, '(joined channel)');
      break;
    }
    case 'msg': {
      const [target, ...rest] = arg.split(' ');
      const text = rest.join(' ');
      if (!target || !text) { pushToast('Usage: /msg username message'); break; }
      const tUser = server.users[target];
      if (!tUser) { pushToast('User not found on this server'); break; }
      addMessageToUI(user, 'private', `(to ${target}) ${text}`);
      addMessageToUI(tUser, 'private', `(from ${user.username}) ${text}`);
      VIBE.trigger('messagePost', { server: server.name, channel: 'private', user, text });
      break;
    }
    case 'nick': {
      const newNick = arg || user.username;
      server.setNick(user, newNick);
      refreshUI();
      break;
    }
    case 'who': {
      const chName = STATE.currentChannel || 'lobby';
      const ch = server.channels[chName] || server.ensureChannel(chName);
      const names = Array.from(ch.members);
      addMessageToUI(user, chName, 'Presence: ' + names.join(', '));
      break;
    }
    case 'redirect': {
      const [target, ch] = arg.split(' ');
      if (!target) { pushToast('Usage: /redirect server [channel]'); break; }
      const channelName = ch || STATE.currentChannel || 'lobby';
      server.routeTo(target, channelName);
      addMessageToUI(user, channelName, `Redirecting channel ${channelName} to ${target}`);
      break;
    }
    case 'kick': {
      const target = arg;
      if (!target) { pushToast('Usage: /kick username'); break; }
      const tUser = server.users[target];
      if (!tUser) { pushToast('User not found on this server'); break; }
      server.kick(tUser);
      addMessageToUI(user, STATE.currentChannel, `Kicked ${target}`);
      break;
    }
    case 'ban': {
      const target = arg;
      if (!target) { pushToast('Usage: /ban username'); break; }
      const tUser = server.users[target];
      if (!tUser) { pushToast('User not found on this server'); break; }
      server.ban(tUser);
      addMessageToUI(user, STATE.currentChannel, `Banned ${target}`);
      break;
    }
    default:
      pushToast('Unknown command');
  }
}

// Confetti (simple lightweight)
function spawnConfetti() {
  const colors = ['#f87171', '#f59e0b', '#34d399', '#60a5fa', '#a78bfa', '#f472b6'];
  const count = 24;
  for (let i = 0; i < count; i++) {
    const div = document.createElement('div');
    div.className = 'confetti-piece';
    div.style.left = Math.random() * 100 + 'vw';
    div.style.top = '0px';
    div.style.background = colors[Math.floor(Math.random() * colors.length)];
    div.style.transform = 'rotate(' + (Math.random() * 360) + 'deg)';
    div.style.animationDuration = (1.2 + Math.random() * 1.5) + 's';
    document.body.appendChild(div);
    // remove after animation ends
    div.addEventListener('animationend', () => div.remove());
  }
}

// Import / Export
document.getElementById('btnExport').addEventListener('click', exportLogs);
document.getElementById('btnImport').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (file) importLogs(file);
  };
  input.click();
});

// Init/demo
function ensureDemoBase() {
  // Create two demo servers and register to federation
  const s1 = new Server('Aurora');
  const s2 = new Server('Zephyr');
  s1.createChannel('lobby', true);
  s2.createChannel('lobby', true);
  STATE.servers[s1.name] = s1;
  STATE.servers[s2.name] = s2;
  federation.register(s1);
  federation.register(s2);
}
function resetDemo() {
  STATE.servers = {};
  STATE.currentUser = null;
  STATE.currentServer = null;
  STATE.currentChannel = null;
  document.getElementById('messages').innerHTML = '';
  document.getElementById('tokenDisplay').textContent = 'Not connected';
  updateChatHeader();
  renderServerList();
  refreshUI();
}
document.getElementById('btnResetDemo').addEventListener('click', () => {
  resetDemo();
  ensureDemoBase();
  renderServerList();
  pushToast('Demo reset');
});
document.getElementById('animToggle').addEventListener('click', () => {
  const btn = document.getElementById('animToggle');
  btn.classList.toggle('on');
  if (btn.classList.contains('on')) {
    document.body.classList.remove('no-animations');
    btn.setAttribute('aria-checked', 'true');
  } else {
    document.body.classList.add('no-animations');
    btn.setAttribute('aria-checked', 'false');
  }
});

// Initial bootstrap
function bootstrap() {
  ensureDemoBase();
  renderServerList();
  renderPlugins();
  // Auto-connect to Aurora for demo
  connectToServer('Aurora');
  addAudit('System ready: Expanded VibeIRC demo');
}
window.addEventListener('DOMContentLoaded', bootstrap);
  </script>

  <!-- Basic helpers for a11y -->
  <div style="position: fixed; bottom: 8px; right: 8px; font-size: 11px; color:#88a; opacity:.6;">
    Keyboard: Enter to send | /join, /nick, /msg, /who, /redirect
  </div>
</body>
</html>