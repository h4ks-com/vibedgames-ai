<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BallPlatformer Deluxe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: #0a0a0a;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    canvas { display: block; width: 100%; height: 100%; background: #0a0a0a; }

    /* Top HUD */
    #hud {
      position: absolute; top: 8px; left: 8px; color: white; font-weight: bold; z-index: 3;
      text-shadow: 0 0 6px rgba(0,0,0,.6);
      display: flex; gap: 12px; align-items: center;
    }
    .pill {
      background: rgba(0,0,0,.5); padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.2);
      font-size: 12px;
    }

    /* Overlay panels */
    #overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 5; }
    #overlay.hidden { display: none; }
    .panel {
      background: rgba(20,20,20,.92); border: 2px solid #555; padding: 20px; border-radius: 12px; text-align: center;
      min-width: 320px; max-width: 90vw; color: #fff;
      box-shadow: 0 20px 60px rgba(0,0,0,.5);
    }
    .title { font-size: 28px; margin-bottom: 6px; }
    .muted { color: #d9d9d9; opacity: .95; }
    .row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 8px; }
    .btn { display: inline-block; padding: 10px 14px; margin: 6px; background: #1e90ff; color: #fff; border-radius: 6px; cursor: pointer; user-select: none;
      transition: transform .1s; border: 1px solid rgba(255,255,255,.25);
    }
    .btn:active { transform: scale(0.98); }
    .section { margin: 12px 0; text-align: left; }

    /* Level select grid */
    #levelGrid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px; justify-items: center; margin-top: 6px; }
    .levelBtn { width: 78px; height: 40px; display: flex; align-items: center; justify-content: center;
      background: #2b2b2b; border: 1px solid #555; color: #fff; border-radius: 6px; cursor: pointer;
    }
    .levelBtn.locked { opacity: .4; cursor: default; }
    .levelBtn.locked:hover { transform: none; }

    /* On-screen controls (mobile) */
    #mobileControls {
      position: absolute; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 14px; align-items: center; z-index: 4;
      user-select: none;
    }
    .pad {
      width: 120px; height: 120px; background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.25); border-radius: 14px;
      display: grid; place-items: center;
      touch-action: none; position: relative;
    }
    .padBtn {
      width: 48px; height: 48px; border-radius: 50%; background: rgba(255,255,255,.12);
      display: grid; place-items: center; color: #fff; font-weight: bold; cursor: pointer;
      user-select: none; border: 1px solid rgba(255,255,255,.25);
      transition: transform .1s;
    }
    .padBtn:active { transform: scale(0.92); }

    .jumpBtn {
      width: 60px; height: 60px; border-radius: 50%; background: #ff6b6b; color: #fff;
      display: grid; place-items: center; font-size: 20px; font-weight: bold; cursor: pointer;
      border: 1px solid rgba(255,255,255,.5);
      box-shadow: 0 6px 20px rgba(255,75,75,.5);
      user-select: none;
    }

    /* Floating text for pickups / events */
    .floating {
      position: absolute; pointer-events: none; color: #ffd166; font-weight: bold; font-size: 14px;
      text-shadow: 0 2px 6px rgba(0,0,0,.4);
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      from { transform: translateY(0); opacity: 1; }
      to { transform: translateY(-32px); opacity: 0; }
    }

    /* Simple settings drawer (advanced options) */
    #settingsPanel { text-align: left; }
    .sliderRow { display: grid; grid-template-columns: 1fr 60px; gap: 8px; align-items: center; }
    input[type="range"] { width: 100%; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <span class="pill" id="hudLevel">Level: 1</span>
    <span class="pill" id="hudScore">Score: 0</span>
    <span class="pill" id="hudCoins">Coins: 0</span>
    <span class="pill" id="hudBest">Best: 0</span>
  </div>

  <div id="overlay" class="">
    <div class="panel" id="startPanel">
      <div class="title">BallPlatformer Deluxe</div>
      <div class="muted" style="margin-bottom:8px;">Roll, jump and collect coins across levels. Advanced mode with particles, trails, and parallax.</div>
      <div class="row">
        <button class="btn" id="startBtn">Play</button>
        <button class="btn" id="levelSelectBtn">Level Select</button>
        <button class="btn" id="settingsBtn">Settings</button>
      </div>
    </div>

    <div class="panel" id="deathPanel" style="display:none;">
      <div class="title">You Died</div>
      <div class="muted" style="margin-bottom:12px;">Try again or choose another level.</div>
      <div class="row">
        <button class="btn" id="restartBtn">Restart Level</button>
        <button class="btn" id="levelSelectFromDeathBtn">Level Select</button>
      </div>
    </div>

    <div class="panel" id="levelCompletePanel" style="display:none;">
      <div class="title">Level Complete!</div>
      <div class="muted" style="margin-bottom:8px;">Progress saved. Coins collected and next level unlocked.</div>
      <div class="row">
        <button class="btn" id="continueBtn">Continue</button>
        <button class="btn" id="levelSelectFromCompleteBtn">Level Select</button>
      </div>
      <div id="stars" style="margin-top:8px; height:20px;"></div>
    </div>

    <div class="panel" id="pausePanel" style="display:none;">
      <div class="title">Paused</div>
      <div class="muted" style="margin-bottom:8px;">Press P or tap Resume.</div>
      <div class="row">
        <button class="btn" id="resumeBtn">Resume</button>
        <button class="btn" id="levelSelectFromPauseBtn">Level Select</button>
      </div>
    </div>

    <div class="panel" id="levelSelectPanel" style="display:none;">
      <div class="title" style="margin-bottom:6px;">Level Select</div>
      <div class="muted" style="margin-bottom:10px;">Choose a level to play</div>
      <div id="levelGrid"></div>
      <div style="margin-top:8px;">
        <button class="btn" id="backFromLevelSelect">Back</button>
      </div>
    </div>

    <div class="panel" id="settingsPanel" style="display:none;">
      <div class="title" style="margin-bottom:6px;">Advanced Settings</div>
      <div class="muted" style="margin-bottom:8px;">Tune gravity, friction, and visuals. Changes apply live.</div>

      <div class="section">
        <div>Gravity</div>
        <div class="sliderRow">
          <input type="range" id="gravSlider" min="400" max="2600" value="1600" step="10" />
          <span id="gravVal">1600</span>
        </div>
      </div>

      <div class="section">
        <div>Jump Height</div>
        <div class="sliderRow">
          <input type="range" id="jumpSlider" min="-900" max="-200" value="-520" step="10" />
          <span id="jumpVal">-520</span>
        </div>
      </div>

      <div class="section">
        <div>Friction (Ground)</div>
        <div class="sliderRow">
          <input type="range" id="fricSlider" min="0.85" max="0.98" value="0.92" step="0.01" />
          <span id="fricVal">0.92</span>
        </div>
      </div>

      <div class="section">
        <div>Trail Enable</div>
        <div class="row">
          <button class="btn" id="trailToggle">On</button>
        </div>
      </div>

      <div class="section">
        <div>Music</div>
        <div class="row">
          <button class="btn" id="musicToggle">On</button>
        </div>
      </div>

      <div class="section">
        <div>SFX</div>
        <div class="row">
          <button class="btn" id="sfxToggle">On</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <button class="btn" id="closeSettings">Close</button>
      </div>
    </div>
  </div>

  <!-- Mobile controls -->
  <div id="mobileControls" aria-label="mobile controls">
    <div class="pad" id="leftPad" title="Left">
      <div class="padBtn" id="leftBtn">←</div>
    </div>
    <div class="pad" id="rightPad" title="Right" style="transform: scaleX(-1);">
      <div class="padBtn" id="rightBtn">→</div>
    </div>
    <div class="jumpBtn" id="jumpBtn" title="Jump">↑</div>
  </div>

  <script>
    // BallPlatformer Deluxe - Vanilla JS enhanced
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = window.innerWidth, H = window.innerHeight;
    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
    }
    window.addEventListener('resize', resize);
    resize();

    // Audio: simple toggleable music and sfx
    let audioCtx = null;
    let sfxOn = true;
    let musicOn = true;
    function ensureAudio() {
      if (!audioCtx) {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (AudioCtx) audioCtx = new AudioCtx();
      }
    }
    function playJumpTone() {
      ensureAudio();
      if (!audioCtx || !sfxOn) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.frequency.value = 520;
      g.gain.value = 0.15;
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'triangle';
      osc.start(t); osc.frequency.exponentialRampToValueAtTime(0.001, t + 0.25);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);
      osc.stop(t + 0.3);
    }
    function toggleMusic(on) { musicOn = on; }

    // Game state
    const GRAVITY_BASE = 1600;
    const ACC_BASE = 1800;
    const MAXVX_BASE = 260;
    const JUMP_VY_BASE = -520;
    let gravity = GRAVITY_BASE;
    let ACC = ACC_BASE;
    let MAXVX = MAXVX_BASE;
    let JUMP_VY = JUMP_VY_BASE;
    let friction = 0.92;
    let trailsEnabled = true;

    // User input
    const keys = { left:false, right:false, up:false };
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
      if (e.code === 'Escape') togglePause();
      if (e.code === 'KeyP') togglePause();
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    });

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    if (leftBtn) {
      leftBtn.addEventListener('mousedown', ()=>{ keys.left = true; });
      leftBtn.addEventListener('mouseup', ()=>{ keys.left = false; });
      leftBtn.addEventListener('touchstart', ()=>{ keys.left = true; });
      leftBtn.addEventListener('touchend', ()=>{ keys.left = false; });
    }
    if (rightBtn) {
      rightBtn.addEventListener('mousedown', ()=>{ keys.right = true; });
      rightBtn.addEventListener('mouseup', ()=>{ keys.right = false; });
      rightBtn.addEventListener('touchstart', ()=>{ keys.right = true; });
      rightBtn.addEventListener('touchend', ()=>{ keys.right = false; });
    }
    if (jumpBtn) {
      jumpBtn.addEventListener('mousedown', ()=>{ keys.up = true; });
      jumpBtn.addEventListener('mouseup', ()=>{ keys.up = false; });
      jumpBtn.addEventListener('touchstart', ()=>{ keys.up = true; });
      jumpBtn.addEventListener('touchend', ()=>{ keys.up = false; });
    }

    // World / Level data
    const levels = [
      {
        name: "Sunrise",
        width: 4200, height: 600,
        platforms: [
          {x:0, y:520, w:1800, h:40},
          {x:1200, y:420, w:600, h:40},
          {x:2100, y:360, w:500, h:40},
          {x:2700, y:500, w:400, h:40},
          {x:3600, y:480, w:600, h:40}
        ],
        endZone: {x:3950, y:520, w:60, h:60},
        enemies: [
          {x:800, y:500, w:34, h:34, minX:700, maxX:1100, speed:60}
        ],
        coins: [
          {x:650, y:480, r:8, collected:false},
          {x:1500, y:420, r:8, collected:false},
          {x:2300, y:320, r:8, collected:false}
        ],
        bg: '#1a1a1a'
      },
      {
        name: "Midnight",
        width: 5400, height: 600,
        platforms: [
          {x:0, y:520, w:2000, h:40},
          {x:1800, y:420, w:240, h:40},
          {x:2100, y:360, w:260, h:40},
          {x:2400, y:420, w:400, h:40},
          {x:3100, y:520, w:2000, h:40},
          {x:4100, y:460, w:280, h:40}
        ],
        endZone: {x:5150, y:520, w:60, h:60},
        enemies: [
          {x:1500, y:500, w:34, h:34, minX:1400, maxX:1700, speed:80},
          {x:3200, y:480, w:34, h:34, minX:3000, maxX:3600, speed:60}
        ],
        coins: [
          {x:420, y:490, r:8, collected:false},
          {x:1500, y:480, r:8, collected:false},
          {x:3200, y:450, r:8, collected:false}
        ],
        bg: '#0b0b0b'
      },
      {
        name: "Nebula",
        width: 6400, height: 600,
        platforms: [
          {x:0, y:520, w:2500, h:40},
          {x:2600, y:470, w:300, h:40},
          {x:3000, y:420, w:300, h:40},
          {x:3500, y:470, w:350, h:40},
          {x:4200, y:520, w:1000, h:40},
          {x:5200, y:420, w:300, h:40}
        ],
        endZone: {x:6100, y:520, w:60, h:60},
        enemies: [
          {x:500, y:500, w:34, h:34, minX:100, maxX:900, speed:90},
          {x:4600, y:500, w:34, h:34, minX:4400, maxX:5200, speed:70}
        ],
        coins: [
          {x:600, y:480, r:8, collected:false},
          {x:5200, y:460, r:8, collected:false}
        ],
        bg: '#141021'
      }
    ];

    // World state per level
    let currentLevel = 0;
    let worldWidth = 0;
    let worldHeight = 0;
    let platforms = [];
    let enemies = [];
    let coins = []; // {x, y, r, collected}
    let endZone = null;

    // Player
    const player = { x: 60, y: 0, vx: 0, vy: 0, r: 22, onGround: false, alive: true, color: '#fff' };
    // Trails
    const trails = [];
    // Particles
    const particles = [];
    // Score / coins
    let score = 0;
    let coinsCollected = 0;
    // HUD elements
    const hudLevel = document.getElementById('hudLevel');
    const hudScore = document.getElementById('hudScore');
    const hudCoins = document.getElementById('hudCoins');
    const hudBest = document.getElementById('hudBest');
    function updateHUD() {
      document.getElementById('hudLevel').textContent = 'Level: ' + (currentLevel + 1);
      hudScore.textContent = 'Score: ' + score;
      hudCoins.textContent = 'Coins: ' + coinsCollected;
      const best = parseInt(localStorage.getItem('bestScore') || '0', 10);
      hudBest.textContent = 'Best: ' + best;
    }

    // Transition / overlay refs
    const overlay = document.getElementById('overlay');
    const startPanel = document.getElementById('startPanel');
    const deathPanel = document.getElementById('deathPanel');
    const levelCompletePanel = document.getElementById('levelCompletePanel');
    const pausePanel = document.getElementById('pausePanel');
    const levelSelectPanel = document.getElementById('levelSelectPanel');
    const levelGridEl = document.getElementById('levelGrid');
    const backFromLevelSelect = document.getElementById('backFromLevelSelect');
    const settingsPanel = document.getElementById('settingsPanel');
    const startBtn = document.getElementById('startBtn');
    const levelSelectBtn = document.getElementById('levelSelectBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const restartBtn = document.getElementById('restartBtn');
    const levelSelectFromDeathBtn = document.getElementById('levelSelectFromDeathBtn');
    const continueBtn = document.getElementById('continueBtn');
    const levelSelectFromCompleteBtn = document.getElementById('levelSelectFromCompleteBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const levelSelectFromPauseBtn = document.getElementById('levelSelectFromPauseBtn');
    const closeSettings = document.getElementById('closeSettings');
    const gravSlider = document.getElementById('gravSlider');
    const gravVal = document.getElementById('gravVal');
    const jumpSlider = document.getElementById('jumpSlider');
    const jumpVal = document.getElementById('jumpVal');
    const fricSlider = document.getElementById('fricSlider');
    const fricVal = document.getElementById('fricVal');
    const trailToggle = document.getElementById('trailToggle');
    const musicToggle = document.getElementById('musicToggle');
    const sfxToggle = document.getElementById('sfxToggle');

    function showOverlay(panel) {
      overlay.style.display = '';
      startPanel.style.display = 'none';
      deathPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      pausePanel.style.display = 'none';
      levelSelectPanel.style.display = 'none';
      settingsPanel.style.display = 'none';
      if (panel) panel.style.display = '';
      overlay.style.pointerEvents = 'auto';
    }
    function hideOverlay() { overlay.style.display = 'none'; }

    // Level loading
    function loadLevel(index) {
      currentLevel = Math.max(0, Math.min(index, levels.length - 1));
      const L = levels[currentLevel];
      worldWidth = L.width;
      worldHeight = L.height;
      platforms = L.platforms.map(p => ({...p}));
      endZone = L.endZone ? {...L.endZone} : null;
      enemies = L.enemies.map(e => ({
        x: e.x, y: e.y, w: e.w, h: e.h,
        minX: e.minX, maxX: e.maxX, speed: e.speed, dir: 1
      }));
      coins = L.coins.map(c => ({...c, x: c.x, y: c.y, r: c.r}));
      coinsCollected = 0;
      score = 0;
      player.x = 60; player.y = 0;
      player.vx = 0; player.vy = 0; player.alive = true; player.onGround = false;
      trails.length = 0;
      particles.length = 0;
      camShake = 0;
      updateHUD();
      // apply any per-level unlock progress
      overlappedBestCheck();
    }

    // Level select grid
    function populateLevelSelect() {
      levelGridEl.innerHTML = '';
      for (let i = 0; i < levels.length; i++) {
        const unlocked = i <= (parseInt(localStorage.getItem('levelUnlocked') || '0', 10) );
        const btn = document.createElement('div');
        btn.className = 'levelBtn' + (unlocked ? '' : ' locked');
        btn.textContent = (i + 1);
        btn.style.opacity = unlocked ? '1' : '0.4';
        btn.style.pointerEvents = unlocked ? 'auto' : 'none';
        btn.onclick = () => {
          hideOverlay();
          loadLevel(i);
          requestAnimationFrame(loop);
          updateHUD();
        };
        levelGridEl.appendChild(btn);
      }
    }

    function showPause() {
      if (!paused) {
        paused = true;
        showOverlay(pausePanel);
      }
    }
    function togglePause() {
      if (!paused) showPause();
      else { paused = false; hideOverlay(); lastTime = performance.now(); requestAnimationFrame(loop); }
    }
    function overlappedBestCheck() {
      // ensure best score tracking
      const best = parseInt(localStorage.getItem('bestScore') || '0', 10);
      if (score > best) localStorage.setItem('bestScore', String(score));
      updateHUD();
    }

    // Floating text helper
    function spawnFloating(x, y, text, color = '#ffd166') {
      const el = document.createElement('div');
      el.className = 'floating';
      el.style.left = (x) + 'px';
      el.style.top = (y) + 'px';
      el.textContent = text;
      document.body.appendChild(el);
      // animate removal after timeout
      setTimeout(() => { el.remove(); }, 1100);
    }

    // Collision helpers
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
      const closestX = clamp(cx, rx, rx + rw);
      const closestY = clamp(cy, ry, ry + rh);
      const dx = cx - closestX, dy = cy - closestY;
      return (dx*dx + dy*dy) <= (r*r);
    }

    // Update function for coins / pickups
    function checkCoinCollisions() {
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        if (c.collected) continue;
        if (circleRectCollision(player.x, player.y, player.r, c.x - c.r, c.y - c.r, c.r*2, c.r*2)) {
          c.collected = true;
          coinsCollected += 1;
          score += 50;
          spawnFloating(player.x, player.y - 20, '+50', '#ffd700');
          if (sfxOn) playCoinSound();
        }
      }
    }

    // Coin sound
    function playCoinSound() {
      // reuse jump tone as coin ping
      ensureAudio();
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.frequency.value = 380;
      g.gain.value = 0.12;
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'triangle';
      osc.start(t); osc.frequency.exponentialRampToValueAtTime(0.001, t + 0.15);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.15);
      osc.stop(t + 0.2);
    }

    // Particles for death / effects
    function spawnParticles(px, py, count = 40, color = 'orange') {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = 60 + Math.random() * 180;
        particles.push({ x: px, y: py, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 1.2 + Math.random()*0.6, color });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i,1); continue; }
        p.vy += 300 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    // Level complete
    function onLevelComplete() {
      // unlock next level
      const next = currentLevel + 1;
      const unlocked = parseInt(localStorage.getItem('levelUnlocked') || '0', 10);
      if (next > unlocked) localStorage.setItem('levelUnlocked', String(next));
      // show stars / score
      showOverlay(levelCompletePanel);
      // simple star rating: based on score
      const stars = Math.min(3, Math.floor(score / 150) + (coinsCollected >= 3 ? 1 : 0));
      const starsEl = document.getElementById('stars');
      starsEl.innerHTML = '';
      for (let s = 0; s < 3; s++) {
        const star = document.createElement('span');
        star.textContent = '★';
        star.style.color = s < stars ? '#ffd700' : '#555';
        star.style.fontSize = '20px';
        star.style.marginRight = '6px';
        starsEl.appendChild(star);
      }
    }

    // Rendering (including parallax)
    let camX = 0;
    let camShake = 0;
    function renderWorld() {
      // clear
      ctx.clearRect(0,0,W,H);

      // camera transform
      const shakeX = camShake * (Math.random()*2 - 1);
      ctx.save();
      ctx.translate(-camX + shakeX, 0);

      // Background parallax layers (mountains / stars)
      drawParallaxBackground(camX);

      // Platforms
      ctx.fillStyle = '#7a4a2f';
      for (const p of platforms) ctx.fillRect(p.x, p.y, p.w, p.h);

      // End zone
      if (endZone) {
        ctx.fillStyle = 'rgba(0,200,0,.6)';
        ctx.fillRect(endZone.x, endZone.y, endZone.w, endZone.h);
      }

      // Coins
      for (const c of coins) if (!c.collected) {
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
        ctx.fill();
        // small sparkle
        ctx.fillStyle = 'rgba(255,255,255,.8)';
        ctx.fillRect(c.x - 1, c.y - c.r - 3, 2, 3);
      }

      // Enemies
      for (const e of enemies) {
        ctx.fillStyle = '#e23c3c';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fillRect(e.x, e.y + e.h, e.w, 6);
      }

      // Player with glow
      const glow = ctx.createRadialGradient(player.x, player.y, 2, player.x, player.y, player.r * 1.5);
      glow.addColorStop(0, 'rgba(255,255,255,.9)');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();

      // Trail
      if (trails.length && trailsEnabled) {
        for (let i = 0; i < trails.length; i++) {
          const t = trails[i];
          const alpha = (i / trails.length) * 0.6;
          ctx.fillStyle = `rgba(0, 180, 255, ${alpha})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // Player
      ctx.fillStyle = player.alive ? '#ffffff' : '#888';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();

      // Particles
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillRect(p.x, p.y, 2, 2);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
      // Overlay transition
      if (inTransition) {
        ctx.save();
        ctx.globalAlpha = transitionAlpha;
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }
    }

    // Parallax background drawing
    function drawParallaxBackground(camX) {
      // distant gradient
      const g = ctx.createLinearGradient(0,0, worldWidth, worldHeight);
      g.addColorStop(0, '#0a0a1a');
      g.addColorStop(1, '#050518');
      ctx.fillStyle = g;
      ctx.fillRect(0,0, worldWidth, worldHeight);

      // simple mountains layer
      ctx.fillStyle = '#1e1e1e';
      const layer1 = camX * 0.25;
      for (let i = -200; i < worldWidth; i += 250) {
        const x = i - (layer1 % 250);
        ctx.beginPath();
        ctx.moveTo(x, 260);
        ctx.lineTo(x + 120, 120);
        ctx.lineTo(x + 240, 260);
        ctx.closePath();
        ctx.fill();
      }

      // starry/glow dots
      ctx.fillStyle = 'rgba(255,255,255,.05)';
      for (let s = 0; s < 80; s++) {
        const ox = ((s * 97) % worldWidth) - camX;
        const oy = (s * 53) % worldHeight;
        if (ox < 0 || ox > worldWidth) continue;
        ctx.fillRect(ox, oy, 2, 2);
      }
    }

    // Main loop
    let lastTime = performance.now();
    let paused = false;
    let started = false;
    let inTransition = true;
    let transitionAlpha = 1;

    function initGame() {
      loadLevel(0);
      paused = false;
      started = true;
      inTransition = true;
      transitionAlpha = 1;
      requestAnimationFrame(loop);
    }

    // Load level function
    function loadLevel(index) {
      currentLevel = Math.max(0, Math.min(index, levels.length - 1));
      const L = levels[currentLevel];
      worldWidth = L.width;
      worldHeight = L.height;
      platforms = L.platforms.map(p => ({...p}));
      endZone = L.endZone ? {...L.endZone} : null;
      enemies = L.enemies.map(e => ({
        x: e.x, y: e.y, w: e.w, h: e.h,
        minX: e.minX, maxX: e.maxX, speed: e.speed, dir: 1
      }));
      coins = L.coins.map(c => ({...c}));
      coinsCollected = 0; score = 0;
      // reset player
      player.x = 60; player.y = 0; player.vx = 0; player.vy = 0; player.alive = true; player.onGround = false;
      trails.length = 0;
      particles.length = 0;
      camShake = 0;
      updateHUD();
    }

    // UI button handlers
    startBtn.onclick = () => {
      hideOverlay();
      initGame();
    };
    levelSelectBtn.onclick = () => {
      populateLevelSelect();
      showOverlay(levelSelectPanel);
    };
    restartBtn.onclick = () => {
      hideOverlay();
      loadLevel(currentLevel);
      requestAnimationFrame(loop);
    };
    levelSelectFromDeathBtn.onclick = () => { populateLevelSelect(); showOverlay(levelSelectPanel); };
    continueBtn.onclick = () => {
      hideOverlay();
      const next = currentLevel + 1;
      if (next < levels.length) loadLevel(next);
      else loadLevel(0);
      requestAnimationFrame(loop);
    };
    levelSelectFromCompleteBtn.onclick = () => { populateLevelSelect(); showOverlay(levelSelectPanel); };
    resumeBtn.onclick = () => { paused = false; hideOverlay(); lastTime = performance.now(); requestAnimationFrame(loop); };
    levelSelectFromPauseBtn.onclick = () => { populateLevelSelect(); showOverlay(levelSelectPanel); };
    backFromLevelSelect.onclick = () => { hideOverlay(); };

    // Settings panel
    const gravSliderChange = () => { gravity = parseFloat(gravSlider.value); gravVal.textContent = gravSlider.value; };
    gravSlider.addEventListener('input', gravSliderChange);
    gravVal.textContent = gravSlider.value;
    jumpSlider.addEventListener('input', () => { JUMP_VY = parseFloat(jumpSlider.value); jumpVal.textContent = jumpSlider.value; });
    jumpVal.textContent = jumpSlider.value;
    fricSlider.addEventListener('input', () => { friction = parseFloat(fricSlider.value); fricVal.textContent = fricSlider.value; });
    fricVal.textContent = fricSlider.value;
    trailToggle.addEventListener('click', () => { trailsEnabled = !trailsEnabled; trailToggle.textContent = trailsEnabled ? 'On' : 'Off'; });
    musicToggle.addEventListener('click', () => { sfxOn = !sfxOn; musicToggle.textContent = 'Music ' + (sfxOn ? 'On' : 'Off'); });
    sfxToggle.addEventListener('click', () => { sfxOn = !sfxOn; sfxToggle.textContent = 'SFX ' + (sfxOn ? 'On' : 'Off'); });

    closeSettings.addEventListener('click', () => {
      hideOverlay();
    });
    document.getElementById('settingsBtn').onclick = () => {
      // open settings panel
      showOverlay(settingsPanel);
      // sync display
      gravSlider.value = gravity;
      gravVal.textContent = gravity;
      jumpSlider.value = JUMP_VY;
      jumpVal.textContent = JUMP_VY;
      fricSlider.value = friction;
      fricVal.textContent = friction;
      trailToggle.textContent = trailsEnabled ? 'On' : 'Off';
      musicToggle.textContent = 'Music ' + (musicOn ? 'On' : 'Off');
      sfxToggle.textContent = 'SFX ' + (sfxOn ? 'On' : 'Off');
    };
    // The settings panel is re-used as a panel
    // We'll reuse the existing panel by showing it
    // Overwrite showOverlay to also handle settings panel
    // Simple approach: override showOverlay for Settings:
    function showOverlaySettings() {
      overlay.style.display = '';
      // hide all
      startPanel.style.display = 'none';
      deathPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      pausePanel.style.display = 'none';
      levelSelectPanel.style.display = 'none';
      settingsPanel.style.display = '';
    }

    // Replace click to show settings
    document.getElementById('settingsBtn').onclick = () => {
      showOverlaySettings();
    };
    // Start UI: Level grid
    backFromLevelSelect.addEventListener('click', () => hideOverlay());

    // Init level unlock data
    function initProgress() {
      const saved = parseInt(localStorage.getItem('levelUnlocked') || '0', 10);
      if (isNaN(saved)) localStorage.setItem('levelUnlocked', '0');
      updateHUD();
    }

    // Game loop
    let lastTime = performance.now();
    let paused = false;
    let started = false;
    let inTransition = true;
    let transitionAlpha = 1;
    let currentLevel = 0;
    let camXBase = 0;

    function loop(now) {
      if (!started) return;
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      if (!paused) {
        // transition
        if (inTransition) {
          transitionAlpha -= dt * 2.0;
          if (transitionAlpha <= 0) { transitionAlpha = 0; inTransition = false; }
        }

        // physics
        let ax = 0;
        if (keys.left) ax -= ACC;
        if (keys.right) ax += ACC;
        player.vx += ax * dt;
        if (player.onGround && Math.abs(player.vx) < 1) player.vx = 0;
        if (player.onGround && !keys.left && !keys.right) player.vx *= friction;
        player.vx = clamp(player.vx, -MAXVX, MAXVX);

        // Jump
        if (keys.up && player.onGround && player.alive) {
          player.vy = JUMP_VY;
          player.onGround = false;
          playJumpTone();
        }

        // gravity
        player.vy += gravity * dt;

        // Integrate
        let nx = player.x + player.vx * dt;
        let ny = player.y + player.vy * dt;

        // collide with platforms
        let onGround = false;
        for (const p of platforms) {
          if (circleRectCollision(nx, ny, player.r, p.x, p.y, p.w, p.h)) {
            const closestX = Math.max(p.x, Math.min(nx, p.x + p.w));
            const closestY = Math.max(p.y, Math.min(ny, p.y + p.h));
            const dx = nx - closestX;
            const dy = ny - closestY;
            const dist = Math.max(1e-4, Math.hypot(dx, dy));
            const nxp = dx / dist, nyp = dy / dist;
            const penetration = player.r - dist;
            nx += nxp * penetration;
            ny += nyp * penetration;
            if (nyp > 0) onGround = true;
          }
        }
        // Boundaries
        if (nx < player.r) { nx = player.r; player.vx = 0; }
        if (ny > worldHeight - player.r) { ny = worldHeight - player.r; player.vy = 0; player.onGround = true; }

        player.x = nx; player.y = ny;
        player.onGround = onGround;

        // Enemies
        for (let e of enemies) {
          e.x += e.dir * e.speed * dt;
          if (e.x < e.minX) { e.x = e.minX; e.dir = 1; }
          if (e.x > e.maxX) { e.x = e.maxX; e.dir = -1; }
          // basic collision
          if (circleRectCollision(player.x, player.y, player.r, e.x, e.y, e.w, e.h)) {
            // death
            die();
          }
        }

        // End zone
        if (endZone && circleRectCollision(player.x, player.y, player.r, endZone.x, endZone.y, endZone.w, endZone.h)) {
          onLevelComplete();
        }

        // Coins
        checkCoinCollisions();

        // score / coin effects
        // simple trail
        if (trailsEnabled) {
          trails.unshift({ x: player.x, y: player.y, r: Math.max(6, player.r * 0.6) });
          if (trails.length > 60) trails.pop();
        }

        // camera
        camX = player.x - W * 0.5;
        camX = Math.max(0, Math.min(camX, worldWidth - W));
        camShake *= 0.92;
        if (camShake < 0.01) camShake = 0;

        // update particles
        updateParticles(dt);
      }

      // render
      renderWorld();

      requestAnimationFrame(loop);
    }

    function die() {
      if (!player.alive) return;
      player.alive = false;
      player.vx = 0; player.vy = 0;
      camShake = 12;
      spawnParticles(player.x, player.y);
      setTimeout(() => { showOverlay(deathPanel); }, 250);
    }

    // Start
    function startGame() {
      started = true;
      showOverlay(null); // hide overlays
      requestAnimationFrame(loop);
    }

    // Initialize
    function init() {
      // prepare progress
      initProgress();
      // load first level
      loadLevel(0);
      // show start screen
      showOverlay(startPanel);
    }

    // Stage controls to level
    function updateHUD() {
      // update HUD values
      // best score
      const best = parseInt(localStorage.getItem('bestScore') || '0', 10);
      hudBest.textContent = 'Best: ' + best;
      document.getElementById('hudLevel').textContent = 'Level: ' + (currentLevel + 1);
      document.getElementById('hudScore').textContent = 'Score: ' + score;
      document.getElementById('hudCoins').textContent = 'Coins: ' + coinsCollected;
    }

    // Helpers
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Initialize on page load
    let pausedState = false;
    let startedState = false;
    let inTransitionState = true;
    let transitionAlphaState = 1;

    function initProgress() {
      if (localStorage.getItem('levelUnlocked') === null) localStorage.setItem('levelUnlocked', '0');
      if (localStorage.getItem('bestScore') === null) localStorage.setItem('bestScore', '0');
      if (localStorage.getItem('trailEnabled') !== null) trailsEnabled = (localStorage.getItem('trailEnabled') === 'true');
    }

    function showOverlay(panel) {
      overlay.style.display = '';
      startPanel.style.display = 'none';
      deathPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      pausePanel.style.display = 'none';
      levelSelectPanel.style.display = 'none';
      settingsPanel.style.display = 'none';
      if (panel) panel.style.display = '';
    }
    // Keep overlay logic for settings panel
    // We'll just reuse showOverlay(null) to hide
    function hideOverlay() { overlay.style.display = 'none'; }

    // Level select button
    populateLevelSelect();

    // Start game on click
    startBtn && (startBtn.onclick = () => {
      hideOverlay();
      started = true;
      startedState = true;
      lastTime = performance.now();
      requestAnimationFrame(loop);
    });

    // Level select btn
    levelSelectBtn && (levelSelectBtn.onclick = () => {
      populateLevelSelect();
      showOverlay(levelSelectPanel);
    });

    // Pause / resume
    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyP' || e.code === 'Escape') {
        if (!started) return;
        togglePause();
      }
    });

    // Level complete continue
    continueBtn && (continueBtn.onclick = () => {
      hideOverlay();
      const next = currentLevel + 1;
      if (next < levels.length) loadLevel(next);
      else loadLevel(0);
      requestAnimationFrame(loop);
    });

    // On load
    init();

  </script>

</body>
</html>