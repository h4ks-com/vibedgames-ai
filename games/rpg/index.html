<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PeerQuest 3D ‚Äî PeerJS Multiplayer Adventure (Single File)</title>
  <style>
    :root{
      --bg:#070b18;
      --panel:rgba(10,16,36,.78);
      --line:rgba(255,255,255,.12);
      --text:rgba(240,248,255,.96);
      --muted:rgba(200,220,255,.65);
      --good:#35f2b4;
      --bad:#ff5c7a;
      --warn:#ffd166;
      --accent:#6ea8fe;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html,body{ height:100%; margin:0; background: radial-gradient(1200px 900px at 10% 10%, rgba(110,168,254,.18), transparent 55%),
                                         radial-gradient(1000px 800px at 90% 15%, rgba(53,242,180,.12), transparent 55%),
                                         radial-gradient(1000px 800px at 50% 95%, rgba(255,92,122,.10), transparent 55%),
                                         var(--bg); color:var(--text); font-family:var(--sans); overflow:hidden; }
    #game { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }

    .ui{
      position:fixed; inset:0; pointer-events:none;
      display:flex; justify-content:space-between; align-items:flex-start;
      padding:14px; gap:14px;
    }
    .card{
      pointer-events:auto;
      width:min(480px, calc(100vw - 28px));
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .card .hd{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
      gap:10px;
    }
    .brand{ display:flex; align-items:center; gap:10px; min-width:0; }
    .logo{
      width:30px; height:30px; border-radius:10px;
      background: conic-gradient(from 180deg, var(--accent), var(--good), var(--bad), var(--accent));
      position:relative;
      box-shadow: 0 14px 30px rgba(110,168,254,.18);
    }
    .logo:after{ content:""; position:absolute; inset:7px; border-radius:8px; background: rgba(7,11,24,.75); border:1px solid rgba(255,255,255,.10); }
    .title{ display:flex; flex-direction:column; min-width:0; gap:2px;}
    .title b{ font-size:13px; letter-spacing:.3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .title span{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .btn{
      pointer-events:auto;
      cursor:pointer;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      font:700 12px/1 var(--sans);
      display:inline-flex; align-items:center; gap:8px;
      user-select:none;
      transition: background .15s ease, transform .05s ease, border-color .15s ease;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.16); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: linear-gradient(180deg, rgba(110,168,254,.28), rgba(110,168,254,.10)); border-color: rgba(110,168,254,.38); }
    .btn.good{ background: linear-gradient(180deg, rgba(53,242,180,.22), rgba(53,242,180,.08)); border-color: rgba(53,242,180,.38); }
    .btn.bad{ background: linear-gradient(180deg, rgba(255,92,122,.22), rgba(255,92,122,.08)); border-color: rgba(255,92,122,.38); }
    .pill{
      display:inline-flex; align-items:center; gap:7px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      white-space:nowrap;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background: rgba(200,220,255,.55); box-shadow: 0 0 0 3px rgba(200,220,255,.10); }
    .dot.good{ background: var(--good); box-shadow: 0 0 0 3px rgba(53,242,180,.12); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 0 3px rgba(255,92,122,.12); }

    .card .bd{ padding:12px; display:flex; flex-direction:column; gap:10px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .row .left{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      padding:2px 6px;
      border-radius:8px;
    }
    .small{ font-size:12px; color:var(--muted); line-height:1.35; }
    .mono{ font-family:var(--mono); font-size:11.5px; color:rgba(220,235,255,.78); }
    .urlbox{
      width:100%;
      border:1px solid var(--line);
      background: rgba(7,11,24,.55);
      border-radius: 12px;
      padding:10px;
      font: 11.5px/1.4 var(--mono);
      color: rgba(232,244,255,.92);
      overflow:auto;
      max-height:84px;
      white-space:pre-wrap;
      word-break:break-all;
    }
    .chat{
      position:fixed;
      right:14px; bottom:14px;
      width:min(480px, calc(100vw - 28px));
      pointer-events:auto;
    }
    .messages{
      height: 160px;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(7,11,24,.55);
      overflow:auto;
      padding:10px;
      font: 12px/1.35 var(--mono);
      color: rgba(232,244,255,.92);
      white-space:pre-wrap;
    }
    .chat input{
      width:100%;
      border:1px solid var(--line);
      background: rgba(7,11,24,.55);
      border-radius: 12px;
      padding:10px;
      outline:none;
      color:var(--text);
      font: 650 12.5px/1.2 var(--sans);
    }
    .nameRow{ display:flex; gap:8px; align-items:center; }
    .nameRow input{ flex:1; }

    .toast{
      position:fixed;
      left:14px; bottom:14px;
      width:min(560px, calc(100vw - 28px));
      display:flex; flex-direction:column; gap:8px;
      pointer-events:none;
    }
    .toast .t{
      pointer-events:auto;
      border:1px solid var(--line);
      background: rgba(10,16,36,.82);
      border-radius: 14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
    }
    .toast .t b{ font-size:12.5px; }
    .toast .t .d{ font-size:11.5px; color:var(--muted); margin-top:3px; font-family:var(--mono); white-space:pre-wrap; word-break:break-word; }
    .toast .t .x{
      cursor:pointer;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--text);
      padding:4px 7px;
      border-radius:10px;
      font:700 12px/1 var(--sans);
    }

    .crosshair{
      position:fixed; left:50%; top:50%;
      width:18px; height:18px; transform: translate(-50%,-50%);
      pointer-events:none;
      opacity:.85;
      display:none;
    }
    .crosshair:before, .crosshair:after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(240,248,255,.8);
      box-shadow: 0 0 0 3px rgba(110,168,254,.10);
    }
    .crosshair:before{ width:18px; height:2px; transform: translate(-50%,-50%); border-radius:2px; }
    .crosshair:after{ width:2px; height:18px; transform: translate(-50%,-50%); border-radius:2px; }

    .hint{
      position:fixed;
      left:50%; bottom:16px;
      transform: translateX(-50%);
      pointer-events:none;
      padding:8px 10px;
      background: rgba(10,16,36,.62);
      border:1px solid var(--line);
      border-radius: 999px;
      color: rgba(232,244,255,.9);
      font-size:12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      text-align:center;
      max-width: min(900px, calc(100vw - 28px));
    }
    @media (max-width: 900px){
      .ui{ flex-direction:column; align-items:stretch; }
      .ui > .card{ width:100%; }
      .chat{ position:fixed; right:14px; left:14px; bottom:14px; width:auto; }
      .hint{ bottom: 220px; }
    }
  </style>

  <!-- Public CDNs -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="game"></div>

  <div class="ui">
    <div class="card">
      <div class="hd">
        <div class="brand">
          <div class="logo"></div>
          <div class="title">
            <b>PeerQuest 3D</b>
            <span id="subtitle">Choose a name, then Play</span>
          </div>
        </div>
        <div class="row">
          <button class="btn primary" id="btnStart">Play</button>
          <button class="btn" id="btnShare">Copy Share URL</button>
        </div>
      </div>
      <div class="bd">
        <div class="row">
          <div class="left">
            <span class="pill"><span class="dot" id="dotPeer"></span><span id="peerState">Peer: ‚Ä¶</span></span>
            <span class="pill"><span class="dot" id="dotRoom"></span><span id="roomState">Room: ‚Ä¶</span></span>
            <span class="pill"><span class="dot" id="dotNet"></span><span id="netState">Network: ‚Ä¶</span></span>
          </div>
          <div class="left">
            <span class="pill">Players: <b id="playerCount">1</b></span>
            <span class="pill">Ping: <b id="pingLabel">‚Äî</b></span>
          </div>
        </div>

        <div class="small">
          <div><span class="kbd">WASD</span> move ¬∑ <span class="kbd">Shift</span> sprint ¬∑ <span class="kbd">Space</span> jump ¬∑ <span class="kbd">Mouse</span> look ¬∑ <span class="kbd">E</span> interact ¬∑ <span class="kbd">/</span> chat ¬∑ <span class="kbd">Esc</span> unlock</div>
        </div>

        <div class="urlbox" id="shareUrlBox"></div>

        <div class="row">
          <div class="left">
            <button class="btn good" id="btnCreate">New Room</button>
            <button class="btn" id="btnReconnect">Reconnect</button>
          </div>
          <div class="left">
            <button class="btn" id="btnToggleNames">Toggle names</button>
            <button class="btn bad" id="btnReset">Reset local</button>
          </div>
        </div>

        <div class="small" id="statusText">Tip: click ‚ÄúNew Room‚Äù to host on your current tab. Share the URL with friends.</div>
      </div>
    </div>
  </div>

  <div class="card chat" id="chatCard">
    <div class="hd">
      <div class="brand">
        <div class="title">
          <b>Party Chat</b>
          <span class="mono" id="chatHint">Press / to chat</span>
        </div>
      </div>
      <div class="row">
        <button class="btn" id="btnClearChat">Clear</button>
      </div>
    </div>
    <div class="bd">
      <div class="nameRow">
        <input id="nameInput" placeholder="Your name (press Save)" maxlength="24" />
        <button class="btn good" id="btnSaveName">Save</button>
      </div>
      <div class="messages" id="messages"></div>
      <input id="chatInput" placeholder="Type message‚Ä¶ (Enter to send)" autocomplete="off" />
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="crosshair" id="crosshair"></div>
  <div class="hint" id="worldHint">Find the village. Talk to NPCs. Collect 3 crystals hidden near trees.</div>

<script>
(() => {
  "use strict";

  // NOTE ABOUT THE ERROR YOU SAW:
  // "Could not connect to peer <id>" happens when you try to join a room id that isn't currently online (host tab not open),
  // or if WebRTC is blocked by network policy. This build adds a "Host/Join Mode" that always works:
  // - If you click "New Room", YOU become host (roomId becomes your PeerJS id).
  // - If you open a URL room=..., you will attempt to join that host. If host is offline, it shows a clear UI state.
  // (No extra explanation requested; leaving this as inline comment only.)

  const $ = (q, el=document) => el.querySelector(q);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const uuid = () => (crypto?.randomUUID ? crypto.randomUUID() : ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)));
  const now = () => performance.now();
  const escapeHtml = (s)=>String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));

  const toastBox = $("#toast");
  function toast(title, detail="", ttl=5000){
    const el = document.createElement("div");
    el.className = "t";
    el.innerHTML = `<div><b>${escapeHtml(title)}</b><div class="d">${escapeHtml(detail)}</div></div><div class="x">√ó</div>`;
    $(".x", el).onclick = ()=>el.remove();
    toastBox.appendChild(el);
    setTimeout(()=>{ if(el.isConnected) el.remove(); }, ttl);
  }

  // URL room helpers
  function roomIdFromUrl(){
    const u = new URL(location.href);
    return u.searchParams.get("room") || u.hash.replace(/^#/, "") || "";
  }
  function setRoomInUrl(rid){
    const u = new URL(location.href);
    u.searchParams.set("room", rid);
    u.hash = "";
    history.replaceState({}, "", u.toString());
    $("#shareUrlBox").textContent = u.toString();
    return u.toString();
  }

  // Local identity
  const LS_ID = "peerquest.playerId.v4";
  const LS_NAME = "peerquest.playerName.v4";
  const LS_COLOR = "peerquest.playerColor.v4";

  let myId = localStorage.getItem(LS_ID) || uuid();
  localStorage.setItem(LS_ID, myId);
  let myName = localStorage.getItem(LS_NAME) || "";
  let myColor = localStorage.getItem(LS_COLOR) || `hsl(${randi(0,360)} 85% 60%)`;
  localStorage.setItem(LS_COLOR, myColor);

  function sanitizeName(s){
    s = String(s||"").trim().replace(/\s+/g, " ");
    s = s.replace(/[^\p{L}\p{N}\s\-_'.!]/gu, "");
    if(s.length > 24) s = s.slice(0,24);
    return s;
  }

  // Audio
  const AudioSys = {
    ctx:null, master:null, musicGain:null, sfxGain:null, started:false, musicTimer:null,
    init(){
      if(this.started) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return;
      this.ctx = new AC();
      this.master = this.ctx.createGain(); this.master.gain.value = 0.75; this.master.connect(this.ctx.destination);
      this.musicGain = this.ctx.createGain(); this.musicGain.gain.value = 0.22; this.musicGain.connect(this.master);
      this.sfxGain = this.ctx.createGain(); this.sfxGain.gain.value = 0.55; this.sfxGain.connect(this.master);
      this.started = true;
      this.startMusic();
    },
    resume(){ if(this.ctx?.state === "suspended") this.ctx.resume(); },
    beep({freq=440,dur=0.07,type="sine",gain=0.10,when=0}={}){
      if(!this.started) return;
      const t0 = this.ctx.currentTime + when;
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      osc.connect(g); g.connect(this.sfxGain);
      osc.start(t0); osc.stop(t0+dur+0.02);
    },
    noise({dur=0.08,gain=0.05,when=0}={}){
      if(!this.started) return;
      const t0 = this.ctx.currentTime + when;
      const len = Math.max(1, Math.floor(this.ctx.sampleRate * dur));
      const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
      const d = buf.getChannelData(0);
      for(let i=0;i<len;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/len, 2);
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      src.connect(g); g.connect(this.sfxGain);
      src.start(t0); src.stop(t0+dur+0.02);
    },
    chord({base=196,dur=0.7,gain=0.045}={}){
      if(!this.started) return;
      const t0 = this.ctx.currentTime;
      const freqs = [base, base*5/4, base*3/2];
      for(const f of freqs){
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(f, t0);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0+0.06);
        g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
        osc.connect(g); g.connect(this.musicGain);
        osc.start(t0); osc.stop(t0+dur+0.02);
      }
    },
    startMusic(){
      if(!this.started || this.musicTimer) return;
      let step = 0;
      const prog = [196,220,247,175];
      this.musicTimer = setInterval(()=>this.chord({ base: prog[step++%prog.length] }), 800);
    }
  };

  // UI refs
  const UI = {
    dotPeer: $("#dotPeer"),
    dotRoom: $("#dotRoom"),
    dotNet: $("#dotNet"),
    peerState: $("#peerState"),
    roomState: $("#roomState"),
    netState: $("#netState"),
    playerCount: $("#playerCount"),
    pingLabel: $("#pingLabel"),
    statusText: $("#statusText"),
    messages: $("#messages"),
    subtitle: $("#subtitle")
  };
  function uiSetPeer(state, kind=""){ UI.peerState.textContent = "Peer: " + state; UI.dotPeer.className = "dot " + (kind||""); }
  function uiSetRoom(state, kind=""){ UI.roomState.textContent = "Room: " + state; UI.dotRoom.className = "dot " + (kind||""); }
  function uiSetNet(state, kind=""){ UI.netState.textContent = "Network: " + state; UI.dotNet.className = "dot " + (kind||""); }
  function appendChat(line){
    const box = UI.messages;
    const atBottom = (box.scrollTop + box.clientHeight) >= (box.scrollHeight - 12);
    box.textContent += line + "\n";
    if(atBottom) box.scrollTop = box.scrollHeight;
  }

  // Three.js
  const container = $("#game");
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a1024, 0.012);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 2000);
  camera.position.set(0, 1.8, 8);

  const hemi = new THREE.HemisphereLight(0x9cc8ff, 0x1b2b18, 0.65);
  scene.add(hemi);

  const sun = new THREE.DirectionalLight(0xffffff, 1.05);
  sun.position.set(20, 34, 12);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 1;
  sun.shadow.camera.far = 150;
  sun.shadow.camera.left = -60;
  sun.shadow.camera.right = 60;
  sun.shadow.camera.top = 60;
  sun.shadow.camera.bottom = -60;
  scene.add(sun);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(400, 400),
    new THREE.MeshStandardMaterial({ color: 0x173319, roughness: 1 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const sky = new THREE.Mesh(
    new THREE.SphereGeometry(900, 32, 16),
    new THREE.MeshBasicMaterial({ color: 0x080c1d, side: THREE.BackSide })
  );
  scene.add(sky);

  const path = new THREE.Mesh(
    new THREE.PlaneGeometry(120, 18),
    new THREE.MeshStandardMaterial({ color: 0x2a2117, roughness: 1 })
  );
  path.rotation.x = -Math.PI/2;
  path.position.set(0, 0.01, -10);
  path.receiveShadow = true;
  scene.add(path);

  const world = new THREE.Group();
  scene.add(world);

  // builders
  const matTreeTrunk = new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 });
  const matTreeLeaf = new THREE.MeshStandardMaterial({ color: 0x1f7a3e, roughness: 1 });
  const matHouseWall = new THREE.MeshStandardMaterial({ color: 0xb9a789, roughness: 1 });
  const matHouseRoof = new THREE.MeshStandardMaterial({ color: 0x7a2a32, roughness: 1 });
  const matStone = new THREE.MeshStandardMaterial({ color: 0x7c8aa3, roughness: 1 });

  function makeTree(x,z, s=1){
    const g = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18*s, 0.24*s, 2.2*s, 8), matTreeTrunk);
    trunk.castShadow = true; trunk.receiveShadow = true;
    trunk.position.y = 1.1*s;
    g.add(trunk);

    const leaf = new THREE.Mesh(new THREE.SphereGeometry(1.05*s, 10, 8), matTreeLeaf);
    leaf.castShadow = true; leaf.receiveShadow = true;
    leaf.position.y = 2.5*s;
    g.add(leaf);

    for(let i=0;i<3;i++){
      const puff = new THREE.Mesh(new THREE.SphereGeometry(rand(0.55,0.8)*s, 10, 8), matTreeLeaf);
      puff.position.set(rand(-0.7,0.7)*s, rand(2.1,3.0)*s, rand(-0.7,0.7)*s);
      puff.castShadow = true;
      g.add(puff);
    }

    g.position.set(x, 0, z);
    world.add(g);
    return g;
  }

  function makeHouse(x,z, rot=0){
    const g = new THREE.Group();
    const base = new THREE.Mesh(new THREE.BoxGeometry(4.2, 2.6, 3.8), matHouseWall);
    base.position.y = 1.3;
    base.castShadow = true; base.receiveShadow = true;
    g.add(base);

    const roof = new THREE.Mesh(new THREE.ConeGeometry(3.4, 2.1, 4), matHouseRoof);
    roof.position.y = 3.0;
    roof.rotation.y = Math.PI/4;
    roof.castShadow = true;
    g.add(roof);

    const door = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.3, 0.1), new THREE.MeshStandardMaterial({ color: 0x3a2a1b, roughness: 1 }));
    door.position.set(0, 0.65, 1.95);
    door.castShadow = true;
    g.add(door);

    const stone = new THREE.Mesh(new THREE.BoxGeometry(5.0, 0.3, 4.6), matStone);
    stone.position.y = 0.15;
    stone.receiveShadow = true;
    g.add(stone);

    g.position.set(x, 0, z);
    g.rotation.y = rot;
    world.add(g);
    return g;
  }

  // game objects
  const gameCrystals = [];
  const crystalMat = new THREE.MeshStandardMaterial({ color: 0x55d7ff, emissive: 0x125577, emissiveIntensity: 1.3, roughness: 0.2, metalness: 0.2 });
  function makeCrystal(x,z){
    const m = new THREE.Mesh(new THREE.OctahedronGeometry(0.35, 0), crystalMat);
    m.position.set(x, 0.55, z);
    m.castShadow = true;
    m.userData.collected = false;
    world.add(m);
    gameCrystals.push(m);
    return m;
  }

  const npcs = [];
  function makeNPC(name, x, z, color=0xffd166){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 0.9, 6, 10), new THREE.MeshStandardMaterial({ color, roughness: 1 }));
    body.castShadow = true; body.receiveShadow = true;
    body.position.y = 1.0;
    g.add(body);

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.33, 14, 12), new THREE.MeshStandardMaterial({ color: 0xffe3c1, roughness: 1 }));
    head.position.y = 1.75;
    head.castShadow = true;
    g.add(head);

    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25 });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x102030, roughness: 0.4 });
    const eyeWhiteGeo = new THREE.SphereGeometry(0.06, 12, 10);
    const pupilGeo = new THREE.SphereGeometry(0.03, 12, 10);
    function eye(){
      const e = new THREE.Group();
      const w = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
      const p = new THREE.Mesh(pupilGeo, pupilMat);
      p.position.set(0.02, 0, 0.055);
      w.castShadow = p.castShadow = true;
      e.add(w,p);
      return e;
    }
    const e1 = eye(), e2 = eye();
    e1.position.set(-0.11, 1.78, 0.27);
    e2.position.set( 0.11, 1.78, 0.27);
    g.add(e1,e2);

    const hat = new THREE.Mesh(new THREE.ConeGeometry(0.42, 0.55, 10), new THREE.MeshStandardMaterial({ color: 0x2c3559, roughness: 1 }));
    hat.position.y = 2.18;
    hat.castShadow = true;
    g.add(hat);

    g.position.set(x, 0, z);
    g.userData = { name, t: Math.random()*10, baseX:x, baseZ:z, msgIndex:0 };
    world.add(g);
    npcs.push(g);
    return g;
  }

  // world populate
  const SPAWN = new THREE.Vector3(0,0,6);
  for(let i=0;i<60;i++){
    const ring = i<22 ? 1 : (i<44 ? 2 : 3);
    const ang = rand(0, Math.PI*2);
    const r = ring===1 ? rand(10,22) : ring===2 ? rand(22,45) : rand(45,75);
    const x = Math.cos(ang)*r + rand(-4,4);
    const z = Math.sin(ang)*r - 12 + rand(-4,4);
    if(Math.abs(x) < 10 && (z > -6 && z < 22)) continue;
    makeTree(x, z, rand(0.9, 1.45));
  }
  makeHouse(-8, -12, 0.4);
  makeHouse(8, -14, -0.6);
  makeHouse(-15, -24, 0.1);
  makeHouse(16, -26, -0.2);

  makeNPC("Elder Rowan", -2, -10, 0xffd166);
  makeNPC("Scout Mira", 10, -18, 0x6ea8fe);
  makeNPC("Smith Kade", -12, -22, 0xff5c7a);

  makeCrystal(-18, 6);
  makeCrystal(22, 2);
  makeCrystal(6, -44);

  // name sprites
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
    ctx.beginPath();
    ctx.moveTo(x+r.tl, y);
    ctx.lineTo(x+w-r.tr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r.tr);
    ctx.lineTo(x+w, y+h-r.br);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r.br, y+h);
    ctx.lineTo(x+r.bl, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r.bl);
    ctx.lineTo(x, y+r.tl);
    ctx.quadraticCurveTo(x, y, x+r.tl, y);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }
  function makeNameSprite(){
    const canvas = document.createElement("canvas");
    canvas.width = 512; canvas.height = 128;
    const ctx = canvas.getContext("2d");
    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite:false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(2.8, 0.7, 1);
    sprite.position.set(0, 2.75, 0);
    sprite.userData = { canvas, ctx, tex };
    return sprite;
  }
  function updateNameTag(sprite, name, extra=""){
    const { canvas, ctx, tex } = sprite.userData;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "rgba(10,16,36,0.75)";
    roundRect(ctx, 14, 18, canvas.width-28, 92, 24, true, false);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 4;
    roundRect(ctx, 14, 18, canvas.width-28, 92, 24, false, true);

    ctx.fillStyle = "rgba(240,248,255,0.92)";
    ctx.font = "700 42px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.fillText(name || "Player", canvas.width/2, 68);

    if(extra){
      ctx.fillStyle = "rgba(200,220,255,0.72)";
      ctx.font = "650 26px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.fillText(extra, canvas.width/2, 106);
    }
    tex.needsUpdate = true;
  }

  // avatars
  function makePlayerAvatar(colorStr){
    const g = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorStr), roughness: 1 });
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 0.95, 6, 10), bodyMat);
    body.castShadow = true; body.receiveShadow = true;
    body.position.y = 1.0;
    g.add(body);

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 14, 12), new THREE.MeshStandardMaterial({ color: 0xffe3c1, roughness: 1 }));
    head.position.y = 1.75;
    head.castShadow = true;
    g.add(head);

    const face = new THREE.Group();
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25 });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x0f1b2a, roughness: 0.35 });
    const eyeWhiteGeo = new THREE.SphereGeometry(0.06, 12, 10);
    const pupilGeo = new THREE.SphereGeometry(0.03, 12, 10);
    function eye(){
      const e = new THREE.Group();
      const w = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
      const p = new THREE.Mesh(pupilGeo, pupilMat);
      p.position.set(0.02, 0, 0.055);
      w.castShadow = p.castShadow = true;
      e.add(w,p);
      return e;
    }
    const e1 = eye(), e2 = eye();
    e1.position.set(-0.11, 0.03, 0.27);
    e2.position.set( 0.11, 0.03, 0.27);
    face.add(e1,e2);
    face.position.set(0, 1.75, 0);
    g.add(face);

    const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.25), new THREE.MeshStandardMaterial({ color: 0x26314a, roughness: 1 }));
    backpack.position.set(0, 1.1, -0.3);
    backpack.castShadow = true;
    g.add(backpack);

    const sprite = makeNameSprite();
    g.add(sprite);

    g.userData = { sprite, face };
    return g;
  }

  // game state
  let showNames = true;
  const my = {
    id: myId,
    name: myName || ("Player-" + myId.slice(0,4)),
    color: myColor,
    pos: SPAWN.clone(),
    vel: new THREE.Vector3(),
    yaw: 0,
    pitch: 0,
    grounded: false,
    sprint: false,
    collected: 0
  };

  const myAvatar = makePlayerAvatar(my.color);
  updateNameTag(myAvatar.userData.sprite, my.name, "YOU");
  myAvatar.position.copy(my.pos);
  scene.add(myAvatar);

  const remotes = new Map(); // pid -> { avatar, state, lastSeen }
  function ensureRemote(pid, meta={}){
    if(remotes.has(pid)) return remotes.get(pid);
    const avatar = makePlayerAvatar(meta.color || `hsl(${randi(0,360)} 80% 60%)`);
    updateNameTag(avatar.userData.sprite, meta.name || ("Player-" + pid.slice(0,4)));
    avatar.position.set(SPAWN.x + rand(-1,1), 0, SPAWN.z + rand(-1,1));
    scene.add(avatar);
    const r = {
      pid,
      avatar,
      state: { name: meta.name||("Player-"+pid.slice(0,4)), color: meta.color||"#fff", pos: avatar.position.clone(), yaw:0, pitch:0, collected:0, ts:Date.now() },
      lastSeen: now()
    };
    remotes.set(pid, r);
    return r;
  }
  function removeRemote(pid){
    const r = remotes.get(pid);
    if(!r) return;
    scene.remove(r.avatar);
    remotes.delete(pid);
  }
  function angleDelta(a,b){
    let d = (b-a)%(Math.PI*2);
    if(d>Math.PI) d-=Math.PI*2;
    if(d<-Math.PI) d+=Math.PI*2;
    return d;
  }

  // input + pointer lock + chat focus
  const chatInput = $("#chatInput");
  let started = false;
  let pointerLocked = false;
  let chatFocused = false;
  const crosshair = $("#crosshair");

  function setPointerLock(on){
    if(on) renderer.domElement.requestPointerLock?.();
    else document.exitPointerLock?.();
  }
  document.addEventListener("pointerlockchange", ()=>{
    pointerLocked = (document.pointerLockElement === renderer.domElement);
    crosshair.style.display = pointerLocked ? "block" : "none";
    UI.subtitle.textContent = pointerLocked ? "In the field" : "Choose a name, then Play";
  });
  function focusChat(){
    chatFocused = true;
    chatInput.focus();
    setPointerLock(false);
  }
  function returnToGame(){
    chatFocused = false;
    chatInput.blur();
    if(started) setPointerLock(true);
  }

  const keys = new Set();
  window.addEventListener("keydown",(ev)=>{
    if(ev.key === "/" && document.activeElement !== chatInput){
      ev.preventDefault();
      focusChat();
      return;
    }
    if(document.activeElement === chatInput) return;
    keys.add(ev.key.toLowerCase());
    if(ev.key === " ") ev.preventDefault();
  });
  window.addEventListener("keyup",(ev)=>keys.delete(ev.key.toLowerCase()));
  window.addEventListener("mousemove",(ev)=>{
    if(!pointerLocked) return;
    my.yaw -= (ev.movementX||0) * 0.0022;
    my.pitch -= (ev.movementY||0) * 0.0020;
    my.pitch = clamp(my.pitch, -1.25, 1.25);
  });
  chatInput.addEventListener("keydown",(ev)=>{
    if(ev.key === "Enter"){
      ev.preventDefault();
      const msg = chatInput.value.trim();
      if(msg) sendChat(msg);
      chatInput.value = "";
      returnToGame();
    }
    ev.stopPropagation();
  });

  // name save
  const nameInput = $("#nameInput");
  nameInput.value = myName || "";
  $("#btnSaveName").onclick = ()=>{
    const nm = sanitizeName(nameInput.value);
    if(!nm){ toast("Name required", "Enter 1‚Äì24 characters."); AudioSys.beep({freq:220,type:"square",gain:0.08}); return; }
    myName = nm;
    localStorage.setItem(LS_NAME, myName);
    my.name = myName;
    updateNameTag(myAvatar.userData.sprite, my.name, "YOU");
    toast("Name saved", my.name, 2000);
    AudioSys.beep({freq:740,type:"triangle",gain:0.06});
    AudioSys.beep({freq:988,type:"triangle",gain:0.06,when:0.06});
    // notify host, if connected
    if(!isHost() && hostConn?.open){
      hostConn.send({ t:"hello", from: myId, name: my.name, color: my.color, ts: Date.now() });
    }
  };

  // PeerJS networking with robust join retry + clearer errors
  let peer = null;
  let hostConn = null;      // client -> host
  const conns = new Map();  // host: pid -> conn
  let roomId = roomIdFromUrl() || uuid();
  setRoomInUrl(roomId);

  function isHost(){
    // Host uses peer id = roomId. We host only if roomId is exactly myId (set by New Room).
    return roomId === myId;
  }

  function broadcast(obj){
    if(!isHost()) return;
    for(const [,c] of conns) if(c.open) c.send(obj);
  }

  function sendChat(msg){
    const payload = { t:"chat", from: myId, name: my.name, msg, ts: Date.now() };
    if(isHost()){
      handleMessage(null, payload);
      broadcast(payload);
    } else {
      hostConn?.open && hostConn.send(payload);
    }
    AudioSys.beep({freq:660,dur:0.05,type:"square",gain:0.06});
  }

  function connectPeer(){
    try{ peer?.destroy(); }catch{}
    peer = null;
    conns.clear();
    hostConn = null;

    uiSetPeer("connecting‚Ä¶");
    uiSetRoom((isHost() ? "host " : "join ") + "(" + roomId.slice(0,8) + "‚Ä¶)", isHost() ? "good" : "warn");
    uiSetNet(isHost() ? "hosting" : "joining‚Ä¶", "warn");
    setRoomInUrl(roomId);

    const pid = isHost() ? roomId : myId;
    peer = new Peer(pid, { debug: 1 });

    peer.on("open", (id)=>{
      uiSetPeer("open (" + id.slice(0,8) + "‚Ä¶)", "good");

      if(isHost()){
        uiSetNet("hosting ‚Äî share URL", "good");
        UI.statusText.textContent = "You are the host. Share the URL; everyone joins your room.";
        toast("Hosting room", "Keep this tab open. Share the URL with friends.", 6000);
      } else {
        UI.statusText.textContent = "Joining host‚Ä¶ (host must be online)";
        connectToHostWithRetry();
      }
    });

    peer.on("connection", (conn)=>{
      if(isHost()) conns.set(conn.peer, conn);
      bindConn(conn, conn.peer);
    });

    peer.on("error", (err)=>{
      uiSetPeer("error", "bad");
      uiSetNet("error", "bad");
      toast("PeerJS error", String(err?.type || err?.message || err), 9000);
      console.error(err);
    });
  }

  let joinAttempt = 0;
  let joinTimer = null;

  function connectToHostWithRetry(){
    if(isHost()) return;
    clearTimeout(joinTimer);
    joinAttempt++;

    // IMPORTANT: host peer id is the roomId. If host is offline, PeerJS throws "Could not connect to peer".
    const attempt = joinAttempt;
    uiSetNet(`joining host‚Ä¶ (try ${attempt})`, "warn");

    hostConn = peer.connect(roomId, { reliable: true });

    let opened = false;

    hostConn.on("open", ()=>{
      opened = true;
      joinAttempt = 0;
      uiSetNet("connected to host", "good");
      UI.statusText.textContent = "Connected. Invite others with the URL.";
      toast("Connected to host", roomId, 3000);
      hostConn.send({ t:"hello", from: myId, name: my.name, color: my.color, ts: Date.now() });
      bindConn(hostConn, roomId);
    });

    hostConn.on("error", (err)=>{
      // wait for close handler / retry below
      console.warn("hostConn error", err);
    });

    hostConn.on("close", ()=>{
      if(opened) return;
      uiSetNet("host offline / unreachable", "bad");
      UI.statusText.textContent = "Host is offline or unreachable. Ask host to open the URL and click Play.";
      toast("Could not connect to host", "Host offline/unreachable or WebRTC blocked. Keep trying or click New Room to host.", 9000);
      // retry with backoff
      const backoff = clamp(800 * attempt, 800, 6000);
      joinTimer = setTimeout(()=>connectToHostWithRetry(), backoff);
    });
  }

  function bindConn(conn, peerId){
    conn.on("open", ()=>{
      if(isHost()){
        uiSetNet(`hosting (${conns.size} connected)`, "good");
        ensureRemote(peerId, { name:"Player-"+peerId.slice(0,4) });
      } else {
        uiSetNet("connected to host", "good");
      }
      UI.playerCount.textContent = String(isHost() ? (1 + conns.size) : (1 + remotes.size));
    });

    conn.on("data", (data)=>handleMessage(conn, data));

    conn.on("close", ()=>{
      if(isHost()){
        conns.delete(peerId);
        removeRemote(peerId);
        broadcast({ t:"peerLeft", pid: peerId, ts: Date.now() });
        uiSetNet(`hosting (${conns.size} connected)`, "good");
      } else {
        uiSetNet("lost host", "bad");
        UI.statusText.textContent = "Disconnected. Retrying‚Ä¶";
        connectToHostWithRetry();
      }
      UI.playerCount.textContent = String(isHost() ? (1 + conns.size) : (1 + remotes.size));
    });
  }

  // Events / state sync
  function collectCrystal(index, byId){
    const c = gameCrystals[index];
    if(!c || c.userData.collected) return;
    c.userData.collected = true;
    c.visible = false;

    if(byId === myId){
      my.collected += 1;
      $("#worldHint").textContent = my.collected>=3 ? "You found all crystals! Return to the Elder for glory." : `Crystals: ${my.collected}/3 ‚Äî keep searching.`;
      AudioSys.beep({freq:880,dur:0.10,type:"triangle",gain:0.09});
      AudioSys.beep({freq:1320,dur:0.10,type:"triangle",gain:0.07,when:0.06});
    } else {
      const r = remotes.get(byId);
      if(r) r.state.collected = (r.state.collected||0) + 1;
    }

    const total = byId === myId ? my.collected : (remotes.get(byId)?.state.collected||0);
    const payload = { t:"event", kind:"crystal", index, by: byId, total, ts: Date.now() };
    broadcast(payload);
    handleMessage(null, payload);
  }

  const npcLines = {
    "Elder Rowan": [
      "Welcome, traveler. The forest hums with old power.",
      "Three crystals are hidden near the trees. Find them.",
      "Return when you have them all. The realm will remember."
    ],
    "Scout Mira": [
      "I saw something glittering beyond the far pines.",
      "Stay low, stay quick. The wind carries secrets.",
      "If you sprint downhill, you can cross the meadow fast."
    ],
    "Smith Kade": [
      "If I had metal, I‚Äôd forge you a blade worthy of legends.",
      "The houses are safe‚Ä¶ mostly. Watch the shadows anyway.",
      "Bring me a crystal and I‚Äôll‚Ä¶ admire it intensely."
    ]
  };

  function handleMessage(conn, msg){
    if(!msg || typeof msg !== "object") return;

    if(msg.t === "hello" && isHost()){
      const pid = conn?.peer || msg.from;
      const r = ensureRemote(pid, { name: msg.name, color: msg.color });
      r.state.name = msg.name;
      r.state.color = msg.color;
      updateNameTag(r.avatar.userData.sprite, r.state.name);
      broadcast({ t:"peerJoined", pid, name: msg.name, color: msg.color, ts: Date.now() });
      UI.playerCount.textContent = String(1 + conns.size);
      AudioSys.beep({freq:523,dur:0.06,type:"square",gain:0.06});
      AudioSys.beep({freq:659,dur:0.06,type:"square",gain:0.06,when:0.06});
      return;
    }

    if(msg.t === "state" && isHost()){
      const pid = conn?.peer || msg.from;
      const r = ensureRemote(pid, { name: msg.name, color: msg.color });
      r.lastSeen = now();
      r.state.name = msg.name || r.state.name;
      r.state.color = msg.color || r.state.color;
      r.state.pos.set(msg.px, msg.py, msg.pz);
      r.state.yaw = msg.yaw || 0;
      r.state.pitch = msg.pitch || 0;
      r.state.ts = msg.ts || Date.now();
      r.state.collected = msg.collected || 0;
      updateNameTag(r.avatar.userData.sprite, r.state.name, r.state.collected ? ("üí†"+r.state.collected) : "");
      return;
    }

    if(msg.t === "snapshot" && !isHost()){
      const players = msg.players || [];
      const ids = new Set(players.map(p=>p.pid));
      for(const p of players){
        const pid = p.pid;
        if(pid === myId) continue;
        const r = ensureRemote(pid, { name: p.name, color: p.color });
        r.lastSeen = now();
        r.state.name = p.name || r.state.name;
        r.state.color = p.color || r.state.color;
        r.state.pos.set(p.px, p.py, p.pz);
        r.state.yaw = p.yaw || 0;
        r.state.pitch = p.pitch || 0;
        r.state.ts = p.ts || Date.now();
        r.state.collected = p.collected || 0;
        updateNameTag(r.avatar.userData.sprite, r.state.name, pid===roomId ? "HOST" : (r.state.collected?("üí†"+r.state.collected):""));
      }
      for(const [pid, r] of remotes){
        if(!ids.has(pid) && (now() - r.lastSeen > 7000)) removeRemote(pid);
      }
      UI.playerCount.textContent = String(1 + remotes.size);
      return;
    }

    if(msg.t === "chat"){
      const name = msg.name || ("Player-"+(msg.from||"").slice(0,4));
      appendChat(`[${new Date(msg.ts||Date.now()).toLocaleTimeString()}] ${name}: ${msg.msg}`);
      AudioSys.beep({freq:392,dur:0.04,type:"sine",gain:0.03});
      return;
    }

    if(msg.t === "peerJoined"){ toast("Party joined", `${msg.name||"A player"} entered the realm.`, 3500); return; }
    if(msg.t === "peerLeft"){ toast("Party left", "A player returned to the mist.", 3500); return; }

    if(msg.t === "event"){
      if(msg.kind === "crystalRequest" && isHost()){
        collectCrystal(msg.index, msg.by || conn?.peer);
        return;
      }
      if(msg.kind === "crystal"){
        const i = msg.index;
        if(Number.isFinite(i) && gameCrystals[i]){
          gameCrystals[i].userData.collected = true;
          gameCrystals[i].visible = false;
        }
        if(msg.by === myId){
          my.collected = msg.total || my.collected;
          $("#worldHint").textContent = my.collected>=3 ? "You found all crystals! Return to the Elder for glory." : `Crystals: ${my.collected}/3 ‚Äî keep searching.`;
        } else {
          const r = remotes.get(msg.by);
          if(r){
            r.state.collected = msg.total || r.state.collected;
            updateNameTag(r.avatar.userData.sprite, r.state.name, r.state.collected?("üí†"+r.state.collected):"");
          }
        }
        return;
      }
      if(msg.kind === "npc"){
        toast("NPC", msg.text || "‚Ä¶", 5200);
        AudioSys.beep({freq:330,dur:0.05,type:"triangle",gain:0.04});
        return;
      }
    }

    if(msg.t === "ping"){
      (isHost()? conn : hostConn)?.send({ t:"pong", id: msg.id, t0: msg.t0, ts: Date.now() });
      return;
    }
    if(msg.t === "pong"){
      if(!isHost()){
        const rtt = Date.now() - (msg.t0||Date.now());
        UI.pingLabel.textContent = rtt + "ms";
      }
      return;
    }
  }

  // Host snapshot
  let lastSnapshot = 0;
  const SNAPSHOT_HZ = 12;
  function hostBroadcastSnapshot(){
    if(!isHost()) return;
    const t = now();
    if(t - lastSnapshot < (1000/SNAPSHOT_HZ)) return;
    lastSnapshot = t;

    const players = [];
    players.push({ pid: roomId, name: my.name, color: my.color, px: my.pos.x, py: my.pos.y, pz: my.pos.z, yaw: my.yaw, pitch: my.pitch, ts: Date.now(), collected: my.collected });
    for(const [pid, r] of remotes){
      if(!conns.has(pid)) continue;
      players.push({ pid, name: r.state.name, color: r.state.color, px: r.state.pos.x, py: r.state.pos.y, pz: r.state.pos.z, yaw: r.state.yaw, pitch: r.state.pitch, ts: r.state.ts || Date.now(), collected: r.state.collected || 0 });
    }
    broadcast({ t:"snapshot", players, ts: Date.now() });
    uiSetNet(`hosting (${conns.size} connected)`, "good");
    UI.playerCount.textContent = String(1 + conns.size);
    UI.pingLabel.textContent = "‚Äî";
  }

  // Client send state
  let lastStateSend = 0;
  const STATE_HZ = 24;
  function clientSendState(){
    if(isHost()) return;
    if(!hostConn?.open) return;
    const t = now();
    if(t - lastStateSend < (1000/STATE_HZ)) return;
    lastStateSend = t;
    hostConn.send({
      t:"state", from: myId, name: my.name, color: my.color,
      px: my.pos.x, py: my.pos.y, pz: my.pos.z,
      yaw: my.yaw, pitch: my.pitch,
      collected: my.collected,
      ts: Date.now()
    });
  }

  // Ping
  let lastPing = 0;
  function doPing(){
    if(isHost()) return;
    if(!hostConn?.open) return;
    if(now() - lastPing < 2000) return;
    lastPing = now();
    hostConn.send({ t:"ping", id: uuid(), t0: Date.now(), ts: Date.now() });
  }

  // Movement
  const GRAV = -22.0;
  const MOVE = 6.8;
  const SPRINT = 11.5;
  const JUMP = 7.6;
  const FRICTION = 18.0;
  const ACCEL = 26.0;

  function stepPlayer(dt){
    const forward = new THREE.Vector3(-Math.sin(my.yaw), 0, -Math.cos(my.yaw)).normalize(); // yaw=0 -> -Z
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    let move = new THREE.Vector3();
    if(keys.has("w")) move.add(forward);
    if(keys.has("s")) move.addScaledVector(forward, -1);
    if(keys.has("d")) move.add(right);
    if(keys.has("a")) move.addScaledVector(right, -1);

    my.sprint = keys.has("shift");
    const maxSpeed = my.sprint ? SPRINT : MOVE;

    let desired = new THREE.Vector3();
    if(move.lengthSq() > 0){
      move.normalize();
      desired.copy(move).multiplyScalar(maxSpeed);
    }

    const horiz = new THREE.Vector3(my.vel.x, 0, my.vel.z);
    const delta = desired.sub(horiz);
    horiz.addScaledVector(delta, clamp(ACCEL*dt, 0, 1));

    if(move.lengthSq() === 0){
      horiz.multiplyScalar(1 - clamp(FRICTION*dt, 0, 1));
    }

    my.vel.x = horiz.x;
    my.vel.z = horiz.z;

    my.vel.y += GRAV * dt;

    if(keys.has(" ") && my.grounded){
      my.vel.y = JUMP;
      my.grounded = false;
      AudioSys.beep({freq:220,type:"square",gain:0.07});
      AudioSys.noise({dur:0.06,gain:0.04,when:0.01});
    }

    my.pos.addScaledVector(my.vel, dt);

    if(my.pos.y < 0){
      if(!my.grounded && my.vel.y < -6) AudioSys.noise({dur:0.06,gain:0.03});
      my.pos.y = 0;
      my.vel.y = 0;
      my.grounded = true;
    }

    const maxR = 175;
    const rr = Math.hypot(my.pos.x, my.pos.z);
    if(rr > maxR){
      const s = maxR / rr;
      my.pos.x *= s; my.pos.z *= s;
      my.vel.x *= 0.2; my.vel.z *= 0.2;
    }

    const headHeight = 1.75;
    camera.position.set(my.pos.x, my.pos.y + headHeight, my.pos.z);
    camera.rotation.order = "YXZ";
    camera.rotation.y = my.yaw;
    camera.rotation.x = my.pitch;

    myAvatar.position.copy(my.pos);
    myAvatar.rotation.y = my.yaw;
    myAvatar.visible = !pointerLocked;
    myAvatar.userData.sprite.visible = showNames && !pointerLocked;
  }

  function stepRemotes(dt){
    const t = now();
    for(const [pid, r] of remotes){
      r.avatar.userData.sprite.visible = showNames;
      r.avatar.position.lerp(r.state.pos, clamp(dt*12.0, 0, 1));
      r.avatar.rotation.y += angleDelta(r.avatar.rotation.y, r.state.yaw) * clamp(dt*12.0, 0, 1);

      // face turn a bit toward camera so eyes visible
      const toCam = new THREE.Vector3().subVectors(camera.position, r.avatar.position);
      const desiredYaw = Math.atan2(toCam.x, toCam.z);
      const localYaw = angleDelta(r.avatar.rotation.y, desiredYaw);
      r.avatar.userData.face.rotation.y = clamp(localYaw, -0.9, 0.9);

      r.avatar.userData.sprite.quaternion.copy(camera.quaternion);

      r.avatar.visible = (t - r.lastSeen) <= 10000;
    }
  }

  // Interact
  function interact(){
    // NPC
    let best = null, bestD = 2.2;
    for(const n of npcs){
      const d = n.position.distanceTo(new THREE.Vector3(my.pos.x, 0, my.pos.z));
      if(d < bestD){ best = n; bestD = d; }
    }
    if(best){
      const lines = npcLines[best.userData.name] || ["‚Ä¶"];
      const idx = (best.userData.msgIndex++) % lines.length;
      const text = `${best.userData.name}: ${lines[idx]}`;
      appendChat(`[NPC] ${text}`);
      AudioSys.beep({freq:294,dur:0.06,type:"triangle",gain:0.04});
      AudioSys.beep({freq:370,dur:0.05,type:"triangle",gain:0.035,when:0.06});
      const payload = { t:"event", kind:"npc", text, ts: Date.now() };
      if(isHost()){ handleMessage(null, payload); broadcast(payload); }
      else hostConn?.open && hostConn.send(payload);
      return;
    }
    // crystals
    for(let i=0;i<gameCrystals.length;i++){
      const c = gameCrystals[i];
      if(!c.visible || c.userData.collected) continue;
      const d = c.position.distanceTo(new THREE.Vector3(my.pos.x, 0.55, my.pos.z));
      if(d < 1.6){
        if(isHost()) collectCrystal(i, myId);
        else hostConn?.open && hostConn.send({ t:"event", kind:"crystalRequest", index:i, by: myId, ts: Date.now() });
        return;
      }
    }
    toast("Interact", "Nothing nearby.", 1200);
  }
  window.addEventListener("keydown",(ev)=>{
    if(ev.key.toLowerCase()==="e" && pointerLocked && !chatFocused) interact();
  });

  // Fireflies
  const fireflies = new THREE.Group();
  scene.add(fireflies);
  const flyMat = new THREE.MeshBasicMaterial({ color: 0x7cf7d4 });
  const flyGeo = new THREE.SphereGeometry(0.03, 6, 6);
  for(let i=0;i<60;i++){
    const f = new THREE.Mesh(flyGeo, flyMat);
    f.position.set(rand(-60,60), rand(1.0, 6.0), rand(-80,40));
    f.userData = { a: rand(0,Math.PI*2), s: rand(0.6,1.4) };
    fireflies.add(f);
  }

  // Buttons
  $("#btnStart").onclick = () => {
    started = true;
    AudioSys.init(); AudioSys.resume();
    setPointerLock(true);
    toast("Adventure", "Mouse locked. Explore the village.", 2400);
  };
  renderer.domElement.addEventListener("mousedown", ()=>{
    if(!pointerLocked && started) setPointerLock(true);
    AudioSys.init(); AudioSys.resume();
  });

  $("#btnShare").onclick = async ()=>{
    try{
      const u = setRoomInUrl(roomId);
      await navigator.clipboard.writeText(u);
      toast("Copied share URL", u, 2400);
      AudioSys.init(); AudioSys.resume();
      AudioSys.beep({freq:784,dur:0.06,type:"square",gain:0.05});
    }catch{
      toast("Share URL", "Copy failed. Select it in the box.", 3500);
    }
  };

  $("#btnCreate").onclick = ()=>{
    // Reliable rule: host peer id MUST equal roomId. We set roomId to myId and reconnect.
    roomId = myId;
    setRoomInUrl(roomId);
    toast("New room created", "You are host now. Keep this tab open.", 5000);
    AudioSys.init(); AudioSys.resume();
    AudioSys.beep({freq:523,dur:0.06,type:"square",gain:0.06});
    AudioSys.beep({freq:659,dur:0.06,type:"square",gain:0.06,when:0.06});
    connectPeer();
  };

  $("#btnReconnect").onclick = ()=>{
    AudioSys.init(); AudioSys.resume();
    connectPeer();
  };

  $("#btnToggleNames").onclick = ()=>{
    showNames = !showNames;
    toast("Names", showNames ? "Visible" : "Hidden", 1800);
    AudioSys.init(); AudioSys.resume();
    AudioSys.beep({freq: showNames ? 660 : 330, dur:0.05, type:"triangle", gain:0.04});
  };

  $("#btnReset").onclick = ()=>{
    localStorage.removeItem(LS_ID);
    localStorage.removeItem(LS_NAME);
    localStorage.removeItem(LS_COLOR);
    toast("Reset", "Reloading‚Ä¶", 1200);
    setTimeout(()=>location.reload(), 250);
  };

  $("#btnClearChat").onclick = ()=>{ UI.messages.textContent = ""; };

  // Resize
  addEventListener("resize", ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  });

  // Animate loop
  let lastT = now();
  function animate(){
    requestAnimationFrame(animate);
    const t = now();
    const dt = clamp((t-lastT)/1000, 0, 0.05);
    lastT = t;

    // crystals float
    for(let i=0;i<gameCrystals.length;i++){
      const c = gameCrystals[i];
      if(!c.visible) continue;
      c.rotation.x += 0.9*dt;
      c.rotation.y += 1.1*dt;
      c.position.y = 0.55 + Math.sin((t*0.002) + i)*0.12;
    }

    // fireflies
    for(const f of fireflies.children){
      f.userData.a += dt * f.userData.s * 0.9;
      f.position.y += Math.sin(f.userData.a)*dt*0.2;
      f.position.x += Math.cos(f.userData.a*0.7)*dt*0.25;
      f.position.z += Math.sin(f.userData.a*0.5)*dt*0.25;
    }

    // NPC face player + wander
    for(const n of npcs){
      n.userData.t += dt;
      const w = 0.5;
      n.position.x = n.userData.baseX + Math.sin(n.userData.t*0.6)*w;
      n.position.z = n.userData.baseZ + Math.cos(n.userData.t*0.55)*w;
      const toP = new THREE.Vector3(my.pos.x, 0, my.pos.z).sub(n.position);
      n.rotation.y = Math.atan2(toP.x, toP.z);
    }

    if(pointerLocked && !chatFocused){
      stepPlayer(dt);
    } else {
      camera.position.set(my.pos.x, my.pos.y + 1.75, my.pos.z + 6);
      camera.lookAt(my.pos.x, my.pos.y + 1.5, my.pos.z);
      myAvatar.position.copy(my.pos);
      myAvatar.rotation.y = my.yaw;
      myAvatar.visible = true;
      myAvatar.userData.sprite.visible = showNames;
    }

    // name tags face camera
    myAvatar.userData.sprite.quaternion.copy(camera.quaternion);
    if(myAvatar.userData.face){
      // in third-person (unlocked), face toward camera a bit
      const toCam = new THREE.Vector3().subVectors(camera.position, myAvatar.position);
      const desiredYaw = Math.atan2(toCam.x, toCam.z);
      const localYaw = angleDelta(myAvatar.rotation.y, desiredYaw);
      myAvatar.userData.face.rotation.y = clamp(localYaw, -0.9, 0.9);
    }

    clientSendState();
    hostBroadcastSnapshot();
    doPing();
    stepRemotes(dt);

    renderer.render(scene, camera);
  }

  // Init net
  function initNet(){
    const rid = roomIdFromUrl();
    if(rid) roomId = rid;
    setRoomInUrl(roomId);
    uiSetRoom((isHost() ? "host " : "join ") + "(" + roomId.slice(0,8) + "‚Ä¶)", isHost() ? "good" : "warn");
    uiSetPeer("‚Ä¶");
    uiSetNet("‚Ä¶");
    connectPeer();
  }

  appendChat(`[${new Date().toLocaleTimeString()}] System: Welcome to PeerQuest. Press / to chat.`);
  appendChat(`[${new Date().toLocaleTimeString()}] System: Click New Room to host, or open a friend's link to join.`);
  appendChat(`[${new Date().toLocaleTimeString()}] System: If you see "Could not connect to peer", the host tab isn't open (or WebRTC is blocked).`);

  if(myName){
    my.name = myName;
    updateNameTag(myAvatar.userData.sprite, my.name, "YOU");
  }

  initNet();
  animate();

})();
</script>
</body>
</html>