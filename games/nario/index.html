<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Platformer (Mario-ish)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #c { display:block; width:100vw; height:100vh; }
    #hud {
      position: fixed; left: 12px; top: 10px; color: #fff;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
      font-size: 14px; line-height: 1.25;
      user-select: none; pointer-events: none;
    }
    #hud b { font-weight: 700; }
    #toast {
      position: fixed; left: 50%; top: 14px; transform: translateX(-50%);
      padding: 8px 12px; border-radius: 10px;
      background: rgba(0,0,0,.45); color:#fff;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      opacity: 0; transition: opacity .2s ease;
      user-select: none; pointer-events: none;
      font-size: 14px;
    }
    #toast.on { opacity: 1; }
    #overlay {
      position: fixed; inset: 0; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 30%, rgba(255,255,255,.08), rgba(0,0,0,.75));
      color:#fff; text-align:center; padding: 24px;
    }
    #card {
      width:min(720px, 92vw);
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      box-shadow: 0 20px 80px rgba(0,0,0,.5);
      padding: 18px 18px 14px;
    }
    #card h1 { margin: 0 0 8px; font-size: 20px; letter-spacing: .2px; }
    #card p { margin: 0 0 12px; opacity:.9; }
    #card kbd {
      display:inline-block; padding: 2px 6px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    #card .row { display:flex; gap: 12px; flex-wrap:wrap; justify-content:center; }
    #btn {
      appearance:none; border: 0; border-radius: 12px;
      background: linear-gradient(180deg, #ff4d4d, #cc1c1c);
      color: #fff; font-weight: 700;
      padding: 10px 14px; cursor: pointer;
      box-shadow: 0 10px 30px rgba(255,77,77,.22);
    }
    #btn:active { transform: translateY(1px); }
    #tiny { margin-top: 10px; font-size: 12px; opacity: .8; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div><b>Coins</b>: <span id="coins">0</span> &nbsp; <b>Lives</b>: <span id="lives">3</span> &nbsp; <b>Time</b>: <span id="time">300</span></div>
  <div style="opacity:.9">Move <b>WASD</b> / Arrows · Jump <b>Space</b> · Sprint <b>Shift</b> · Stomp enemies · Reach the flag</div>
</div>
<div id="toast"></div>

<div id="overlay">
  <div id="card">
    <h1>3D Platformer</h1>
    <p>Classic platforming vibes in 3D. Collect coins, stomp goombas, reach the flag.</p>
    <div class="row">
      <div><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> / Arrows</div>
      <div><kbd>Space</kbd> jump</div>
      <div><kbd>Shift</kbd> sprint</div>
      <div><kbd>R</kbd> restart</div>
    </div>
    <div style="margin-top:12px">
      <button id="btn">Start</button>
    </div>
    <div id="tiny">Tip: if you fall, you lose a life. Stomp enemies from above.</div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x87CEEB, 1);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87CEEB, 40, 220);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 600);
camera.position.set(0, 5, 10);

const hudCoins = document.getElementById('coins');
const hudLives = document.getElementById('lives');
const hudTime  = document.getElementById('time');
const toast = document.getElementById('toast');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('btn');

const state = {
  started: false,
  coins: 0,
  lives: 3,
  time: 300,
  timeAcc: 0,
  won: false,
  dead: false
};

function say(msg, ms=1400){
  toast.textContent = msg;
  toast.classList.add('on');
  clearTimeout(say._t);
  say._t = setTimeout(()=>toast.classList.remove('on'), ms);
}

const hemi = new THREE.HemisphereLight(0xffffff, 0x385070, 0.75);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 1.05);
sun.position.set(30, 50, 15);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 160;
sun.shadow.camera.left = -70;
sun.shadow.camera.right = 70;
sun.shadow.camera.top = 70;
sun.shadow.camera.bottom = -70;
scene.add(sun);

const groundMat = new THREE.MeshStandardMaterial({ color: 0x3fbf4a, roughness: 0.95 });
const dirtMat   = new THREE.MeshStandardMaterial({ color: 0x8a5a2b, roughness: 1.0 });
const brickMat  = new THREE.MeshStandardMaterial({ color: 0xd0703f, roughness: 0.85 });
const coinMat   = new THREE.MeshStandardMaterial({ color: 0xffd34a, metalness: 0.6, roughness: 0.25, emissive: 0x221100 });
const enemyMat  = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.95 });
const pipeMat   = new THREE.MeshStandardMaterial({ color: 0x1db954, roughness: 0.45, metalness: 0.05 });
const flagMat   = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
const flagCloth = new THREE.MeshStandardMaterial({ color: 0xff4d4d, roughness: 0.7, emissive: 0x220000 });

const world = new THREE.Group();
scene.add(world);

const colliders = [];
const coins = [];
const enemies = [];
let flag = null;

function makeBox(w,h,d, mat){
  const geo = new THREE.BoxGeometry(w,h,d);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function addCollider(mesh, type="solid", data={}){
  mesh.userData.collider = { type, ...data };
  colliders.push(mesh);
}

function addPlatform(x,y,z,w,h,d, topMat=groundMat, sideMat=dirtMat){
  const g = new THREE.Group();
  const top = makeBox(w, Math.min(0.35,h), d, topMat);
  top.position.y = (h/2) - (Math.min(0.35,h)/2);
  const bodyH = Math.max(0, h - Math.min(0.35,h));
  if(bodyH > 0){
    const body = makeBox(w, bodyH, d, sideMat);
    body.position.y = - (h/2) + bodyH/2;
    g.add(body);
  }
  g.add(top);
  g.position.set(x,y,z);
  g.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
  world.add(g);

  // Single collider box
  const col = makeBox(w,h,d, new THREE.MeshBasicMaterial({ visible:false }));
  col.position.set(x,y,z);
  world.add(col);
  addCollider(col, "solid");
  return g;
}

function addBrick(x,y,z){
  const b = makeBox(2,1,2, brickMat);
  b.position.set(x,y,z);
  world.add(b);
  addCollider(b,"solid");
  return b;
}

function addPipe(x,y,z, r=1.2, h=3.2){
  const group = new THREE.Group();
  const base = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, 18), pipeMat);
  base.castShadow = true; base.receiveShadow = true;
  base.position.y = h/2;
  const lip = new THREE.Mesh(new THREE.CylinderGeometry(r*1.12, r*1.12, 0.45, 18), pipeMat);
  lip.castShadow = true; lip.receiveShadow = true;
  lip.position.y = h + 0.2;
  group.add(base, lip);
  group.position.set(x,y,z);
  world.add(group);

  const col = makeBox(r*2.3, h+0.7, r*2.3, new THREE.MeshBasicMaterial({ visible:false }));
  col.position.set(x, y + (h+0.7)/2, z);
  world.add(col);
  addCollider(col, "solid");
  return group;
}

function addCoin(x,y,z){
  const geo = new THREE.TorusGeometry(0.45, 0.16, 12, 20);
  const mesh = new THREE.Mesh(geo, coinMat);
  mesh.position.set(x,y,z);
  mesh.castShadow = true;
  world.add(mesh);
  mesh.userData.spin = (Math.random()*0.6+0.6) * (Math.random()<0.5?-1:1);
  coins.push(mesh);
  return mesh;
}

function addEnemy(x,y,z){
  const g = new THREE.Group();

  const body = new THREE.Mesh(new THREE.SphereGeometry(0.75, 18, 14), enemyMat);
  body.scale.y = 0.85;
  body.castShadow = true; body.receiveShadow = true;
  body.position.y = 0.75;

  const footMat = new THREE.MeshStandardMaterial({ color: 0x3b2a1c, roughness: 1.0 });
  const f1 = new THREE.Mesh(new THREE.BoxGeometry(0.38,0.2,0.65), footMat);
  const f2 = f1.clone();
  f1.position.set(-0.35,0.15,0.05);
  f2.position.set( 0.35,0.15,0.05);
  f1.castShadow=f1.receiveShadow=true;
  f2.castShadow=f2.receiveShadow=true;

  const eyeW = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 });
  const eyeB = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5 });
  const e1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 10), eyeW);
  const e2 = e1.clone();
  const p1 = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 10), eyeB);
  const p2 = p1.clone();
  e1.position.set(-0.22, 0.92, 0.55);
  e2.position.set( 0.22, 0.92, 0.55);
  p1.position.set(-0.22, 0.92, 0.67);
  p2.position.set( 0.22, 0.92, 0.67);
  e1.castShadow=e2.castShadow=p1.castShadow=p2.castShadow=true;

  g.add(body,f1,f2,e1,e2,p1,p2);
  g.position.set(x,y,z);
  world.add(g);

  const col = makeBox(1.8, 1.6, 1.6, new THREE.MeshBasicMaterial({ visible:false }));
  col.position.set(x, y+0.8, z);
  world.add(col);

  const enemy = {
    group: g,
    col,
    alive: true,
    dir: (Math.random()<0.5?-1:1),
    speed: 2.0 + Math.random()*0.6,
    bob: Math.random()*Math.PI*2,
    stompedT: 0
  };
  enemies.push(enemy);
  return enemy;
}

function addFlag(x,y,z){
  const g = new THREE.Group();
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,10, 10), flagMat);
  pole.castShadow = true; pole.receiveShadow = true;
  pole.position.y = 5;
  const cap = new THREE.Mesh(new THREE.SphereGeometry(0.22, 12, 10), flagMat);
  cap.position.y = 10.1;
  cap.castShadow = true; cap.receiveShadow = true;

  const cloth = new THREE.Mesh(new THREE.PlaneGeometry(2.2,1.5, 10, 6), flagCloth);
  cloth.position.set(1.2, 8.8, 0);
  cloth.rotation.y = Math.PI/2;
  cloth.castShadow = true; cloth.receiveShadow = true;
  cloth.userData.wave = 0;

  g.add(pole, cap, cloth);
  g.position.set(x,y,z);
  world.add(g);

  const zone = makeBox(3.0, 6.0, 3.0, new THREE.MeshBasicMaterial({ visible:false }));
  zone.position.set(x, y+3, z);
  world.add(zone);
  addCollider(zone, "flag", { flagGroup: g, cloth });

  flag = { group: g, cloth, zone };
  return flag;
}

function buildLevel(){
  // Clear previous
  for(const m of [...colliders, ...coins]) { world.remove(m); }
  for(const e of enemies) { world.remove(e.group); world.remove(e.col); }
  colliders.length = 0; coins.length = 0; enemies.length = 0;
  if(flag?.group){ world.remove(flag.group); world.remove(flag.zone); }
  flag = null;

  // Big base ground
  addPlatform(0, -2, 0, 140, 4, 30);

  // Raised sections / gaps
  addPlatform(24, -1.4, 0, 22, 2.8, 22);
  addPlatform(52, -0.8, 0, 22, 4.0, 22);
  addPlatform(78, -0.2, 0, 22, 5.2, 22);
  addPlatform(102, 0.4, 0, 18, 6.4, 22);

  // Some bricks
  addBrick(12, 2.5, 0);
  addBrick(14.5, 2.5, 0);
  addBrick(17, 2.5, 0);

  addBrick(40, 3.2, -2);
  addBrick(42.5, 3.2, -2);

  addBrick(64, 4.3, 2);
  addBrick(66.5, 4.3, 2);
  addBrick(69, 4.3, 2);

  // Pipes
  addPipe(30, -2, 6, 1.2, 3.2);
  addPipe(36, -2, -6, 1.4, 3.9);
  addPipe(58, -2, 6, 1.6, 4.6);

  // Coins arcs
  for(let i=0;i<8;i++) addCoin(10 + i*1.5, 4.2 + Math.sin(i*0.45)*0.8, 0);
  for(let i=0;i<10;i++) addCoin(30 + i*1.6, 2.2 + Math.sin(i*0.5)*0.7, (i%2? -4:4));
  for(let i=0;i<10;i++) addCoin(54 + i*1.6, 3.2 + Math.sin(i*0.55)*0.8, (i%2? -5:5));
  for(let i=0;i<12;i++) addCoin(76 + i*1.5, 4.4 + Math.sin(i*0.45)*0.9, 0);

  // Enemies
  addEnemy(18, -2, 4);
  addEnemy(34, -2, -3);
  addEnemy(46, -2, 5);
  addEnemy(62, -2, -5);
  addEnemy(86, -2, 3);

  // Flag
  addFlag(110, -2, 0);

  // Background hills
  const hillMat = new THREE.MeshStandardMaterial({ color: 0x2ea13b, roughness: 1.0 });
  for(let i=0;i<10;i++){
    const hill = new THREE.Mesh(new THREE.SphereGeometry(6+Math.random()*10, 18, 14), hillMat);
    hill.scale.y = 0.55;
    hill.position.set(-40 + i*18 + Math.random()*10, -2, -32 - Math.random()*25);
    hill.receiveShadow = true;
    world.add(hill);
  }

  // Clouds
  const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0 });
  for(let i=0;i<18;i++){
    const cg = new THREE.Group();
    const puffs = 3 + Math.floor(Math.random()*3);
    for(let j=0;j<puffs;j++){
      const puff = new THREE.Mesh(new THREE.SphereGeometry(1.5+Math.random()*1.4, 14, 12), cloudMat);
      puff.position.set(j*1.7, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.7);
      puff.castShadow = false; puff.receiveShadow = false;
      cg.add(puff);
    }
    cg.position.set(-30 + Math.random()*170, 18 + Math.random()*18, -22 - Math.random()*45);
    cg.userData.drift = 0.4 + Math.random()*0.7;
    cg.userData.baseX = cg.position.x;
    world.add(cg);
  }
}

const player = {
  radius: 0.55,
  height: 1.75,
  pos: new THREE.Vector3(0, 1, 0),
  vel: new THREE.Vector3(),
  onGround: false,
  facing: 1,
  hurtT: 0
};

const playerGroup = new THREE.Group();
scene.add(playerGroup);

function buildPlayer(){
  playerGroup.clear();

  // Simple Mario-ish: red cap, blue body
  const capMat = new THREE.MeshStandardMaterial({ color: 0xff2b2b, roughness: 0.65 });
  const skinMat= new THREE.MeshStandardMaterial({ color: 0xffd2b0, roughness: 0.9 });
  const blueMat= new THREE.MeshStandardMaterial({ color: 0x2f62ff, roughness: 0.7 });
  const brown  = new THREE.MeshStandardMaterial({ color: 0x6b3f1f, roughness: 1.0 });
  const white  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });

  const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.55, 0.7, 6, 14), blueMat);
  body.castShadow = true; body.receiveShadow = true;
  body.position.y = 0.95;

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.48, 16, 14), skinMat);
  head.castShadow = true;
  head.position.y = 1.78;

  const cap = new THREE.Mesh(new THREE.SphereGeometry(0.52, 16, 14, 0, Math.PI*2, 0, Math.PI*0.55), capMat);
  cap.castShadow = true;
  cap.position.y = 2.05;
  cap.rotation.x = Math.PI;

  const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.33, 0.52, 0.12, 18), capMat);
  brim.castShadow = true;
  brim.position.set(0, 1.95, 0.38);
  brim.rotation.x = Math.PI/2;

  const must = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.08, 10, 18, Math.PI), brown);
  must.position.set(0, 1.63, 0.42);
  must.rotation.x = Math.PI/2;
  must.castShadow = true;

  const eyeW = new THREE.Mesh(new THREE.SphereGeometry(0.09, 10, 10), white);
  const eyeW2= eyeW.clone();
  const eyeB = new THREE.Mesh(new THREE.SphereGeometry(0.04, 10, 10), brown);
  const eyeB2= eyeB.clone();
  eyeW.position.set(-0.13, 1.78, 0.42);
  eyeW2.position.set( 0.13, 1.78, 0.42);
  eyeB.position.set(-0.13, 1.78, 0.49);
  eyeB2.position.set( 0.13, 1.78, 0.49);
  eyeW.castShadow=eyeW2.castShadow=eyeB.castShadow=eyeB2.castShadow=true;

  const footGeo = new THREE.BoxGeometry(0.35,0.2,0.7);
  const f1 = new THREE.Mesh(footGeo, brown);
  const f2 = new THREE.Mesh(footGeo, brown);
  f1.position.set(-0.25, 0.12, 0.08);
  f2.position.set( 0.25, 0.12, 0.08);
  f1.castShadow=f2.castShadow=true;

  playerGroup.add(body, head, cap, brim, must, eyeW, eyeW2, eyeB, eyeB2, f1, f2);
}
buildPlayer();

const keys = new Set();
addEventListener('keydown', (e)=>{
  keys.add(e.code);
  if(e.code === 'KeyR') restart();
  if(!state.started && (e.code === 'Space' || e.code === 'Enter')) start();
});
addEventListener('keyup', (e)=> keys.delete(e.code));

function aabbOf(mesh){
  mesh.geometry.computeBoundingBox?.();
  const box = new THREE.Box3().setFromObject(mesh);
  return box;
}

const tmpBox = new THREE.Box3();
const tmpBox2 = new THREE.Box3();
const tmpV = new THREE.Vector3();

function capsuleAABB(pos, radius, height){
  // Approx: capsule as AABB
  const half = height/2;
  return tmpBox.setFromCenterAndSize(
    new THREE.Vector3(pos.x, pos.y + half, pos.z),
    new THREE.Vector3(radius*2, height + radius*2, radius*2)
  );
}

function resolveCollisions(nextPos, vel, dt){
  // broadphase AABB
  const aabb = capsuleAABB(nextPos, player.radius, player.height);

  player.onGround = false;

  for(const m of colliders){
    const c = m.userData.collider;
    if(!c) continue;

    tmpBox2.setFromObject(m);
    if(!aabb.intersectsBox(tmpBox2)) continue;

    if(c.type === "flag"){
      if(!state.won){
        state.won = true;
        say("Course clear!");
      }
      continue;
    }

    if(c.type !== "solid") continue;

    // Compute overlap along axes using AABB approximation
    const pxMin = aabb.min.x, pxMax = aabb.max.x;
    const pyMin = aabb.min.y, pyMax = aabb.max.y;
    const pzMin = aabb.min.z, pzMax = aabb.max.z;

    const bxMin = tmpBox2.min.x, bxMax = tmpBox2.max.x;
    const byMin = tmpBox2.min.y, byMax = tmpBox2.max.y;
    const bzMin = tmpBox2.min.z, bzMax = tmpBox2.max.z;

    const ox = Math.min(pxMax, bxMax) - Math.max(pxMin, bxMin);
    const oy = Math.min(pyMax, byMax) - Math.max(pyMin, byMin);
    const oz = Math.min(pzMax, bzMax) - Math.max(pzMin, bzMin);

    if(ox<=0 || oy<=0 || oz<=0) continue;

    // push out along smallest overlap
    if(oy <= ox && oy <= oz){
      // vertical
      if(pyMax > byMin && pyMin < byMin){
        // hit from below (ceiling)
        nextPos.y -= oy;
        if(vel.y > 0) vel.y = 0;
      } else {
        // land on top
        nextPos.y += oy;
        if(vel.y < 0) vel.y = 0;
        player.onGround = true;
      }
    } else if(ox <= oz){
      // x
      if(nextPos.x > m.position.x) nextPos.x += ox; else nextPos.x -= ox;
      vel.x *= 0.2;
    } else {
      // z
      if(nextPos.z > m.position.z) nextPos.z += oz; else nextPos.z -= oz;
      vel.z *= 0.2;
    }

    // update aabb after changes
    capsuleAABB(nextPos, player.radius, player.height);
  }

  return nextPos;
}

function collectCoins(){
  const p = player.pos;
  for(let i=coins.length-1;i>=0;i--){
    const coin = coins[i];
    if(p.distanceToSquared(coin.position) < 1.2*1.2){
      world.remove(coin);
      coins.splice(i,1);
      state.coins++;
      hudCoins.textContent = state.coins;
      say("+1 coin");
    }
  }
}

function hurt(){
  if(player.hurtT > 0) return;
  state.lives--;
  hudLives.textContent = state.lives;
  player.hurtT = 1.2;
  say("Ouch!");
  if(state.lives <= 0){
    state.dead = true;
    say("Game over — press R");
  } else {
    // knockback
    player.vel.y = 6.5;
    player.vel.x = -player.facing * 6.0;
    player.vel.z = 0;
  }
}

function stompEnemy(e){
  e.alive = false;
  e.stompedT = 0.6;
  // squash visual
  e.group.scale.y = 0.35;
  e.group.scale.x = 1.25;
  e.group.scale.z = 1.25;
  // bounce
  player.vel.y = 8.2;
  say("Stomp!");
}

function updateEnemies(dt){
  for(const e of enemies){
    if(!e.alive){
      e.stompedT -= dt;
      if(e.stompedT <= 0){
        world.remove(e.group);
        world.remove(e.col);
      }
      continue;
    }

    e.bob += dt*7;
    e.group.position.y = e.group.position.y; // no-op (kept for clarity)

    // move along x with simple edge turning using ground height check via ray-ish sampling
    const move = e.dir * e.speed * dt;
    e.group.position.x += move;
    e.col.position.x += move;

    // Turn around near platform edges by checking if enemy is above ground collider within small distance
    const footPos = tmpV.set(e.col.position.x, e.col.position.y-0.9, e.col.position.z);
    let supported = false;
    for(const m of colliders){
      const c = m.userData.collider;
      if(!c || c.type!=="solid") continue;
      tmpBox2.setFromObject(m);
      if(footPos.x > tmpBox2.min.x && footPos.x < tmpBox2.max.x &&
         footPos.z > tmpBox2.min.z && footPos.z < tmpBox2.max.z &&
         footPos.y >= tmpBox2.max.y - 0.35 && footPos.y <= tmpBox2.max.y + 0.75){
        supported = true;
        // snap to ground
        const targetY = tmpBox2.max.y;
        const desiredColY = targetY + 0.8;
        e.col.position.y += (desiredColY - e.col.position.y) * Math.min(1, dt*12);
        e.group.position.y = e.col.position.y - 0.8;
        break;
      }
    }
    if(!supported) e.dir *= -1;

    // Player interaction
    const pAABB = capsuleAABB(player.pos, player.radius, player.height);
    tmpBox2.setFromObject(e.col);
    if(pAABB.intersectsBox(tmpBox2)){
      // decide stomp vs hurt by comparing player's vertical velocity and position
      const playerBottom = pAABB.min.y;
      const enemyTop = tmpBox2.max.y;
      const comingDown = player.vel.y < -1.0;
      const above = playerBottom > enemyTop - 0.35;
      if(comingDown && above){
        stompEnemy(e);
      } else {
        hurt();
      }
    }
  }
}

function updateFlag(dt){
  if(!flag) return;
  // cloth wave (cheap vertex-less fake via scaling + rotation)
  flag.cloth.userData.wave += dt * 3.3;
  const w = flag.cloth.userData.wave;
  flag.cloth.position.x = 1.2 + Math.sin(w)*0.12;
  flag.cloth.rotation.z = Math.sin(w*1.4)*0.18;
}

function updateClouds(dt){
  world.children.forEach(ch=>{
    if(ch.userData?.drift){
      ch.position.x += ch.userData.drift * dt;
      if(ch.position.x > 150) ch.position.x = -60;
    }
  });
}

function restart(){
  state.coins = 0;
  state.lives = 3;
  state.time = 300;
  state.timeAcc = 0;
  state.won = false;
  state.dead = false;
  hudCoins.textContent = state.coins;
  hudLives.textContent = state.lives;
  hudTime.textContent = state.time;

  player.pos.set(0, 2, 0);
  player.vel.set(0, 0, 0);
  player.onGround = false;
  player.hurtT = 0;

  buildLevel();
  say("Restarted");
}

function start(){
  overlay.style.display = "none";
  state.started = true;
  say("Let's-a go!");
}

startBtn.onclick = start;

buildLevel();
restart();

let last = performance.now();

function tick(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  if(state.started && !state.dead && !state.won){
    state.timeAcc += dt;
    if(state.timeAcc >= 1){
      state.timeAcc -= 1;
      state.time = Math.max(0, state.time - 1);
      hudTime.textContent = state.time;
      if(state.time === 0){
        state.dead = true;
        say("Time up — press R");
      }
    }
  }

  // Animate coins
  for(const c of coins){
    c.rotation.y += (c.userData.spin || 1.0) * dt * 3.2;
    c.position.y += Math.sin(now*0.002 + c.position.x*0.4) * dt * 0.12;
  }

  // Player physics
  if(state.started && !state.dead && !state.won){
    const moveX = (keys.has('KeyD') || keys.has('ArrowRight') ? 1 : 0) - (keys.has('KeyA') || keys.has('ArrowLeft') ? 1 : 0);
    const moveZ = (keys.has('KeyW') || keys.has('ArrowUp') ? 1 : 0) - (keys.has('KeyS') || keys.has('ArrowDown') ? 1 : 0);
    const sprint = keys.has('ShiftLeft') || keys.has('ShiftRight');

    const input = new THREE.Vector3(moveX, 0, moveZ);
    const inputLen = input.length();
    if(inputLen > 0) input.multiplyScalar(1/inputLen);

    // Camera-relative movement (but keep it mostly side-scroller along +X)
    // We'll bias to X axis, allow some Z drifting.
    const targetSpeed = (sprint ? 9.5 : 6.5);
    const accel = player.onGround ? 34 : 18;
    const airControl = player.onGround ? 1 : 0.55;

    // Desired velocity
    const desired = new THREE.Vector3(input.x * targetSpeed, 0, input.z * targetSpeed * 0.85);
    // Smooth toward desired
    player.vel.x += (desired.x - player.vel.x) * Math.min(1, dt*accel*airControl);
    player.vel.z += (desired.z - player.vel.z) * Math.min(1, dt*accel*airControl);

    // friction
    if(inputLen === 0 && player.onGround){
      player.vel.x *= Math.pow(0.0009, dt);
      player.vel.z *= Math.pow(0.0009, dt);
    }

    // Jump
    const jumpPressed = keys.has('Space');
    if(jumpPressed && player.onGround){
      player.vel.y = 9.5;
      player.onGround = false;
    }

    // Gravity
    player.vel.y += -22.0 * dt;
    player.vel.y = Math.max(player.vel.y, -35);

    // Integrate
    const nextPos = player.pos.clone().addScaledVector(player.vel, dt);
    resolveCollisions(nextPos, player.vel, dt);
    player.pos.copy(nextPos);

    // Facing for knockback
    if(Math.abs(player.vel.x) > 0.2) player.facing = Math.sign(player.vel.x);

    // Hurt timer visual blink
    if(player.hurtT > 0) player.hurtT -= dt;
    const blink = player.hurtT > 0 && (Math.floor(now*0.02)%2===0);
    playerGroup.visible = !blink;

    collectCoins();
    updateEnemies(dt);

    // Fall check
    if(player.pos.y < -20){
      state.lives--;
      hudLives.textContent = state.lives;
      if(state.lives <= 0){
        state.dead = true;
        say("Game over — press R");
      } else {
        say("Fell! -1 life");
        player.pos.set(0, 2, 0);
        player.vel.set(0, 0, 0);
      }
    }
  }

  updateFlag(dt);
  updateClouds(dt);

  // Place player group
  playerGroup.position.set(player.pos.x, player.pos.y, player.pos.z);
  playerGroup.rotation.y = player.facing < 0 ? Math.PI : 0;

  // Camera follow
  const camTarget = new THREE.Vector3(player.pos.x + 6.5, player.pos.y + 4.4, player.pos.z + 11);
  const lookAt = new THREE.Vector3(player.pos.x + 4.5, player.pos.y + 2.2, player.pos.z);
  camera.position.lerp(camTarget, 1 - Math.pow(0.00001, dt));
  camera.lookAt(lookAt);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>