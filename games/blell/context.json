{
  "messages": [
    {
      "role": "user",
      "content": "mini VM in browser using JS, with typical Unix utilities like htop that actually run and show the memory usage and other specs of the actual browser VM\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Mini Browser VM with htop-like Monitoring</title>\n<style>\n  /* Basic reset */\n  * {\n    box-sizing: border-box;\n  }\n  body {\n    margin: 0;\n    background: #1e1e1e;\n    color: #cfcfcf;\n    font-family: monospace, monospace;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  #terminal {\n    flex-grow: 1;\n    padding: 10px;\n    background: #1e1e1e;\n    overflow-y: auto;\n    white-space: pre-wrap;\n    outline: none;\n  }\n  #input-line {\n    display: flex;\n    border-top: 1px solid #555;\n  }\n  #prompt {\n    padding: 0 10px;\n    background: #333;\n    color: #0f0;\n    user-select: none;\n  }\n  #command-input {\n    flex-grow: 1;\n    background: #1e1e1e;\n    border: none;\n    color: #cfcfcf;\n    font-family: monospace, monospace;\n    font-size: 1em;\n    padding: 6px 10px;\n  }\n  #command-input:focus {\n    outline: none;\n  }\n  /* Scrollbar styling */\n  #terminal::-webkit-scrollbar {\n    width: 8px;\n  }\n  #terminal::-webkit-scrollbar-thumb {\n    background: #555;\n    border-radius: 4px;\n  }\n  #terminal::-webkit-scrollbar-track {\n    background: #1e1e1e;\n  }\n  /* htop table styles */\n  .htop-header {\n    color: #0f0;\n  }\n  .htop-row {\n    font-variant-numeric: tabular-nums;\n  }\n  .htop-bar {\n    display: inline-block;\n    height: 1em;\n    background: #0f0;\n    vertical-align: middle;\n  }\n  .htop-bar-bg {\n    background: #444;\n    display: inline-block;\n    height: 1em;\n    vertical-align: middle;\n    width: 20ch;\n  }\n  /* Error text */\n  .error {\n    color: #f44;\n  }\n</style>\n</head>\n<body>\n<div id=\"terminal\" tabindex=\"0\" aria-label=\"Terminal output\" role=\"log\" aria-live=\"polite\"></div>\n<div id=\"input-line\">\n  <span id=\"prompt\">$</span>\n  <input type=\"text\" id=\"command-input\" aria-label=\"Command input\" autocomplete=\"off\" spellcheck=\"false\" />\n</div>\n<script>\n(() => {\n  // VM filesystem & utilities simulation\n  const terminal = document.getElementById('terminal');\n  const input = document.getElementById('command-input');\n  const promptStr = '$';\n\n  // Simple file system structure (mock)\n  let fileSystem = {\n    '/': {\n      type: 'dir',\n      contents: {\n        'bin': {type: 'dir', contents: {}},\n        'usr': {type: 'dir', contents: {}},\n        'home': {type: 'dir', contents: {\n          'user': {type: 'dir', contents: {\n            'readme.txt': {type: 'file', content: \"Welcome to the Mini Browser VM!\\nType 'htop' to show system info.\\nTry usual commands: ls, cat, echo, help, clear.\"}\n          }}\n        }},\n      }\n    }\n  };\n\n  // Current working directory\n  let cwd = '/home/user';\n\n  // Utility functions\n  function pathToArray(path) {\n    if (!path) return [];\n    return path.split('/').filter(x => x.length);\n  }\n  function resolvePath(p) {\n    if (!p) return cwd;\n    if (p.startsWith('/')) {\n      // Absolute path\n      return '/' + pathToArray(p).join('/');\n    } else {\n      // Relative path\n      let c = pathToArray(cwd);\n      let parts = pathToArray(p);\n      for (let part of parts) {\n        if (part === '.') continue;\n        if (part === '..') {\n          if (c.length > 0) c.pop();\n          continue;\n        }\n        c.push(part);\n      }\n      return '/' + c.join('/');\n    }\n  }\n  function getNode(path) {\n    let parts = pathToArray(path);\n    let node = fileSystem['/'];\n    for (let p of parts) {\n      if (!node.contents || !node.contents[p]) return null;\n      node = node.contents[p];\n    }\n    return node;\n  }\n  function isDir(path) {\n    let node = getNode(path);\n    return node && node.type === 'dir';\n  }\n  function isFile(path) {\n    let node = getNode(path);\n    return node && node.type === 'file';\n  }\n\n  // Print helpers\n  function printLine(txt = '') {\n    terminal.textContent += txt + '\\n';\n    terminal.scrollTop = terminal.scrollHeight;\n  }\n  function clearScreen() {\n    terminal.textContent = '';\n  }\n\n  // Command implementations\n\n  // 'help' command\n  function cmd_help(args) {\n    printLine(`Available commands:\n  help         Show this help\n  clear        Clear the terminal\n  ls [dir]     List directory\n  cd [dir]     Change directory\n  pwd          Print working directory\n  cat file     Show file contents\n  echo args    Print args\n  htop         Show browser memory & CPU info\n  date         Show current date/time\n  uname [-a]   Show system info\n  exit         Clear terminal\n`);\n  }\n\n  // 'ls' command\n  function cmd_ls(args) {\n    let target = args[0] ? resolvePath(args[0]) : cwd;\n    let node = getNode(target);\n    if (!node) {\n      printLine(`ls: cannot access '${args[0] || ''}': No such file or directory`);\n      return;\n    }\n    if (node.type === 'file') {\n      printLine(args[0]);\n      return;\n    }\n    let entries = Object.keys(node.contents).sort();\n    printLine(entries.join('  '));\n  }\n\n  // 'cd' command\n  function cmd_cd(args) {\n    let target = args[0] ? resolvePath(args[0]) : '/home/user';\n    let node = getNode(target);\n    if (!node || node.type !== 'dir') {\n      printLine(`cd: no such file or directory: ${args[0] || ''}`);\n      return;\n    }\n    cwd = target;\n  }\n\n  // 'pwd' command\n  function cmd_pwd(args) {\n    printLine(cwd);\n  }\n\n  // 'cat' command\n  function cmd_cat(args) {\n    if (!args[0]) {\n      printLine('cat: missing operand');\n      return;\n    }\n    let target = resolvePath(args[0]);\n    let node = getNode(target);\n    if (!node) {\n      printLine(`cat: ${args[0]}: No such file or directory`);\n      return;\n    }\n    if (node.type !== 'file') {\n      printLine(`cat: ${args[0]}: Is a directory`);\n      return;\n    }\n    printLine(node.content);\n  }\n\n  // 'echo' command\n  function cmd_echo(args) {\n    printLine(args.join(' '));\n  }\n  // 'clear' command\n  function cmd_clear() {\n    clearScreen();\n  }\n\n  // 'date' command\n  function cmd_date() {\n    printLine(new Date().toString());\n  }\n\n  // 'uname' command\n  function cmd_uname(args) {\n    /*\n    Options:\n    -a : all info\n    */\n    const nav = navigator;\n    if (args.length && args[0] === '-a') {\n      printLine(`Linux mini-vm 5.0.0-0-browser #1 SMP Fri Jun 7 12:00:00 UTC 2024 x86_64 GNU/Linux\nBrowser: ${nav.appName} ${nav.appVersion}\nPlatform: ${nav.platform}\nUserAgent: ${nav.userAgent}`);\n    } else {\n      printLine('Linux');\n    }\n  }\n\n  // 'exit' command (just clear)\n  function cmd_exit() {\n    clearScreen();\n    printLine('Session ended. Refresh to restart.');\n    input.disabled = true;\n  }\n\n  // 'htop' command: show simulated system usage from browser APIs\n  // We will try to show CPU usage and memory info by sampling performance\n  // Use performance.memory if available (Chrome mostly)\n  // CPU usage approximated by event loop blocking/fps info from requestAnimationFrame?\n\n  // We'll create a dynamic htop like display that updates for 5 seconds,\n  // then stops.\n\n  function cmd_htop() {\n    clearScreen();\n\n    printLine('htop - Mini Browser VM System Monitor');\n    printLine('(refreshing for 5 seconds, then returning to prompt)');\n    printLine('');\n\n    // Prepare live updating output area\n    let intervalId = null;\n    let count = 0;\n    const maxCount = 50; // 5 seconds @ 100ms update\n\n    // CPU usage estimation: measure event-loop delay\n    let lastTime = performance.now();\n    let delays = [];\n\n    // Get memory info if available\n    function getMemInfo() {\n      if (performance && performance.memory) {\n        let mem = performance.memory;\n        // mem.usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit all in bytes\n        return {\n          used: mem.usedJSHeapSize,\n          total: mem.jsHeapSizeLimit,\n        };\n      }\n      return null;\n    }\n\n    // Format bytes\n    function formatBytes(bytes) {\n      if (bytes < 1024) return bytes + ' B';\n      let kb = bytes / 1024;\n      if (kb < 1024) return kb.toFixed(1) + ' KB';\n      let mb = kb / 1024;\n      return mb.toFixed(2) + ' MB';\n    }\n\n    // draw loadbars\n    function bar(percentage, length=20) {\n      let fullBlocks = Math.round((percentage / 100) * length);\n      if (fullBlocks > length) fullBlocks = length;\n      let emptyBlocks = length - fullBlocks;\n      return '\\x1b[42m' + ' '.repeat(fullBlocks) + '\\x1b[0m' + ' '.repeat(emptyBlocks);\n    }\n\n    function drawBar(percentage, length=20) {\n      // We'll simulate a green bar inside brackets using unicode block elements and CSS styling:\n      // But terminal is plain text - we can simulate with █ and ░\n\n      let fullLength = Math.round((percentage / 100) * length);\n      let emptyLength = length - fullLength;\n      let fullBar = '█'.repeat(fullLength);\n      let emptyBar = '░'.repeat(emptyLength);\n      return fullBar + emptyBar;\n    }\n\n    function printHtop() {\n      // Clear terminal for every redraw (simulate clear)\n      terminal.textContent = '';\n      printLine('htop - Mini Browser VM System Monitor');\n      printLine('');\n\n      // CPU Usage calculated from event-loop delays\n\n      let meanDelay = 0;\n      if (delays.length > 0) {\n        let sum = 0;\n        for (let d of delays) sum += d;\n        meanDelay = sum / delays.length;\n      }\n\n      // Typical frame budget ~16ms for 60fps\n      // event-loop delay >16ms means CPU busy or slow\n\n      let loadPercent = Math.min(100, (meanDelay / 16) * 100);\n      if (loadPercent < 0) loadPercent = 0;\n\n      // Print CPU usage bar\n      printLine(`CPU Usage:` + ' ' + drawBar(loadPercent, 30) + ` ${loadPercent.toFixed(0)}%`);\n\n      // Memory info\n      let mem = getMemInfo();\n      if (mem) {\n        let usedPercent = (mem.used / mem.total) * 100;\n        printLine(`Memory Usage:` + ' ' + drawBar(usedPercent, 30) + ` ${formatBytes(mem.used)} / ${formatBytes(mem.total)} (${usedPercent.toFixed(0)}%)`);\n      } else {\n        printLine('Memory Usage: Not supported in this browser.');\n      }\n\n      // Print seconds elapsed (fake uptime)\n      printLine('');\n      printLine(`Uptime: ${(count*0.1).toFixed(1)} s`);\n\n      printLine('');\n      printLine(`Press Ctrl+C or wait 5 seconds to exit htop.`);\n    }\n\n    // We use requestAnimationFrame to track event loop lag\n\n    function rafTick(now) {\n      let delay = now - lastTime - 16; // expected 16 ms frame duration\n      if (delay < 0) delay = 0;\n      delays.push(delay);\n      if (delays.length > 20) delays.shift(); // keep last 20 samples\n      lastTime = now;\n      count++;\n      printHtop();\n\n      if (count >= maxCount) {\n        clearInterval(intervalId);\n        printLine('\\nhtop ended.\\n');\n        printLine(promptStr + ' ');\n        input.disabled = false;\n        input.focus();\n        return;\n      }\n      rafId = requestAnimationFrame(rafTick);\n    }\n    // Disable input while htop runs\n    input.disabled = true;\n    input.value = '';\n    input.blur();\n\n    let rafId;\n\n    // Start rAF loop\n    lastTime = performance.now();\n    rafId = requestAnimationFrame(rafTick);\n\n    // Also allow user to exit htop by Ctrl+C\n    function onKeydown(e) {\n      if (e.ctrlKey && e.key === 'c') {\n        if (rafId) cancelAnimationFrame(rafId);\n        clearInterval(intervalId);\n        document.removeEventListener('keydown', onKeydown);\n        printLine('\\nhtop interrupted by user.\\n');\n        printLine(promptStr + ' ');\n        input.disabled = false;\n        input.focus();\n      }\n    }\n    document.addEventListener('keydown', onKeydown);\n  }\n\n  // Command Map\n  const commands = {\n    'help': cmd_help,\n    'clear': cmd_clear,\n    'ls': cmd_ls,\n    'cd': cmd_cd,\n    'pwd': cmd_pwd,\n    'cat': cmd_cat,\n    'echo': cmd_echo,\n    'date': cmd_date,\n    'uname': cmd_uname,\n    'exit': cmd_exit,\n    'htop': cmd_htop,\n  };\n\n  // Interpret and run command line text\n  function runCommand(line) {\n    line = line.trim();\n    if (!line) return;\n    printLine(promptStr + ' ' + line);\n    let tokens = [];\n    let word = '';\n    let inQuotes = false;\n    for (let i = 0; i < line.length; i++) {\n      let ch = line[i];\n      if (ch === '\"') {\n        inQuotes = !inQuotes;\n        continue;\n      }\n      if (!inQuotes && /\\s/.test(ch)) {\n        if (word.length) {\n          tokens.push(word);\n          word = '';\n        }\n      } else {\n        word += ch;\n      }\n    }\n    if (word.length) tokens.push(word);\n    if (tokens.length === 0) return;\n\n    let cmd = tokens[0];\n    let args = tokens.slice(1);\n    if (commands[cmd]) {\n      commands[cmd](args);\n    } else {\n      printLine(`${cmd}: command not found`);\n    }\n  }\n\n\n  input.addEventListener('keydown', e => {\n    if (e.key === 'Enter') {\n      let val = input.value;\n      runCommand(val);\n      input.value = '';\n      // Keep focus for next command\n      e.preventDefault();\n    }\n  });\n\n  // On page load, print welcome screen and focus input\n  clearScreen();\n  printLine('Welcome to the Mini Browser VM!');\n  printLine('Type \"help\" to see available commands.');\n  printLine('');\n  input.focus();\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}