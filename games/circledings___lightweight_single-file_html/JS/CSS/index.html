<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CircleDings â€“ Enhanced, Animated, Vanilla HTML/JS</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      color: #eaeaea;
      /* Subtle animated background gradient for depth */
      background: #0f1220;
      background: linear-gradient(135deg, #0f1220 0%, #1a1030 40%, #0f1220 100%);
      background-size: 400% 400%;
      animation: bgShift 20s ease infinite;
    }
    @keyframes bgShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Board holds all circles */
    #board {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      cursor: default;
    }

    /* Circle visuals */
    .circle {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      box-shadow: 0 6px 14px rgba(0,0,0,.35);
      will-change: transform;
      touch-action: none;
      user-select: none;
      transition: box-shadow .25s;
    }
    .circle:hover { box-shadow: 0 8px 22px rgba(0,0,0,.5); }

    /* Drag/selection visuals */
    .circle.dragging {
      box-shadow: 0 0 0 rgba(0,0,0,0);
      outline: 2px solid rgba(255,255,255,.9);
      outline-offset: -6px;
    }

    /* Pop (removal) animation */
    .circle.pop {
      transition: transform 220ms ease-out, opacity 220ms ease-out;
      transform: scale(0.0);
      opacity: 0;
    }

    /* Particles for pops */
    .particle {
      position: absolute;
      width: 6px; height: 6px;
      border-radius: 50%;
      background: white;
      pointer-events: none;
      will-change: transform, opacity;
      opacity: 0.0;
      transform: translate3d(0,0,0) scale(1);
    }
    @keyframes floatOut {
      0% { transform: translate3d(var(--dx), var(--dy), 0) scale(1); opacity: 1; }
      100% { transform: translate3d(calc(var(--dx) * 6), calc(var(--dy) * 6), 0) scale(0.3); opacity: 0; }
    }
    .particle.animate {
      animation: floatOut 600ms ease-out forwards;
    }

    /* Controls panel */
    #controls {
      position: fixed;
      top: 14px;
      left: 14px;
      width: min(420px, 92vw);
      background: rgba(10, 10, 20, 0.84);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 12px;
      padding: 12px 14px;
      z-index: 10;
      color: #eaeaea;
      box-shadow: 0 10px 40px rgba(0,0,0,.4);
      backdrop-filter: blur(4px);
    }
    #controls h1 {
      font-size: 14px;
      margin: 2px 0 8px;
      letter-spacing: .4px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      margin: 8px 0;
    }
    label { font-size: 12px; opacity: .95; }
    input[type="range"] { width: 100%; }
    select, button {
      background: #1e1f2a;
      color: #eaeaea;
      border: 1px solid rgba(255,255,255,.25);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 13px;
    }
    button.primary {
      background: linear-gradient(135deg, #5d8cff, #2f7cff);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    button.secondary {
      background: #2a2b3a;
      border: 1px solid rgba(255,255,255,.25);
      color: #eaeaea;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    #status {
      font-size: 12px;
      opacity: .8;
      margin-top: 6px;
    }

    /* HUD badge for mode */
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.18);
    }

    /* small responsive tweak */
    @media (max-width: 720px) {
      #controls { width: calc(100% - 28px); left:14px; top: 12px; }
    }
  </style>
</head>
<body>
  <div id="board" aria-label="Circle board containing animated circles" role="region"></div>

  <div id="controls" aria-label="Circle controls">
    <h1>CircleDings Studio</h1>

    <div class="row" title="Number of circles">
      <label for="count">Circles</label>
      <input id="count" type="range" min="10" max="200" value="60" step="1" />
    </div>
    <div class="row" title="Animation mode">
      <label for="mode">Mode</label>
      <select id="mode">
        <option value="floating">Floating</option>
        <option value="orbit">Orbit</option>
        <option value="breathing">Breathing</option>
        <option value="spiral">Color Spiral</option>
      </select>
    </div>
    <div class="row" style="align-items:center;">
      <div style="display:flex;gap:8px;align-items:center;">
        <span class="badge" id="soundBadge">Sound: On</span>
      </div>
      <button id="soundBtn" class="secondary" title="Toggle sound">Toggle Sound</button>
    </div>
    <div class="row" style="gap:6px;">
      <button id="pauseBtn" class="secondary" title="Pause/resume animation">Pause</button>
      <button id="resetBtn" class="secondary" title="Reset circles to defaults">Reset</button>
      <button id="shuffleBtn" class="secondary" title="Regenerate positions">Shuffle</button>
    </div>

    <div id="status" aria-live="polite"></div>
  </div>

  <script>
  (function() {
    // Core state
    const board = document.getElementById('board');
    const countInput = document.getElementById('count');
    const modeSelect = document.getElementById('mode');
    const soundBtn = document.getElementById('soundBtn');
    const soundBadge = document.getElementById('soundBadge');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const statusEl = document.getElementById('status');

    let circles = []; // array of circle objects
    let paused = false;
    let audioCtx = null;
    let dingBuffer = null;
    let soundEnabled = true;
    let lastTime = performance.now();
    let draggingIndex = -1;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let dragStartX = 0;
    let dragStartY = 0;
    let gridSeed = Math.random() * 1e9;

    // Layout helpers
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function initAudio() {
      if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        audioCtx = new Ctx();
      }
      if (!dingBuffer) {
        createDingBuffer();
      }
    }

    function createDingBuffer() {
      if (!audioCtx) return;
      const duration = 0.25;
      const sr = audioCtx.sampleRate;
      const length = Math.floor(sr * duration);
      const buffer = audioCtx.createBuffer(1, length, sr);
      const data = buffer.getChannelData(0);
      const fStart = 900, fEnd = 250;
      for (let i = 0; i < length; i++) {
        const t = i / sr;
        const env = Math.exp(-6 * t);
        const f = fStart + (fEnd - fStart) * (t / duration);
        data[i] = Math.sin(2 * Math.PI * f * t) * env;
      }
      dingBuffer = buffer;
    }

    function playDing() {
      if (!soundEnabled || !audioCtx || !dingBuffer) return;
      if (audioCtx.state === 'suspended') {
        try { audioCtx.resume(); } catch(e) {}
      }
      const src = audioCtx.createBufferSource();
      src.buffer = dingBuffer;
      const gain = audioCtx.createGain();
      gain.gain.value = 0.9;
      src.connect(gain);
      gain.connect(audioCtx.destination);
      src.start();
    }

    function unlockAudioIfNeeded() {
      if (!soundEnabled) return;
      if (!audioCtx) initAudio();
      if (audioCtx.state === 'suspended') {
        try { audioCtx.resume(); } catch(e) { /* ignore */ }
      }
      if (!dingBuffer) createDingBuffer();
    }

    function newColor(h = Math.floor(Math.random()*360)) {
      return `hsl(${h}, 85%, 60%)`;
    }

    // Initialize circles based on count
    function initCircles(count) {
      circles = [];
      const w = window.innerWidth;
      const h = window.innerHeight;
      const maxR = Math.max(8, Math.min(60, Math.floor(Math.min(w, h) * 0.08)));
      for (let i = 0; i < count; i++) {
        // Diverse radii
        const r = Math.floor(rand(8, maxR));
        const x = Math.floor(rand(r, w - r));
        const y = Math.floor(rand(r, h - r));
        const hue = Math.floor(Math.random() * 360);
        // Each circle knows its type depending on mode
        const el = document.createElement('div');
        el.className = 'circle';
        el.style.width = (2 * r) + 'px';
        el.style.height = (2 * r) + 'px';
        el.style.left = '0px';
        el.style.top = '0px';
        el.style.background = newColor(hue);
        el.style.transform = `translate3d(${x - r}px, ${y - r}px, 0)`;
        el.setAttribute('data-id', i.toString());
        el.style.position = 'absolute';
        board.appendChild(el);

        const vx = rand(-50, 50);
        const vy = rand(-50, 50);

        circles.push({
          id: i,
          r,
          x,
          y,
          vx,
          vy,
          color: `hsl(${hue}, 85%, 60%)`,
          el,
          alive: true,
          dragging: false,
          modeTag: 'normal',
          orbitAngle: rand(0, Math.PI * 2),
          orbitRadius: rand(60, Math.min(w, h) * 0.28)
        });

        // Attach pointer handlers for drag/pop interactions
        (function(index) {
          el.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (paused) return;
            // Start potential drag
            draggingIndex = index;
            dragOffsetX = (circles[index].x) - e.clientX;
            dragOffsetY = (circles[index].y) - e.clientY;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            circles[index].dragging = false;
            el.classList.add('dragging');
            // Capture events on window
            window.setPointerCapture?.(e.pointerId);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            unlockAudioIfNeeded();
          }, { passive: false });
        })(i);
      }
    }

    function onPointerMove(e) {
      if (draggingIndex < 0) return;
      const c = circles[draggingIndex];
      if (!c) return;
      const px = e.clientX;
      const py = e.clientY;
      const nx = px + dragOffsetX;
      const ny = py + dragOffsetY;
      const w = window.innerWidth;
      const h = window.innerHeight;
      // compute new center
      const newX = clamp(nx, c.r, w - c.r);
      const newY = clamp(ny, c.r, h - c.r);
      c.x = newX;
      c.y = newY;
      // mark as dragging if moved sufficiently
      const moved = Math.hypot(px - dragStartX, py - dragStartY);
      if (moved > 6) c.dragging = true;
    }

    function onPointerUp(e) {
      if (draggingIndex < 0) return;
      const idx = draggingIndex;
      const c = circles[idx];
      if (c) {
        board.querySelectorAll('.circle')[idx]?.classList.remove('dragging');
      }
      // If not dragged, treat as pop
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      const dist = Math.hypot(dx, dy);
      if (dist < 6 && c) {
        popCircle(idx);
      }
      // Cleanup
      draggingIndex = -1;
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
      try { window.releasePointerCapture?.(e.pointerId); } catch(eunused) {}
    }

    function popCircle(index) {
      const c = circles[index];
      if (!c || !c.el) return;
      // burst particles
      spawnBurst(c.x, c.y, c.r);
      // remove visual
      c.el.classList.add('pop');
      // allow CSS transition then actually remove
      setTimeout(() => {
        if (c.el && c.el.parentElement === board) board.removeChild(c.el);
        circles.splice(index, 1);
      }, 240);
      // if last, clear
    }

    function spawnBurst(x, y, r) {
      const count = 10;
      for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        const px = x - r;
        const py = y - r;
        p.style.left = px + 'px';
        p.style.top = py + 'px';
        const angle = Math.random() * Math.PI * 2;
        const speed = rand(20, 120);
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;
        p.style.setProperty('--dx', dx.toFixed(2) + 'px');
        p.style.setProperty('--dy', dy.toFixed(2) + 'px');
        board.appendChild(p);
        // Force reflow then animate
        requestAnimationFrame(() => {
          p.classList.add('animate');
        });
        // cleanup after animation
        setTimeout(() => {
          if (p.parentElement === board) board.removeChild(p);
        }, 700);
      }
    }

    // Update loop: physics + modes
    function update(dt) {
      if (paused) return;
      const w = window.innerWidth;
      const h = window.innerHeight;

      // Determine time-based global modifiers
      const t = performance.now() / 1000;
      const mode = modeSelect.value;

      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        if (!c.alive) continue;

        // Skip updates if this circle is being dragged
        if (c.dragging) {
          // Keep in place; position set by drag above
        } else {
          if (mode === 'orbit') {
            // Each circle orbits around center
            const cx = w / 2;
            const cy = h / 2;
            const speed = 0.25 + (i % 7) * 0.02;
            c.orbitAngle += speed * dt;
            const rx = Math.cos(c.orbitAngle) * c.orbitRadius;
            const ry = Math.sin(c.orbitAngle) * c.orbitRadius;
            c.x = cx + rx;
            c.y = cy + ry;
          } else if (mode === 'breathing') {
            // gentle breathing by scaling; keep positions
            // We'll adjust a faux scale via color intensity
            // implement by slightly modulating radius visually
            // We'll just modify the render via transform scale; use a wobble factor
            // Nothing to update here besides transform
          } else if (mode === 'floating') {
            // Move with velocity, bounce on walls
            c.x += c.vx * dt;
            c.y += c.vy * dt;
            if (c.x < c.r) { c.x = c.r; c.vx *= -1; }
            if (c.y < c.r) { c.y = c.r; c.vy *= -1; }
            if (c.x > w - c.r) { c.x = w - c.r; c.vx *= -1; }
            if (c.y > h - c.r) { c.y = h - c.r; c.vy *= -1; }
          } else if (mode === 'spiral') {
            // move in a gentle spiral pattern by velocity + angular drift
            c.x += Math.cos(t * 0.6 + i * 0.3) * (20 * dt);
            c.y += Math.sin(t * 0.6 + i * 0.31) * (20 * dt);
            // bounds
            if (c.x < c.r) c.x = c.r;
            if (c.y < c.r) c.y = c.r;
            if (c.x > w - c.r) c.x = w - c.r;
            if (c.y > h - c.r) c.y = h - c.r;
          } else {
            // default drift
            c.x += c.vx * dt;
            c.y += c.vy * dt;
            if (c.x < c.r || c.x > w - c.r) c.vx = -c.vx;
            if (c.y < c.r || c.y > h - c.r) c.vy = -c.vy;
          }
        }
      }
    }

    // Render: apply transforms for every circle
    function render() {
      const mode = modeSelect.value;
      const t = performance.now() / 1000;
      // breathing factor
      const breathe = (mode === 'breathing') ? 0.15 * Math.sin(t * 3) : 0;

      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        const el = c.el;
        if (!el) continue;
        // compute scale for breathing or orbit glow
        let scale = 1;
        if (mode === 'breathing') {
          scale = 1 + 0.15 * Math.sin(t * 2 + i * 0.3);
        } else if (mode === 'spiral') {
          // subtle hue shift for spiral mode
          el.style.filter = `hue-rotate(${(t * 20 + i*2) % 360}deg) saturate(120%)`;
        } else {
          el.style.filter = '';
        }

        // position transforms
        const x = c.x;
        const y = c.y;
        // Use translate3d for smoother rendering
        el.style.transform = `translate3d(${x - c.r}px, ${y - c.r}px, 0) scale(${scale})`;
        // keep size stable (2*r)
        el.style.width = (2 * c.r) + 'px';
        el.style.height = (2 * c.r) + 'px';
        // fade out if somehow dead
        if (!c.alive) {
          el.style.opacity = '0';
        }
      }
    }

    // Animation loop
    function loop(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    // Helpers for control panel
    function regenOnCount() {
      // Remove all current DOM circles
      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        if (c && c.el && c.el.parentElement === board) board.removeChild(c.el);
      }
      // Re-create with new count
      const n = clamp(parseInt(countInput.value || 60, 10), 10, 200);
      initCircles(n);
      // small status update
      statusEl.textContent = `Regenerated ${n} circles in mode ${modeSelect.value}.`;
    }

    // Button handlers
    soundBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundBadge.textContent = 'Sound: ' + (soundEnabled ? 'On' : 'Off');
      if (soundEnabled) {
        initAudio();
      }
      // reflect in icon
      statusEl.textContent = 'Sound ' + (soundEnabled ? 'enabled' : 'muted');
    });

    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      statusEl.textContent = paused ? 'Animation paused' : 'Animation resumed';
    });

    resetBtn.addEventListener('click', () => {
      // Reset to defaults
      countInput.value = 60;
      modeSelect.value = 'floating';
      pauseBtn.textContent = 'Pause';
      paused = false;
      statusEl.textContent = 'Reset to defaults';
      // Rebuild
      regenOnCount();
    });

    shuffleBtn.addEventListener('click', () => {
      // Shuffle positions and small variations
      const w = window.innerWidth, h = window.innerHeight;
      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        c.x = rand(c.r, w - c.r);
        c.y = rand(c.r, h - c.r);
        c.vx = rand(-60, 60);
        c.vy = rand(-60, 60);
      }
      statusEl.textContent = 'Shuffled positions';
    });

    countInput.addEventListener('input', () => {
      // live feedback
      statusEl.textContent = `Circles: ${countInput.value}`;
    });

    modeSelect.addEventListener('change', () => {
      // When mode changes, re-position to some variation to emphasize
      regenOnCount();
      statusEl.textContent = `Mode: ${modeSelect.value}`;
    });

    // Resize handler to reflow circles
    window.addEventListener('resize', () => {
      // clamp existing circles within new bounds
      const w = window.innerWidth, h = window.innerHeight;
      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        c.x = clamp(c.x, c.r, w - c.r);
        c.y = clamp(c.y, c.r, h - c.r);
      }
    });

    // Unmute and start
    function start() {
      initAudio();
      // initial count and mode
      const initialCount = clamp(parseInt(countInput.value, 10), 10, 200);
      initCircles(initialCount);
      // initial status
      statusEl.textContent = 'CircleDings ready. Explore interactions: drag to move, click to pop, enjoy animations!';
      requestAnimationFrame(loop);
    }

    // Seeded initial creation
    start();
  })();
  </script>
</body>
</html>