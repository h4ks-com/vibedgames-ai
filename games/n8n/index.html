<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FlowForge — Single‑File Automation Suite</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c132b;
      --muted:#8fa3c7;
      --text:#e8f0ff;
      --accent:#6ea8fe;
      --accent2:#7cf7d4;
      --danger:#ff5c7a;
      --warn:#ffd166;
      --ok:#2ee59d;
      --line:rgba(255,255,255,.08);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius:14px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(110,168,254,.20), transparent 50%),
                  radial-gradient(1100px 700px at 90% 20%, rgba(124,247,212,.14), transparent 55%),
                  radial-gradient(900px 700px at 55% 95%, rgba(255,92,122,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow:hidden;
    }
    .app{
      height:100%;
      display:grid;
      grid-template-columns: 340px 1fr 420px;
      grid-template-rows: 56px 1fr;
      gap: 0;
    }
    header{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 14px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
      backdrop-filter: blur(6px);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      min-width:320px;
    }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background: conic-gradient(from 180deg, var(--accent), var(--accent2), var(--danger), var(--accent));
      box-shadow: 0 12px 25px rgba(110,168,254,.15);
      position:relative;
    }
    .logo:after{
      content:"";
      position:absolute; inset:8px;
      border-radius:7px;
      background: rgba(11,16,32,.75);
      border:1px solid rgba(255,255,255,.10);
    }
    .brand h1{
      font-size:14px; margin:0; letter-spacing:.4px;
      display:flex; align-items:baseline; gap:8px;
    }
    .badge{
      font-size:11px; color: var(--muted);
      border:1px solid var(--line);
      padding:2px 8px; border-radius:999px;
      background: rgba(255,255,255,.03);
    }
    .top-actions{
      display:flex; align-items:center; gap:8px;
    }
    button, .btn{
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      font: 600 12px/1 var(--sans);
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    button:hover, .btn:hover{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.15); }
    button:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(110,168,254,.26), rgba(110,168,254,.10));
      border-color: rgba(110,168,254,.35);
    }
    .btn.good{
      background: linear-gradient(180deg, rgba(46,229,157,.20), rgba(46,229,157,.08));
      border-color: rgba(46,229,157,.35);
    }
    .btn.danger{
      background: linear-gradient(180deg, rgba(255,92,122,.20), rgba(255,92,122,.08));
      border-color: rgba(255,92,122,.35);
    }
    .btn.tiny{
      padding:6px 8px;
      font-weight:600;
      border-radius:9px;
    }
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      color: var(--muted);
      border:1px solid var(--line);
      padding:2px 6px;
      border-radius:8px;
      background: rgba(255,255,255,.03);
    }
    .left, .right{
      overflow:auto;
      border-right:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent);
    }
    .right{
      border-right:none;
      border-left:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.02), transparent);
    }
    .center{
      overflow:hidden;
      position:relative;
    }
    .panel{
      padding:14px;
    }
    .section{
      margin-bottom:14px;
      background: rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
    }
    .section .hd{
      padding:10px 12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.02);
    }
    .section .hd h2{
      font-size:12px; margin:0; letter-spacing:.35px;
      color: rgba(232,240,255,.92);
      text-transform: uppercase;
    }
    .section .bd{ padding:12px; }
    .field{
      display:flex; flex-direction:column; gap:6px;
      margin-bottom:10px;
    }
    .field label{
      font-size:12px; color: var(--muted);
      display:flex; align-items:center; justify-content:space-between;
    }
    input[type="text"], input[type="number"], input[type="password"], textarea, select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(11,16,32,.55);
      color:var(--text);
      outline:none;
      font: 500 12.5px/1.35 var(--sans);
    }
    textarea{ min-height:92px; resize:vertical; font-family:var(--mono); font-size:12px; }
    select{ cursor:pointer; }
    .row{ display:flex; gap:10px; }
    .row .field{ flex:1; }
    .muted{ color: var(--muted); font-size:12px; line-height:1.35; }
    .list{
      display:flex; flex-direction:column; gap:8px;
    }
    .item{
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      border-radius: 12px;
      padding:10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
    }
    .item:hover{ background: rgba(255,255,255,.04); border-color: rgba(255,255,255,.14); }
    .item .meta{
      display:flex; flex-direction:column; gap:4px;
      min-width:0;
    }
    .item .title{
      font-weight:700; font-size:13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .item .sub{
      font-size:12px; color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .pill{
      font-size:11px;
      border:1px solid var(--line);
      padding:2px 7px;
      border-radius:999px;
      background: rgba(255,255,255,.03);
      color: var(--muted);
      white-space:nowrap;
    }
    .pill.ok{ border-color: rgba(46,229,157,.35); color: rgba(46,229,157,.9); background: rgba(46,229,157,.08); }
    .pill.warn{ border-color: rgba(255,209,102,.35); color: rgba(255,209,102,.95); background: rgba(255,209,102,.08); }
    .pill.bad{ border-color: rgba(255,92,122,.35); color: rgba(255,92,122,.95); background: rgba(255,92,122,.08); }
    .canvas-wrap{
      position:absolute; inset:0;
      overflow:hidden;
    }
    svg#canvas{
      width:100%; height:100%;
      background:
        radial-gradient(circle at 1px 1px, rgba(255,255,255,.06) 1px, transparent 1px);
      background-size: 22px 22px;
    }
    .node{
      filter: drop-shadow(0 18px 25px rgba(0,0,0,.35));
    }
    .node-rect{
      fill: rgba(15,23,51,.85);
      stroke: rgba(255,255,255,.12);
      stroke-width:1;
    }
    .node-rect.selected{
      stroke: rgba(110,168,254,.55);
      stroke-width:1.5;
    }
    .node-title{ font: 700 12px var(--sans); fill: rgba(232,240,255,.95); }
    .node-sub{ font: 500 11px var(--sans); fill: rgba(143,163,199,.95); }
    .port{
      fill: rgba(255,255,255,.10);
      stroke: rgba(255,255,255,.18);
      stroke-width:1;
    }
    .port:hover{
      fill: rgba(110,168,254,.28);
      stroke: rgba(110,168,254,.55);
    }
    .edge{
      fill:none;
      stroke: rgba(110,168,254,.55);
      stroke-width:2.2;
    }
    .edge.shadow{
      stroke: rgba(0,0,0,.35);
      stroke-width:6;
      stroke-linecap:round;
      filter: blur(0.2px);
    }
    .edge.bad{ stroke: rgba(255,92,122,.65); }
    .edge.good{ stroke: rgba(46,229,157,.55); }
    .hud{
      position:absolute;
      left:12px; bottom:12px;
      display:flex; gap:8px; align-items:center;
      padding:8px 10px;
      background: rgba(255,255,255,.03);
      border: 1px solid var(--line);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
      color: var(--muted);
      font-size:12px;
    }
    .toast{
      position:absolute;
      right:14px; bottom:14px;
      width:min(520px, calc(100% - 28px));
      display:flex;
      flex-direction:column;
      gap:8px;
      pointer-events:none;
    }
    .toast .t{
      pointer-events:auto;
      border:1px solid var(--line);
      background: rgba(15,23,51,.85);
      border-radius: 14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }
    .toast .t .msg{ font-size:12.5px; line-height:1.35; }
    .toast .t .msg b{ color: rgba(232,240,255,.95); }
    .toast .t .msg .small{ color: var(--muted); font-size:11.5px; margin-top:3px; font-family:var(--mono); white-space:pre-wrap; }
    .toast .t .x{
      pointer-events:auto;
      cursor:pointer;
      opacity:.8;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding:4px 7px;
      border-radius:10px;
      font: 700 12px/1 var(--sans);
      color: var(--text);
    }
    .split{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .hr{
      height:1px;
      background: var(--line);
      margin:10px 0;
    }
    .codebox{
      border:1px solid var(--line);
      background: rgba(11,16,32,.55);
      border-radius: 12px;
      padding:10px;
      font: 12px/1.4 var(--mono);
      color: rgba(232,240,255,.92);
      white-space:pre;
      overflow:auto;
      max-height:260px;
    }
    .minihelp{
      font-size:11.5px;
      color: var(--muted);
      line-height:1.35;
    }
    .tabs{
      display:flex; gap:8px;
    }
    .tab{
      padding:6px 9px;
      border:1px solid var(--line);
      border-radius: 999px;
      font-size:12px;
      cursor:pointer;
      background: rgba(255,255,255,.02);
      color: var(--muted);
      user-select:none;
    }
    .tab.active{
      background: rgba(110,168,254,.16);
      border-color: rgba(110,168,254,.35);
      color: rgba(232,240,255,.95);
    }
    .statusline{
      display:flex; justify-content:space-between; gap:10px;
      align-items:center;
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
    }
    .statusline .dot{
      width:8px; height:8px; border-radius:50%;
      background: rgba(143,163,199,.6);
      display:inline-block; margin-right:7px;
      box-shadow: 0 0 0 3px rgba(143,163,199,.10);
    }
    .statusline .dot.ok{ background: rgba(46,229,157,.95); box-shadow: 0 0 0 3px rgba(46,229,157,.12); }
    .statusline .dot.bad{ background: rgba(255,92,122,.95); box-shadow: 0 0 0 3px rgba(255,92,122,.12); }
    .statusline .dot.warn{ background: rgba(255,209,102,.95); box-shadow: 0 0 0 3px rgba(255,209,102,.12); }

    /* Modal */
    .modal-backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
      padding:18px;
    }
    .modal{
      width:min(980px, 100%);
      max-height: min(86vh, 920px);
      overflow:auto;
      border-radius: 18px;
      border:1px solid var(--line);
      background: rgba(15,23,51,.92);
      box-shadow: var(--shadow);
    }
    .modal .mh{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .modal .mh h3{ margin:0; font-size:13px; letter-spacing:.35px; text-transform:uppercase; color: rgba(232,240,255,.95); }
    .modal .mb{ padding:14px; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 1200px){
      .app{ grid-template-columns: 320px 1fr 380px; }
    }
    @media (max-width: 980px){
      body{ overflow:auto; }
      .app{ grid-template-columns: 1fr; grid-template-rows: 56px auto auto auto; }
      .left{ border-right:none; border-bottom:1px solid var(--line); }
      .center{ height: 62vh; }
      .right{ border-left:none; border-top:1px solid var(--line); }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <h1>FlowForge <span class="badge">single‑file automation suite</span></h1>
      <span class="kbd" title="Keyboard shortcuts">/ search · ⌘/Ctrl+Enter run · Del delete</span>
    </div>
    <div class="top-actions">
      <button class="btn tiny" id="btnHelp">Help</button>
      <button class="btn tiny" id="btnImport">Import</button>
      <button class="btn tiny" id="btnExport">Export</button>
      <button class="btn tiny" id="btnClear">New</button>
      <button class="btn primary" id="btnRun">Run Workflow</button>
    </div>
  </header>

  <aside class="left">
    <div class="panel">
      <div class="section">
        <div class="hd">
          <h2>Workflows</h2>
          <div class="split">
            <button class="btn tiny" id="btnSaveWF">Save</button>
            <button class="btn tiny" id="btnDupWF">Duplicate</button>
          </div>
        </div>
        <div class="bd">
          <div class="field">
            <label>Current workflow</label>
            <select id="wfSelect"></select>
          </div>
          <div class="field">
            <label>Name</label>
            <input id="wfName" type="text" placeholder="Workflow name" />
          </div>
          <div class="row">
            <div class="field">
              <label>Mode</label>
              <select id="wfMode">
                <option value="manual">Manual</option>
                <option value="schedule">Schedule (interval)</option>
              </select>
            </div>
            <div class="field">
              <label>Every (sec)</label>
              <input id="wfInterval" type="number" min="1" step="1" value="60" />
            </div>
          </div>
          <div class="statusline">
            <div><span class="dot" id="schedDot"></span><span id="schedLabel">Scheduler: off</span></div>
            <div class="split">
              <button class="btn tiny" id="btnToggleScheduler">Toggle</button>
              <span class="pill" id="wfDirty">saved</span>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="hd">
          <h2>Node Library</h2>
          <span class="pill">drag or click</span>
        </div>
        <div class="bd">
          <div class="field">
            <label>Search <span class="kbd">/</span></label>
            <input id="nodeSearch" type="text" placeholder="http, js, filter, map, email, webhook..." />
          </div>
          <div class="list" id="nodeLibrary"></div>
          <div class="hr"></div>
          <div class="minihelp">
            Tip: click a node type to add it to the canvas (near center). Drag nodes to rearrange. Connect output → input by dragging from a port.
          </div>
        </div>
      </div>

      <div class="section">
        <div class="hd">
          <h2>Integrations</h2>
          <span class="pill">tokens stored locally</span>
        </div>
        <div class="bd">
          <div class="field">
            <label>HTTP Base URL (optional)</label>
            <input id="cfgBaseUrl" type="text" placeholder="https://api.example.com" />
          </div>
          <div class="field">
            <label>API Key (optional)</label>
            <input id="cfgApiKey" type="password" placeholder="stored in localStorage" />
          </div>
          <div class="split">
            <button class="btn tiny" id="btnSaveSecrets">Save</button>
            <button class="btn tiny" id="btnClearSecrets">Clear</button>
            <span class="pill" id="secretsStatus">not set</span>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <main class="center">
    <div class="canvas-wrap">
      <svg id="canvas" viewBox="0 0 1400 900" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Workflow canvas">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="8.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(110,168,254,.8)"></path>
          </marker>
          <marker id="arrowGood" viewBox="0 0 10 10" refX="8.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(46,229,157,.9)"></path>
          </marker>
          <marker id="arrowBad" viewBox="0 0 10 10" refX="8.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(255,92,122,.9)"></path>
          </marker>
        </defs>
        <g id="edges"></g>
        <g id="nodes"></g>
        <g id="overlay"></g>
      </svg>
      <div class="hud" id="hud">
        <span class="pill">Canvas</span>
        <span id="hudText">0 nodes · 0 edges</span>
        <span class="pill">Zoom</span>
        <button class="btn tiny" id="zoomOut">−</button>
        <span class="kbd" id="zoomLabel">100%</span>
        <button class="btn tiny" id="zoomIn">+</button>
        <button class="btn tiny" id="fit">Fit</button>
      </div>
      <div class="toast" id="toast"></div>
    </div>
  </main>

  <aside class="right">
    <div class="panel">
      <div class="section">
        <div class="hd">
          <h2>Inspector</h2>
          <div class="tabs">
            <div class="tab active" data-tab="config">Config</div>
            <div class="tab" data-tab="test">Test</div>
            <div class="tab" data-tab="logs">Logs</div>
          </div>
        </div>
        <div class="bd" id="inspectorBody"></div>
      </div>

      <div class="section">
        <div class="hd">
          <h2>Execution</h2>
          <div class="split">
            <span class="pill" id="execState">idle</span>
            <button class="btn tiny" id="btnStop">Stop</button>
          </div>
        </div>
        <div class="bd">
          <div class="row">
            <div class="field">
              <label>Concurrency</label>
              <select id="execConcurrency">
                <option value="1">1 (sequential)</option>
                <option value="2">2</option>
                <option value="4">4</option>
              </select>
            </div>
            <div class="field">
              <label>Timeout (sec)</label>
              <input id="execTimeout" type="number" min="1" step="1" value="30" />
            </div>
          </div>
          <div class="field">
            <label>Input (JSON)</label>
            <textarea id="execInput">{ "hello": "world" }</textarea>
          </div>
          <div class="split">
            <button class="btn good" id="btnRun2">Run</button>
            <button class="btn" id="btnRunFrom">Run from selected</button>
            <button class="btn" id="btnValidate">Validate</button>
          </div>
          <div class="hr"></div>
          <div class="field">
            <label>Result</label>
            <div class="codebox" id="execResult">{}</div>
          </div>
        </div>
      </div>
    </div>
  </aside>
</div>

<div class="modal-backdrop" id="modal">
  <div class="modal">
    <div class="mh">
      <h3 id="modalTitle">Modal</h3>
      <button class="btn tiny" id="modalClose">Close</button>
    </div>
    <div class="mb" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  const $ = (q, el=document) => el.querySelector(q);
  const $$ = (q, el=document) => [...el.querySelectorAll(q)];
  const uid = () => Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const deepClone = (x)=>JSON.parse(JSON.stringify(x));
  const nowISO = ()=>new Date().toISOString();

  const storage = {
    get(key, fallback){
      try{
        const v = localStorage.getItem(key);
        if(v==null) return fallback;
        return JSON.parse(v);
      }catch{ return fallback; }
    },
    set(key, value){
      localStorage.setItem(key, JSON.stringify(value));
    },
    del(key){ localStorage.removeItem(key); }
  };

  // -------- Node registry (connectors) --------
  const REGISTRY = {
    "trigger.manual": {
      name: "Manual Trigger",
      category: "Triggers",
      icon: "▶",
      inputs: 0,
      outputs: 1,
      defaults: { note: "Starts the workflow." },
      run: async (ctx, input, cfg) => {
        return { ...input, _meta: { triggeredAt: nowISO(), trigger: "manual" }, note: cfg.note || "" };
      }
    },
    "trigger.webhook": {
      name: "Webhook Trigger (mock)",
      category: "Triggers",
      icon: "⟲",
      inputs: 0,
      outputs: 1,
      defaults: { path: "/hook", secret: "", sampleBody: '{"event":"ping"}' },
      run: async (ctx, input, cfg) => {
        // In a single-file browser app we can't host webhooks; simulate with provided body.
        let body = {};
        try{ body = JSON.parse(cfg.sampleBody || "{}"); }catch{ body = { raw: cfg.sampleBody }; }
        return { ...input, webhook: { path: cfg.path, body } };
      }
    },
    "core.set": {
      name: "Set (merge fields)",
      category: "Core",
      icon: "＋",
      inputs: 1,
      outputs: 1,
      defaults: { json: '{ "key": "value" }', mode: "merge" },
      run: async (ctx, input, cfg) => {
        let obj = {};
        try{ obj = JSON.parse(cfg.json || "{}"); }catch(e){ throw new Error("Set.json invalid JSON"); }
        if(cfg.mode === "replace") return obj;
        return { ...(input||{}), ...obj };
      }
    },
    "core.filter": {
      name: "Filter (JS expr)",
      category: "Core",
      icon: "⎇",
      inputs: 1,
      outputs: 1,
      defaults: { expr: "input != null && true" },
      run: async (ctx, input, cfg) => {
        const pass = safeEvalExpression(cfg.expr || "true", { input, ctx });
        if(!pass) return ctx.SKIP;
        return input;
      }
    },
    "core.map": {
      name: "Map (JS expr)",
      category: "Core",
      icon: "↦",
      inputs: 1,
      outputs: 1,
      defaults: { expr: "({ ...input, mappedAt: new Date().toISOString() })" },
      run: async (ctx, input, cfg) => {
        return safeEvalExpression(cfg.expr || "input", { input, ctx, Date });
      }
    },
    "core.code": {
      name: "Code (JS function)",
      category: "Core",
      icon: "⌬",
      inputs: 1,
      outputs: 1,
      defaults: { code:
`// Return a value or mutate/return input.
// Available: input, ctx, fetchJson, sleep
return { ...input, codedAt: new Date().toISOString() };` },
      run: async (ctx, input, cfg) => {
        return await safeRunUserCode(cfg.code || "return input;", { input, ctx });
      }
    },
    "core.delay": {
      name: "Delay",
      category: "Core",
      icon: "⏳",
      inputs: 1,
      outputs: 1,
      defaults: { ms: 500 },
      run: async (ctx, input, cfg) => {
        await sleep(Number(cfg.ms||0));
        return input;
      }
    },
    "http.request": {
      name: "HTTP Request",
      category: "HTTP",
      icon: "☍",
      inputs: 1,
      outputs: 1,
      defaults: {
        method: "GET",
        url: "https://jsonplaceholder.typicode.com/todos/1",
        headers: '{ "Accept": "application/json" }',
        body: "",
        responseType: "json"
      },
      run: async (ctx, input, cfg) => {
        let headers = {};
        try{ headers = cfg.headers ? JSON.parse(cfg.headers) : {}; }catch{ throw new Error("HTTP.headers invalid JSON"); }
        const url = resolveTemplate(cfg.url || "", input);
        const method = (cfg.method || "GET").toUpperCase();
        const init = { method, headers: { ...headers } };
        if(ctx.secrets.apiKey && !init.headers["Authorization"]) init.headers["Authorization"] = `Bearer ${ctx.secrets.apiKey}`;
        if(method !== "GET" && method !== "HEAD"){
          init.body = resolveTemplate(cfg.body || "", input);
        }
        const controller = new AbortController();
        const t = setTimeout(()=>controller.abort(), ctx.timeoutMs);
        let res;
        try{
          res = await fetch(url, { ...init, signal: controller.signal });
        }finally{
          clearTimeout(t);
        }
        const text = await res.text();
        let parsed = text;
        if((cfg.responseType||"json")==="json"){
          try{ parsed = text ? JSON.parse(text) : null; }catch{ parsed = { _raw: text }; }
        }
        return { ...input, http: { url, method, status: res.status, ok: res.ok, data: parsed } };
      }
    },
    "data.json.parse": {
      name: "JSON Parse",
      category: "Data",
      icon: "{}",
      inputs: 1,
      outputs: 1,
      defaults: { path: "text", outPath: "json" },
      run: async (ctx, input, cfg) => {
        const text = getPath(input, cfg.path || "text");
        if(typeof text !== "string") throw new Error("JSON Parse: input at path is not string");
        let parsed;
        try{ parsed = JSON.parse(text); }catch(e){ throw new Error("JSON Parse: invalid JSON"); }
        const out = deepClone(input||{});
        setPath(out, cfg.outPath || "json", parsed);
        return out;
      }
    },
    "data.json.stringify": {
      name: "JSON Stringify",
      category: "Data",
      icon: "⇢",
      inputs: 1,
      outputs: 1,
      defaults: { path: "", pretty: true, outPath: "text" },
      run: async (ctx, input, cfg) => {
        const v = cfg.path ? getPath(input, cfg.path) : input;
        const out = deepClone(input||{});
        setPath(out, cfg.outPath || "text", JSON.stringify(v, null, cfg.pretty ? 2 : 0));
        return out;
      }
    },
    "util.log": {
      name: "Log",
      category: "Utility",
      icon: "≡",
      inputs: 1,
      outputs: 1,
      defaults: { message: "Input:", level: "info" },
      run: async (ctx, input, cfg) => {
        ctx.log(cfg.level || "info", cfg.message || "Log", input);
        return input;
      }
    },
    "util.throw": {
      name: "Throw Error",
      category: "Utility",
      icon: "!",
      inputs: 1,
      outputs: 1,
      defaults: { message: "Something went wrong" },
      run: async () => { throw new Error("Throw: " + (arguments[2]?.message || "Error")); }
    }
  };

  const NODE_TYPES = Object.entries(REGISTRY).map(([type, def]) => ({ type, ...def }))
    .sort((a,b)=> (a.category+a.name).localeCompare(b.category+b.name));

  // -------- Helpers --------
  function toast(title, detail="", kind="info", ttl=5000){
    const box = $("#toast");
    const el = document.createElement("div");
    el.className = "t";
    const pill = kind==="ok" ? "ok" : kind==="bad" ? "bad" : kind==="warn" ? "warn" : "";
    el.innerHTML = `
      <div class="msg">
        <b>${escapeHtml(title)}</b> <span class="pill ${pill}">${escapeHtml(kind)}</span>
        ${detail?`<div class="small">${escapeHtml(detail)}</div>`:""}
      </div>
      <div class="x" title="dismiss">×</div>
    `;
    $(".x", el).onclick = () => el.remove();
    box.appendChild(el);
    setTimeout(()=>{ if(el.isConnected) el.remove(); }, ttl);
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  function resolveTemplate(str, input){
    // {{path.to.value}} with simple dot paths
    return String(str).replace(/\{\{\s*([a-zA-Z0-9_.\[\]]+)\s*\}\}/g, (_,p)=>{
      const v = getPath(input, p);
      if(v==null) return "";
      if(typeof v === "object") return JSON.stringify(v);
      return String(v);
    });
  }

  function getPath(obj, path){
    if(path==="" || path==null) return obj;
    const parts = String(path).replace(/\[(\d+)\]/g, ".$1").split(".").filter(Boolean);
    let cur = obj;
    for(const k of parts){
      if(cur==null) return undefined;
      cur = cur[k];
    }
    return cur;
  }
  function setPath(obj, path, value){
    const parts = String(path).replace(/\[(\d+)\]/g, ".$1").split(".").filter(Boolean);
    if(parts.length===0) throw new Error("setPath: empty path");
    let cur = obj;
    for(let i=0;i<parts.length-1;i++){
      const k = parts[i];
      if(cur[k]==null || typeof cur[k] !== "object") cur[k] = {};
      cur = cur[k];
    }
    cur[parts[parts.length-1]] = value;
  }

  function safeEvalExpression(expr, scope){
    // expression only
    const keys = Object.keys(scope||{});
    const vals = keys.map(k=>scope[k]);
    // no access to global via strict + shadowing
    const fn = new Function(...keys, `"use strict"; return (${expr});`);
    return fn(...vals);
  }

  async function safeRunUserCode(code, scope){
    const api = {
      fetchJson: async (url, init={}) => {
        const controller = new AbortController();
        const t = setTimeout(()=>controller.abort(), scope.ctx.timeoutMs);
        try{
          const r = await fetch(url, { ...init, signal: controller.signal });
          const txt = await r.text();
          let j; try{ j = JSON.parse(txt); }catch{ j = { _raw: txt }; }
          return { status: r.status, ok: r.ok, data: j, headers: Object.fromEntries(r.headers.entries()) };
        } finally { clearTimeout(t); }
      },
      sleep
    };
    const keys = [...Object.keys(scope||{}), ...Object.keys(api)];
    const vals = [...Object.values(scope||{}), ...Object.values(api)];
    const wrapped = `
"use strict";
return (async () => {
${code}
})()
`;
    const fn = new Function(...keys, wrapped);
    return await fn(...vals);
  }

  // -------- App state --------
  const LS_KEY = "flowforge.v1";
  const LS_SECRETS = "flowforge.secrets.v1";

  const defaultWorkflow = () => ({
    id: uid(),
    name: "Demo: Fetch & Transform",
    mode: "manual",
    intervalSec: 60,
    nodes: [
      { id: uid(), type:"trigger.manual", x:220, y:170, cfg: deepClone(REGISTRY["trigger.manual"].defaults) },
      { id: uid(), type:"http.request", x:520, y:170, cfg: deepClone(REGISTRY["http.request"].defaults) },
      { id: uid(), type:"core.map", x:820, y:170, cfg: { expr: "({ title: input.http?.data?.title, done: input.http?.data?.completed, id: input.http?.data?.id })" } },
      { id: uid(), type:"util.log", x:1120, y:170, cfg: { message: "Output payload", level: "info" } }
    ],
    edges: []
  });

  function seedEdgesIfEmpty(wf){
    if(wf.edges?.length) return wf;
    const ids = wf.nodes.map(n=>n.id);
    wf.edges = [
      { id: uid(), from: ids[0], to: ids[1] },
      { id: uid(), from: ids[1], to: ids[2] },
      { id: uid(), from: ids[2], to: ids[3] }
    ];
    return wf;
  }

  const state = {
    workflows: [],
    currentId: null,
    dirty: false,
    selectedNodeId: null,
    selectedEdgeId: null,
    dragging: null,   // {id, dx, dy}
    connecting: null, // {fromId, x, y}
    pan: { x:0, y:0 },
    zoom: 1,
    running: false,
    stopRequested: false,
    logs: [],
    lastRunGraph: null,
    scheduler: { on:false, timer:null }
  };

  const secrets = storage.get(LS_SECRETS, { baseUrl:"", apiKey:"" });

  // -------- Persistence --------
  function load(){
    const saved = storage.get(LS_KEY, null);
    if(saved && saved.workflows && saved.workflows.length){
      state.workflows = saved.workflows;
      state.currentId = saved.currentId || saved.workflows[0].id;
    } else {
      const wf = seedEdgesIfEmpty(defaultWorkflow());
      state.workflows = [wf];
      state.currentId = wf.id;
    }
    $("#cfgBaseUrl").value = secrets.baseUrl || "";
    $("#cfgApiKey").value = secrets.apiKey || "";
    updateSecretsStatus();
  }
  function persist(){
    storage.set(LS_KEY, { workflows: state.workflows, currentId: state.currentId });
    setDirty(false);
  }
  function setDirty(v){
    state.dirty = v;
    const pill = $("#wfDirty");
    pill.textContent = v ? "unsaved" : "saved";
    pill.className = "pill " + (v ? "warn" : "ok");
  }

  function currentWF(){
    return state.workflows.find(w=>w.id===state.currentId);
  }

  // -------- UI: workflow list --------
  function renderWorkflowSelect(){
    const sel = $("#wfSelect");
    sel.innerHTML = "";
    for(const wf of state.workflows){
      const opt = document.createElement("option");
      opt.value = wf.id;
      opt.textContent = wf.name || "Untitled";
      sel.appendChild(opt);
    }
    sel.value = state.currentId;
    const wf = currentWF();
    $("#wfName").value = wf?.name || "";
    $("#wfMode").value = wf?.mode || "manual";
    $("#wfInterval").value = wf?.intervalSec || 60;
  }

  // -------- UI: node library --------
  function renderNodeLibrary(filter=""){
    const q = filter.trim().toLowerCase();
    const el = $("#nodeLibrary");
    el.innerHTML = "";
    const groups = new Map();
    for(const t of NODE_TYPES){
      const hay = (t.type+" "+t.name+" "+t.category).toLowerCase();
      if(q && !hay.includes(q)) continue;
      if(!groups.has(t.category)) groups.set(t.category, []);
      groups.get(t.category).push(t);
    }
    for(const [cat, items] of groups){
      const h = document.createElement("div");
      h.className = "muted";
      h.style.margin = "8px 0 4px";
      h.style.fontSize = "11.5px";
      h.textContent = cat.toUpperCase();
      el.appendChild(h);
      for(const t of items){
        const d = document.createElement("div");
        d.className = "item";
        d.innerHTML = `
          <div class="meta">
            <div class="title">${escapeHtml(t.icon)} ${escapeHtml(t.name)}</div>
            <div class="sub">${escapeHtml(t.type)}</div>
          </div>
          <div class="pill">${t.inputs}→${t.outputs}</div>
        `;
        d.onclick = () => addNode(t.type);
        el.appendChild(d);
      }
    }
    if(!el.children.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No node types found.";
      el.appendChild(empty);
    }
  }

  // -------- Canvas rendering & interaction --------
  const svg = $("#canvas");
  const gNodes = $("#nodes");
  const gEdges = $("#edges");
  const gOverlay = $("#overlay");

  function toWorld(clientX, clientY){
    const r = svg.getBoundingClientRect();
    const x = (clientX - r.left);
    const y = (clientY - r.top);
    // Convert screen coords to world coords with pan/zoom
    return {
      x: (x - state.pan.x) / state.zoom,
      y: (y - state.pan.y) / state.zoom
    };
  }
  function toScreen(worldX, worldY){
    return {
      x: worldX * state.zoom + state.pan.x,
      y: worldY * state.zoom + state.pan.y
    };
  }

  function nodeSizeFor(type){
    // fixed for simplicity
    return { w: 250, h: 78 };
  }

  function portPos(node, which){
    const {w,h} = nodeSizeFor(node.type);
    const y = node.y + h/2;
    if(which === "in") return { x: node.x + 10, y };
    return { x: node.x + w - 10, y };
  }

  function edgePath(fromNode, toNode){
    const a = portPos(fromNode, "out");
    const b = portPos(toNode, "in");
    const dx = Math.max(60, (b.x-a.x)*0.5);
    const c1 = { x: a.x + dx, y: a.y };
    const c2 = { x: b.x - dx, y: b.y };
    return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
  }

  function applyViewport(){
    const vb = svg.viewBox.baseVal;
    // Keep fixed viewBox; transform groups for pan/zoom
    const t = `translate(${state.pan.x} ${state.pan.y}) scale(${state.zoom})`;
    gEdges.setAttribute("transform", t);
    gNodes.setAttribute("transform", t);
    gOverlay.setAttribute("transform", t);
    $("#zoomLabel").textContent = Math.round(state.zoom*100) + "%";
  }

  function render(){
    const wf = currentWF();
    if(!wf) return;
    renderWorkflowSelect();
    $("#hudText").textContent = `${wf.nodes.length} nodes · ${wf.edges.length} edges`;
    renderEdges(wf);
    renderNodes(wf);
    renderOverlay(wf);
    renderInspector();
    applyViewport();
  }

  function renderEdges(wf){
    gEdges.innerHTML = "";
    for(const e of wf.edges){
      const from = wf.nodes.find(n=>n.id===e.from);
      const to = wf.nodes.find(n=>n.id===e.to);
      if(!from || !to) continue;
      const p = edgePath(from,to);
      const selected = state.selectedEdgeId === e.id;
      const runInfo = state.lastRunGraph?.edges?.[e.id];
      const cls = runInfo?.status === "ok" ? "edge good" : runInfo?.status==="bad" ? "edge bad" : "edge";
      const marker = runInfo?.status==="ok" ? "url(#arrowGood)" : runInfo?.status==="bad" ? "url(#arrowBad)" : "url(#arrow)";
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      const sh = document.createElementNS("http://www.w3.org/2000/svg","path");
      sh.setAttribute("d", p);
      sh.setAttribute("class", "edge shadow");
      sh.setAttribute("opacity", selected ? "0.75" : "0.45");
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", p);
      path.setAttribute("class", cls);
      path.setAttribute("marker-end", marker);
      path.setAttribute("opacity", selected ? "1" : "0.8");
      path.style.cursor = "pointer";
      path.addEventListener("mousedown", (ev)=>{
        ev.stopPropagation();
        selectEdge(e.id);
      });
      path.addEventListener("dblclick", (ev)=>{
        ev.stopPropagation();
        removeEdge(e.id);
      });
      g.appendChild(sh);
      g.appendChild(path);
      gEdges.appendChild(g);
    }
  }

  function renderNodes(wf){
    gNodes.innerHTML = "";
    for(const n of wf.nodes){
      const def = REGISTRY[n.type];
      const {w,h} = nodeSizeFor(n.type);
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("class","node");
      g.setAttribute("data-id", n.id);
      g.setAttribute("transform", `translate(${n.x} ${n.y})`);
      g.style.cursor = "grab";

      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("rx","14");
      rect.setAttribute("ry","14");
      rect.setAttribute("width", w);
      rect.setAttribute("height", h);
      rect.setAttribute("class", "node-rect" + (state.selectedNodeId===n.id ? " selected": ""));
      g.appendChild(rect);

      const title = document.createElementNS("http://www.w3.org/2000/svg","text");
      title.setAttribute("x","14"); title.setAttribute("y","28");
      title.setAttribute("class","node-title");
      title.textContent = `${def?.icon||"•"} ${def?.name||n.type}`;
      g.appendChild(title);

      const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
      sub.setAttribute("x","14"); sub.setAttribute("y","48");
      sub.setAttribute("class","node-sub");
      sub.textContent = n.type;
      g.appendChild(sub);

      const status = state.lastRunGraph?.nodes?.[n.id];
      if(status){
        const pill = document.createElementNS("http://www.w3.org/2000/svg","text");
        pill.setAttribute("x", w-14);
        pill.setAttribute("y", 28);
        pill.setAttribute("text-anchor", "end");
        pill.setAttribute("class", "node-sub");
        pill.textContent = status.status.toUpperCase();
        pill.setAttribute("fill", status.status==="ok" ? "rgba(46,229,157,.95)" : status.status==="bad" ? "rgba(255,92,122,.95)" : "rgba(255,209,102,.95)");
        g.appendChild(pill);
      }

      // ports
      if(def?.inputs){
        const pin = document.createElementNS("http://www.w3.org/2000/svg","circle");
        pin.setAttribute("class","port");
        pin.setAttribute("r","7");
        pin.setAttribute("cx","10");
        pin.setAttribute("cy", String(h/2));
        pin.style.cursor = "crosshair";
        pin.addEventListener("mousedown",(ev)=>{ ev.stopPropagation(); /* input port doesn't start connection */ });
        g.appendChild(pin);
      }
      if(def?.outputs){
        const pout = document.createElementNS("http://www.w3.org/2000/svg","circle");
        pout.setAttribute("class","port");
        pout.setAttribute("r","7");
        pout.setAttribute("cx", String(w-10));
        pout.setAttribute("cy", String(h/2));
        pout.style.cursor = "crosshair";
        pout.addEventListener("mousedown",(ev)=>{
          ev.stopPropagation();
          const pt = toWorld(ev.clientX, ev.clientY);
          state.connecting = { fromId: n.id, x: pt.x, y: pt.y };
          selectNode(n.id);
          render();
        });
        g.appendChild(pout);
      }

      g.addEventListener("mousedown",(ev)=>{
        ev.stopPropagation();
        const pt = toWorld(ev.clientX, ev.clientY);
        selectNode(n.id);
        state.dragging = { id: n.id, dx: pt.x - n.x, dy: pt.y - n.y };
        g.style.cursor = "grabbing";
      });
      g.addEventListener("dblclick",(ev)=>{
        ev.stopPropagation();
        openQuickEdit(n.id);
      });

      gNodes.appendChild(g);
    }
  }

  function renderOverlay(wf){
    gOverlay.innerHTML = "";
    if(state.connecting){
      const from = wf.nodes.find(n=>n.id===state.connecting.fromId);
      if(from){
        const a = portPos(from, "out");
        const b = { x: state.connecting.x, y: state.connecting.y };
        const dx = Math.max(60, (b.x-a.x)*0.5);
        const c1 = { x: a.x + dx, y: a.y };
        const c2 = { x: b.x - dx, y: b.y };
        const d = `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
        const sh = document.createElementNS("http://www.w3.org/2000/svg","path");
        sh.setAttribute("d", d);
        sh.setAttribute("class", "edge shadow");
        const p = document.createElementNS("http://www.w3.org/2000/svg","path");
        p.setAttribute("d", d);
        p.setAttribute("class", "edge");
        p.setAttribute("marker-end", "url(#arrow)");
        gOverlay.appendChild(sh);
        gOverlay.appendChild(p);
      }
    }
  }

  function selectNode(id){
    state.selectedNodeId = id;
    state.selectedEdgeId = null;
    render();
  }
  function selectEdge(id){
    state.selectedEdgeId = id;
    state.selectedNodeId = null;
    render();
  }
  function clearSelection(){
    state.selectedNodeId = null;
    state.selectedEdgeId = null;
    render();
  }

  function addNode(type){
    const wf = currentWF();
    const def = REGISTRY[type];
    if(!def) return;
    const center = { x: 700, y: 450 };
    const worldCenter = toWorld(svg.getBoundingClientRect().left + svg.clientWidth/2, svg.getBoundingClientRect().top + svg.clientHeight/2);
    const n = {
      id: uid(),
      type,
      x: Math.round((worldCenter?.x ?? center.x) - 120 + (Math.random()*24-12)),
      y: Math.round((worldCenter?.y ?? center.y) - 40 + (Math.random()*24-12)),
      cfg: deepClone(def.defaults || {})
    };
    wf.nodes.push(n);
    setDirty(true);
    selectNode(n.id);
    toast("Node added", `${type}`, "ok", 2200);
  }

  function removeNode(id){
    const wf = currentWF();
    const i = wf.nodes.findIndex(n=>n.id===id);
    if(i<0) return;
    wf.nodes.splice(i,1);
    wf.edges = wf.edges.filter(e=>e.from!==id && e.to!==id);
    setDirty(true);
    state.selectedNodeId = null;
    render();
    toast("Node deleted", id, "warn", 2200);
  }
  function removeEdge(id){
    const wf = currentWF();
    const i = wf.edges.findIndex(e=>e.id===id);
    if(i<0) return;
    wf.edges.splice(i,1);
    setDirty(true);
    state.selectedEdgeId = null;
    render();
    toast("Edge deleted", id, "warn", 2200);
  }

  function connect(fromId, toId){
    const wf = currentWF();
    if(fromId===toId) return;
    const from = wf.nodes.find(n=>n.id===fromId);
    const to = wf.nodes.find(n=>n.id===toId);
    if(!from || !to) return;
    const fromDef = REGISTRY[from.type], toDef = REGISTRY[to.type];
    if(!fromDef?.outputs) return;
    if(!toDef?.inputs) return;
    if(wf.edges.some(e=>e.from===fromId && e.to===toId)) return;
    wf.edges.push({ id: uid(), from: fromId, to: toId });
    setDirty(true);
    toast("Connected", `${fromDef.name} → ${toDef.name}`, "ok", 2000);
  }

  // Canvas background interactions: pan, connect completion
  let panning = null; // {x,y, panx,pany}
  svg.addEventListener("mousedown",(ev)=>{
    if(ev.button!==0) return;
    // background click clears selection
    clearSelection();
    // start panning with space or middle button; here: right click disabled; use Alt for pan
    if(ev.altKey){
      panning = { x: ev.clientX, y: ev.clientY, panx: state.pan.x, pany: state.pan.y };
    }
  });
  window.addEventListener("mousemove",(ev)=>{
    const wf = currentWF();
    if(state.dragging){
      const pt = toWorld(ev.clientX, ev.clientY);
      const n = wf.nodes.find(n=>n.id===state.dragging.id);
      if(n){
        n.x = Math.round(pt.x - state.dragging.dx);
        n.y = Math.round(pt.y - state.dragging.dy);
        setDirty(true);
        render();
      }
    } else if(state.connecting){
      const pt = toWorld(ev.clientX, ev.clientY);
      state.connecting.x = pt.x; state.connecting.y = pt.y;
      renderOverlay(wf);
    } else if(panning){
      state.pan.x = panning.panx + (ev.clientX - panning.x);
      state.pan.y = panning.pany + (ev.clientY - panning.y);
      applyViewport();
    }
  });
  window.addEventListener("mouseup",(ev)=>{
    const wf = currentWF();
    if(state.dragging){
      state.dragging = null;
      render();
    }
    if(state.connecting){
      // If mouse is over a node input port area, connect.
      const pt = toWorld(ev.clientX, ev.clientY);
      const target = hitTestNodeInput(wf, pt.x, pt.y);
      if(target){
        connect(state.connecting.fromId, target.id);
      }
      state.connecting = null;
      render();
    }
    panning = null;
  });

  // Zoom (wheel)
  svg.addEventListener("wheel",(ev)=>{
    ev.preventDefault();
    const delta = -ev.deltaY;
    const factor = delta > 0 ? 1.08 : 0.92;
    const before = toWorld(ev.clientX, ev.clientY);
    state.zoom = clamp(state.zoom * factor, 0.35, 2.2);
    const after = toWorld(ev.clientX, ev.clientY);
    // adjust pan to keep cursor stable
    state.pan.x += (after.x - before.x) * state.zoom;
    state.pan.y += (after.y - before.y) * state.zoom;
    applyViewport();
  }, { passive:false });

  function hitTestNodeInput(wf, x, y){
    for(const n of wf.nodes){
      const def = REGISTRY[n.type];
      if(!def?.inputs) continue;
      const {w,h} = nodeSizeFor(n.type);
      const px = n.x + 10, py = n.y + h/2;
      const d = Math.hypot(px-x, py-y);
      if(d <= 14) return n;
    }
    return null;
  }

  // Fit view
  function fitView(){
    const wf = currentWF();
    if(!wf.nodes.length){ state.pan={x:0,y:0}; state.zoom=1; applyViewport(); return; }
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const n of wf.nodes){
      const {w,h} = nodeSizeFor(n.type);
      minX = Math.min(minX, n.x);
      minY = Math.min(minY, n.y);
      maxX = Math.max(maxX, n.x+w);
      maxY = Math.max(maxY, n.y+h);
    }
    const pad = 90;
    minX-=pad; minY-=pad; maxX+=pad; maxY+=pad;
    const r = svg.getBoundingClientRect();
    const scaleX = r.width / (maxX-minX);
    const scaleY = r.height / (maxY-minY);
    state.zoom = clamp(Math.min(scaleX, scaleY), 0.35, 1.6);
    state.pan.x = -minX*state.zoom;
    state.pan.y = -minY*state.zoom;
    applyViewport();
  }

  $("#zoomIn").onclick = ()=>{ state.zoom = clamp(state.zoom*1.12, 0.35, 2.2); applyViewport(); };
  $("#zoomOut").onclick = ()=>{ state.zoom = clamp(state.zoom/1.12, 0.35, 2.2); applyViewport(); };
  $("#fit").onclick = ()=>fitView();

  // -------- Inspector --------
  const inspectorBody = $("#inspectorBody");
  let inspectorTab = "config";

  $$(".tab").forEach(t=>{
    t.onclick = ()=>{
      $$(".tab").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      inspectorTab = t.dataset.tab;
      renderInspector();
    };
  });

  function renderInspector(){
    const wf = currentWF();
    if(!wf) return;
    if(inspectorTab === "logs"){
      inspectorBody.innerHTML = `
        <div class="field">
          <label>Logs <span class="pill">${state.logs.length}</span></label>
          <div class="codebox" id="logsBox">${escapeHtml(state.logs.map(l=>`[${l.ts}] ${l.level.toUpperCase()} ${l.msg} ${l.data?JSON.stringify(l.data):""}`).join("\n")) || ""}</div>
        </div>
        <div class="split">
          <button class="btn tiny" id="btnCopyLogs">Copy</button>
          <button class="btn tiny" id="btnClearLogs">Clear</button>
        </div>
      `;
      $("#btnCopyLogs").onclick = async ()=> {
        await navigator.clipboard.writeText(state.logs.map(l=>`[${l.ts}] ${l.level.toUpperCase()} ${l.msg} ${l.data?JSON.stringify(l.data):""}`).join("\n"));
        toast("Copied logs", "", "ok", 1800);
      };
      $("#btnClearLogs").onclick = ()=>{ state.logs = []; renderInspector(); };
      return;
    }
    if(inspectorTab === "test"){
      const node = wf.nodes.find(n=>n.id===state.selectedNodeId);
      if(!node){
        inspectorBody.innerHTML = `<div class="muted">Select a node to test it.</div>`;
        return;
      }
      inspectorBody.innerHTML = `
        <div class="field">
          <label>Node</label>
          <div class="codebox">${escapeHtml(node.type)}\n${escapeHtml(REGISTRY[node.type]?.name||"")}</div>
        </div>
        <div class="field">
          <label>Test input (JSON)</label>
          <textarea id="nodeTestInput">{ "sample": true }</textarea>
        </div>
        <div class="split">
          <button class="btn good" id="btnTestNode">Run Node</button>
          <button class="btn" id="btnTestDownstream">Run from Node</button>
        </div>
        <div class="hr"></div>
        <div class="field">
          <label>Output</label>
          <div class="codebox" id="nodeTestOut">{}</div>
        </div>
      `;
      $("#btnTestNode").onclick = async ()=>{
        let input={};
        try{ input = JSON.parse($("#nodeTestInput").value || "{}"); }catch{ toast("Invalid JSON", "Test input", "bad"); return; }
        try{
          const ctx = makeExecContext();
          const out = await runSingleNode(ctx, node, input);
          $("#nodeTestOut").textContent = JSON.stringify(out, null, 2);
        }catch(e){
          $("#nodeTestOut").textContent = String(e?.stack||e);
        }
      };
      $("#btnTestDownstream").onclick = ()=> runWorkflow({ fromNodeId: node.id });
      return;
    }

    // config
    if(state.selectedEdgeId){
      const e = wf.edges.find(x=>x.id===state.selectedEdgeId);
      const from = wf.nodes.find(n=>n.id===e?.from);
      const to = wf.nodes.find(n=>n.id===e?.to);
      inspectorBody.innerHTML = `
        <div class="field">
          <label>Edge</label>
          <div class="codebox">${escapeHtml(e?.id||"")}</div>
        </div>
        <div class="field">
          <label>From → To</label>
          <div class="codebox">${escapeHtml(from?.type||"?")} → ${escapeHtml(to?.type||"?")}</div>
        </div>
        <div class="split">
          <button class="btn danger" id="btnDelEdge">Delete edge</button>
        </div>
        <div class="hr"></div>
        <div class="minihelp">Double‑click an edge to delete. Edges currently support 1 output → 1 input routing.</div>
      `;
      $("#btnDelEdge").onclick = ()=>removeEdge(e.id);
      return;
    }

    const node = wf.nodes.find(n=>n.id===state.selectedNodeId);
    if(!node){
      inspectorBody.innerHTML = `<div class="muted">Select a node on the canvas to configure it.</div>`;
      return;
    }
    const def = REGISTRY[node.type];
    const cfg = node.cfg || (node.cfg = {});
    const fields = buildCfgFields(node, def);
    inspectorBody.innerHTML = `
      <div class="field">
        <label>Node</label>
        <div class="codebox">${escapeHtml(def.icon||"•")} ${escapeHtml(def.name||node.type)}\n${escapeHtml(node.type)}\nID: ${escapeHtml(node.id)}</div>
      </div>
      ${fields}
      <div class="split">
        <button class="btn danger" id="btnDelNode">Delete node</button>
        <button class="btn" id="btnCenterNode">Center</button>
      </div>
      <div class="hr"></div>
      <div class="minihelp">
        Quick edit: double‑click a node. Connect: drag from right port to another node’s left port.
      </div>
    `;
    $("#btnDelNode").onclick = ()=>removeNode(node.id);
    $("#btnCenterNode").onclick = ()=>centerOnNode(node.id);
    // wire up inputs
    $$("[data-cfg-key]", inspectorBody).forEach(inp=>{
      inp.addEventListener("input", ()=>{
        const k = inp.dataset.cfgKey;
        let v = inp.value;
        if(inp.dataset.cfgType==="number") v = Number(v);
        cfg[k]=v;
        setDirty(true);
      });
    });
  }

  function buildCfgFields(node, def){
    const cfg = node.cfg || {};
    const type = node.type;
    const common = `
      <div class="field">
        <label>Label (optional)</label>
        <input data-cfg-key="_label" type="text" value="${escapeHtml(cfg._label||"")}" placeholder="Shown in logs (optional)" />
      </div>
    `;
    if(type==="http.request"){
      return common + `
        <div class="row">
          <div class="field">
            <label>Method</label>
            <select data-cfg-key="method">
              ${["GET","POST","PUT","PATCH","DELETE"].map(m=>`<option ${cfg.method===m?"selected":""}>${m}</option>`).join("")}
            </select>
          </div>
          <div class="field">
            <label>Response</label>
            <select data-cfg-key="responseType">
              <option value="json" ${cfg.responseType==="json"?"selected":""}>json</option>
              <option value="text" ${cfg.responseType==="text"?"selected":""}>text</option>
            </select>
          </div>
        </div>
        <div class="field">
          <label>URL <span class="pill">{{templating}}</span></label>
          <input data-cfg-key="url" type="text" value="${escapeHtml(cfg.url||"")}" />
        </div>
        <div class="field">
          <label>Headers (JSON)</label>
          <textarea data-cfg-key="headers">${escapeHtml(cfg.headers||"")}</textarea>
        </div>
        <div class="field">
          <label>Body (string, templated)</label>
          <textarea data-cfg-key="body">${escapeHtml(cfg.body||"")}</textarea>
        </div>
      `;
    }
    if(type==="core.code"){
      return common + `
        <div class="field">
          <label>Code (async JS)</label>
          <textarea data-cfg-key="code">${escapeHtml(cfg.code||"")}</textarea>
        </div>
      `;
    }
    if(type==="core.map" || type==="core.filter"){
      return common + `
        <div class="field">
          <label>Expression (JS)</label>
          <textarea data-cfg-key="expr">${escapeHtml(cfg.expr||"")}</textarea>
        </div>
      `;
    }
    if(type==="core.delay"){
      return common + `
        <div class="field">
          <label>Milliseconds</label>
          <input data-cfg-key="ms" data-cfg-type="number" type="number" min="0" step="50" value="${escapeHtml(cfg.ms??0)}" />
        </div>
      `;
    }
    if(type==="core.set"){
      return common + `
        <div class="row">
          <div class="field">
            <label>Mode</label>
            <select data-cfg-key="mode">
              <option value="merge" ${cfg.mode==="merge"?"selected":""}>merge</option>
              <option value="replace" ${cfg.mode==="replace"?"selected":""}>replace</option>
            </select>
          </div>
          <div class="field">
            <label>JSON</label>
            <span class="pill">object</span>
          </div>
        </div>
        <div class="field">
          <textarea data-cfg-key="json">${escapeHtml(cfg.json||"")}</textarea>
        </div>
      `;
    }
    if(type==="data.json.parse" || type==="data.json.stringify"){
      return common + `
        <div class="row">
          <div class="field">
            <label>Path</label>
            <input data-cfg-key="path" type="text" value="${escapeHtml(cfg.path||"")}" />
          </div>
          <div class="field">
            <label>Out path</label>
            <input data-cfg-key="outPath" type="text" value="${escapeHtml(cfg.outPath||"")}" />
          </div>
        </div>
        ${type==="data.json.stringify"?`
          <div class="field">
            <label>Pretty</label>
            <select data-cfg-key="pretty">
              <option value="true" ${(cfg.pretty===true || cfg.pretty==="true")?"selected":""}>true</option>
              <option value="false" ${(cfg.pretty===false || cfg.pretty==="false")?"selected":""}>false</option>
            </select>
          </div>`:""
        }
      `;
    }
    if(type==="util.log"){
      return common + `
        <div class="row">
          <div class="field">
            <label>Level</label>
            <select data-cfg-key="level">
              ${["debug","info","warn","error"].map(l=>`<option value="${l}" ${(cfg.level===l)?"selected":""}>${l}</option>`).join("")}
            </select>
          </div>
          <div class="field">
            <label>Message</label>
            <input data-cfg-key="message" type="text" value="${escapeHtml(cfg.message||"")}" />
          </div>
        </div>
      `;
    }
    if(type==="trigger.webhook"){
      return common + `
        <div class="row">
          <div class="field">
            <label>Path</label>
            <input data-cfg-key="path" type="text" value="${escapeHtml(cfg.path||"")}" />
          </div>
          <div class="field">
            <label>Secret</label>
            <input data-cfg-key="secret" type="password" value="${escapeHtml(cfg.secret||"")}" />
          </div>
        </div>
        <div class="field">
          <label>Sample Body (JSON)</label>
          <textarea data-cfg-key="sampleBody">${escapeHtml(cfg.sampleBody||"")}</textarea>
        </div>
      `;
    }
    // fallback: show any keys
    const keys = Object.keys(cfg).filter(k=>!k.startsWith("_"));
    return common + (keys.length ? keys.map(k=>`
      <div class="field">
        <label>${escapeHtml(k)}</label>
        <input data-cfg-key="${escapeHtml(k)}" type="text" value="${escapeHtml(cfg[k])}" />
      </div>`).join("") : `<div class="muted">No configurable fields.</div>`);
  }

  function centerOnNode(id){
    const wf = currentWF();
    const n = wf.nodes.find(n=>n.id===id);
    if(!n) return;
    const {w,h} = nodeSizeFor(n.type);
    const r = svg.getBoundingClientRect();
    const targetScreen = { x: r.width/2, y: r.height/2 };
    state.pan.x = targetScreen.x - (n.x + w/2) * state.zoom;
    state.pan.y = targetScreen.y - (n.y + h/2) * state.zoom;
    applyViewport();
  }

  function openQuickEdit(nodeId){
    const wf = currentWF();
    const node = wf.nodes.find(n=>n.id===nodeId);
    if(!node) return;
    const def = REGISTRY[node.type];
    showModal(`Quick Edit: ${def.name}`, `
      <div class="grid2">
        <div>
          <div class="field">
            <label>Node type</label>
            <div class="codebox">${escapeHtml(node.type)}\n${escapeHtml(def.name)}</div>
          </div>
          <div class="field">
            <label>Config (JSON)</label>
            <textarea id="qeCfg">${escapeHtml(JSON.stringify(node.cfg||{}, null, 2))}</textarea>
          </div>
          <div class="split">
            <button class="btn good" id="qeSave">Apply</button>
            <button class="btn" id="qePretty">Prettify</button>
          </div>
        </div>
        <div>
          <div class="field">
            <label>Notes</label>
            <div class="muted">
              This editor applies the config blob directly. Some nodes interpret fields as JSON/JS (e.g., HTTP headers, JS expressions).
            </div>
          </div>
          <div class="field">
            <label>Node preview</label>
            <div class="codebox" id="qePreview">${escapeHtml(JSON.stringify(node, null, 2))}</div>
          </div>
        </div>
      </div>
    `);
    $("#qePretty").onclick = ()=>{
      try{
        const obj = JSON.parse($("#qeCfg").value);
        $("#qeCfg").value = JSON.stringify(obj, null, 2);
      }catch{ toast("Invalid JSON", "Cannot prettify", "bad"); }
    };
    $("#qeSave").onclick = ()=>{
      try{
        const obj = JSON.parse($("#qeCfg").value);
        node.cfg = obj;
        setDirty(true);
        hideModal();
        render();
      }catch(e){
        toast("Invalid JSON", String(e), "bad");
      }
    };
  }

  // -------- Modal --------
  const modal = $("#modal");
  function showModal(title, html){
    $("#modalTitle").textContent = title;
    $("#modalBody").innerHTML = html;
    modal.style.display = "flex";
  }
  function hideModal(){ modal.style.display = "none"; }
  $("#modalClose").onclick = hideModal;
  modal.addEventListener("mousedown",(ev)=>{ if(ev.target===modal) hideModal(); });

  // -------- Execution engine --------
  function log(level, msg, data){
    state.logs.push({ ts: new Date().toLocaleTimeString(), level, msg, data });
    if(inspectorTab==="logs") renderInspector();
  }

  function makeExecContext(){
    const timeoutMs = Number($("#execTimeout").value||30)*1000;
    const ctx = {
      timeoutMs,
      SKIP: Symbol("SKIP"),
      secrets: { ...secrets },
      baseUrl: secrets.baseUrl || "",
      log,
      stopRequested: ()=>state.stopRequested
    };
    return ctx;
  }

  async function runSingleNode(ctx, node, input){
    const def = REGISTRY[node.type];
    if(!def) throw new Error("Unknown node type: " + node.type);
    const label = node.cfg?._label ? ` (${node.cfg._label})` : "";
    ctx.log("debug", `Run ${def.name}${label}`, { nodeId: node.id, type: node.type });
    const out = await def.run(ctx, input, node.cfg||{});
    if(out === ctx.SKIP) return ctx.SKIP;
    return out;
  }

  function topoFrom(wf, startIds){
    const out = [];
    const adj = new Map();
    const indeg = new Map();
    for(const n of wf.nodes){ adj.set(n.id, []); indeg.set(n.id, 0); }
    for(const e of wf.edges){
      if(!adj.has(e.from) || !adj.has(e.to)) continue;
      adj.get(e.from).push(e.to);
      indeg.set(e.to, (indeg.get(e.to)||0)+1);
    }
    const reachable = new Set();
    const stack = [...startIds];
    while(stack.length){
      const id = stack.pop();
      if(reachable.has(id)) continue;
      reachable.add(id);
      for(const to of (adj.get(id)||[])) stack.push(to);
    }
    // Kahn on reachable subgraph
    const q = [];
    for(const id of reachable){
      let d = 0;
      for(const e of wf.edges) if(e.to===id && reachable.has(e.from)) d++;
      if(d===0) q.push(id);
    }
    while(q.length){
      const id = q.shift();
      out.push(id);
      for(const to of (adj.get(id)||[])){
        if(!reachable.has(to)) continue;
        let d = 0;
        for(const e of wf.edges) if(e.to===to && reachable.has(e.from)) d++;
        // recompute indegree in remaining set
        // simpler: push when all predecessors already in out
        const preds = wf.edges.filter(e=>e.to===to && reachable.has(e.from)).map(e=>e.from);
        if(preds.every(p=>out.includes(p)) && !out.includes(to) && !q.includes(to)) q.push(to);
      }
    }
    // if cycles, append remaining reachable
    for(const id of reachable) if(!out.includes(id)) out.push(id);
    return out;
  }

  function validateWorkflow(wf){
    const errs = [];
    const ids = new Set(wf.nodes.map(n=>n.id));
    for(const e of wf.edges){
      if(!ids.has(e.from) || !ids.has(e.to)) errs.push(`Edge ${e.id} references missing node`);
      const from = wf.nodes.find(n=>n.id===e.from);
      const to = wf.nodes.find(n=>n.id===e.to);
      if(from && !REGISTRY[from.type]?.outputs) errs.push(`Edge ${e.id}: from-node has no outputs`);
      if(to && !REGISTRY[to.type]?.inputs) errs.push(`Edge ${e.id}: to-node has no inputs`);
    }
    // triggers: at least one node with inputs=0?
    if(!wf.nodes.some(n=> (REGISTRY[n.type]?.inputs||0)===0)) errs.push("No trigger-like nodes (0 inputs)");
    return errs;
  }

  async function runWorkflow({ fromNodeId=null } = {}){
    const wf = currentWF();
    if(!wf) return;
    if(state.running){ toast("Already running", "Stop first", "warn"); return; }
    const errs = validateWorkflow(wf);
    if(errs.length){
      toast("Validation failed", errs.join("\n"), "bad", 9000);
      return;
    }

    // Determine start nodes
    let starts = [];
    if(fromNodeId){
      starts = [fromNodeId];
    } else {
      // nodes with 0 inputs
      starts = wf.nodes.filter(n=>(REGISTRY[n.type]?.inputs||0)===0).map(n=>n.id);
      if(!starts.length) starts = [wf.nodes[0].id];
    }

    let input = {};
    try{ input = JSON.parse($("#execInput").value || "{}"); }
    catch{ toast("Invalid JSON", "Execution input", "bad"); return; }

    state.running = true;
    state.stopRequested = false;
    $("#execState").textContent = "running";
    $("#execState").className = "pill warn";
    state.lastRunGraph = { nodes:{}, edges:{} };
    render();

    const ctx = makeExecContext();
    const order = topoFrom(wf, starts);

    // Prepare predecessor map
    const preds = new Map();
    const outs = new Map(); // nodeId -> output
    for(const n of wf.nodes) preds.set(n.id, []);
    for(const e of wf.edges){
      if(!preds.has(e.to)) preds.set(e.to, []);
      preds.get(e.to).push(e.from);
    }

    // Execute sequentially with simple fan-in: merge object outputs from predecessors into {inputs:[...], merged:{...}}
    let lastOutput = input;
    try{
      for(const id of order){
        if(state.stopRequested){ throw new Error("Stopped"); }
        const node = wf.nodes.find(n=>n.id===id);
        if(!node) continue;
        // skip nodes not reachable from starts already included; topoFrom includes only reachable, so ok.
        const nodePreds = (preds.get(id)||[]).filter(p=>outs.has(p));
        let nodeInput;
        if((REGISTRY[node.type]?.inputs||0)===0){
          nodeInput = deepClone(input);
        } else if(nodePreds.length===0){
          // no incoming data yet => skip
          state.lastRunGraph.nodes[id] = { status:"skip", at: nowISO(), reason:"no-input" };
          continue;
        } else if(nodePreds.length===1){
          nodeInput = deepClone(outs.get(nodePreds[0]));
        } else {
          const inputsArr = nodePreds.map(p=>outs.get(p));
          const merged = {};
          for(const v of inputsArr){
            if(v && typeof v==="object" && !Array.isArray(v)) Object.assign(merged, v);
          }
          nodeInput = { inputs: inputsArr, merged };
        }

        const t0 = performance.now();
        try{
          const out = await runSingleNode(ctx, node, nodeInput);
          const dt = Math.round(performance.now() - t0);
          if(out === ctx.SKIP){
            state.lastRunGraph.nodes[id] = { status:"skip", at: nowISO(), ms: dt };
            continue;
          }
          outs.set(id, out);
          lastOutput = out;
          state.lastRunGraph.nodes[id] = { status:"ok", at: nowISO(), ms: dt };
          // mark outgoing edges ok
          for(const e of wf.edges.filter(e=>e.from===id)){
            state.lastRunGraph.edges[e.id] = { status:"ok", at: nowISO() };
          }
        }catch(e){
          const dt = Math.round(performance.now() - t0);
          state.lastRunGraph.nodes[id] = { status:"bad", at: nowISO(), ms: dt, error: String(e?.message||e) };
          for(const e2 of wf.edges.filter(e2=>e2.from===id)){
            state.lastRunGraph.edges[e2.id] = { status:"bad", at: nowISO() };
          }
          throw e;
        } finally {
          render();
          await sleep(10);
        }
      }

      $("#execResult").textContent = JSON.stringify(lastOutput, null, 2);
      toast("Run complete", "Workflow finished successfully", "ok", 3000);
      $("#execState").textContent = "ok";
      $("#execState").className = "pill ok";
    }catch(e){
      $("#execResult").textContent = JSON.stringify({ error: String(e?.message||e) }, null, 2);
      toast("Run failed", String(e?.message||e), "bad", 7000);
      $("#execState").textContent = "error";
      $("#execState").className = "pill bad";
      log("error", "Workflow failed", { error: String(e?.stack||e) });
    }finally{
      state.running = false;
      state.stopRequested = false;
      render();
    }
  }

  // -------- Scheduler --------
  function updateSchedulerUI(){
    const wf = currentWF();
    const on = state.scheduler.on && wf?.mode==="schedule";
    $("#schedDot").className = "dot " + (on ? "ok" : "");
    $("#schedLabel").textContent = on ? `Scheduler: on (${wf.intervalSec}s)` : "Scheduler: off";
  }

  function stopScheduler(){
    if(state.scheduler.timer){
      clearInterval(state.scheduler.timer);
      state.scheduler.timer = null;
    }
    state.scheduler.on = false;
    updateSchedulerUI();
  }

  function startScheduler(){
    const wf = currentWF();
    if(!wf) return;
    if(wf.mode !== "schedule"){ toast("Switch mode to Schedule", "", "warn"); return; }
    stopScheduler();
    state.scheduler.on = true;
    const intervalMs = Math.max(1000, (wf.intervalSec||60)*1000);
    state.scheduler.timer = setInterval(()=>{
      if(state.running) return;
      runWorkflow();
    }, intervalMs);
    updateSchedulerUI();
  }

  $("#btnToggleScheduler").onclick = ()=>{
    const wf = currentWF();
    if(!wf) return;
    if(state.scheduler.on) stopScheduler();
    else startScheduler();
  };

  // -------- Header / controls --------
  $("#btnRun").onclick = ()=>runWorkflow();
  $("#btnRun2").onclick = ()=>runWorkflow();
  $("#btnRunFrom").onclick = ()=>{
    if(!state.selectedNodeId){ toast("Select a node", "", "warn"); return; }
    runWorkflow({ fromNodeId: state.selectedNodeId });
  };
  $("#btnStop").onclick = ()=>{
    if(!state.running){ toast("Not running", "", "warn"); return; }
    state.stopRequested = true;
    toast("Stop requested", "Will halt ASAP", "warn", 2500);
  };
  $("#btnValidate").onclick = ()=>{
    const errs = validateWorkflow(currentWF());
    if(errs.length) toast("Validation failed", errs.join("\n"), "bad", 9000);
    else toast("Validation ok", "No issues found", "ok", 2200);
  };

  $("#btnSaveWF").onclick = ()=>{ persist(); toast("Saved", "Local browser storage", "ok", 1800); };
  $("#btnDupWF").onclick = ()=>{
    const wf = currentWF();
    const copy = deepClone(wf);
    copy.id = uid();
    copy.name = (wf.name||"Untitled") + " (copy)";
    // new ids for nodes and edges
    const map = new Map();
    copy.nodes.forEach(n=>{ const old=n.id; n.id=uid(); map.set(old,n.id); n.x += 30; n.y += 30; });
    copy.edges.forEach(e=>{ e.id=uid(); e.from = map.get(e.from)||e.from; e.to = map.get(e.to)||e.to; });
    state.workflows.push(copy);
    state.currentId = copy.id;
    setDirty(true);
    render();
    toast("Workflow duplicated", copy.name, "ok", 2200);
  };

  $("#btnClear").onclick = ()=>{
    const wf = {
      id: uid(),
      name: "New Workflow",
      mode: "manual",
      intervalSec: 60,
      nodes: [
        { id: uid(), type:"trigger.manual", x:260, y:200, cfg: deepClone(REGISTRY["trigger.manual"].defaults) }
      ],
      edges: []
    };
    state.workflows.push(wf);
    state.currentId = wf.id;
    setDirty(true);
    stopScheduler();
    state.lastRunGraph = null;
    render();
    fitView();
  };

  $("#btnExport").onclick = ()=>{
    const wf = currentWF();
    const payload = {
      app: "FlowForge",
      version: 1,
      exportedAt: nowISO(),
      workflow: wf
    };
    showModal("Export workflow", `
      <div class="field">
        <label>JSON</label>
        <textarea id="exportText">${escapeHtml(JSON.stringify(payload, null, 2))}</textarea>
      </div>
      <div class="split">
        <button class="btn good" id="copyExport">Copy</button>
        <button class="btn" id="downloadExport">Download</button>
      </div>
    `);
    $("#copyExport").onclick = async ()=>{
      await navigator.clipboard.writeText($("#exportText").value);
      toast("Copied", "Export JSON copied", "ok", 1800);
    };
    $("#downloadExport").onclick = ()=>{
      const blob = new Blob([$("#exportText").value], { type:"application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = (wf.name||"workflow").replace(/[^\w\-]+/g,"_") + ".json";
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
    };
  };

  $("#btnImport").onclick = ()=>{
    showModal("Import workflow", `
      <div class="field">
        <label>Paste export JSON</label>
        <textarea id="importText" placeholder='{"app":"FlowForge","workflow":{...}}'></textarea>
      </div>
      <div class="split">
        <button class="btn good" id="doImport">Import</button>
        <button class="btn" id="importExample">Paste example</button>
      </div>
      <div class="minihelp">Import adds a new workflow to your list. Existing workflows remain.</div>
    `);
    $("#importExample").onclick = ()=>{
      $("#importText").value = JSON.stringify({ app:"FlowForge", version:1, exportedAt: nowISO(), workflow: seedEdgesIfEmpty(defaultWorkflow()) }, null, 2);
    };
    $("#doImport").onclick = ()=>{
      try{
        const obj = JSON.parse($("#importText").value || "{}");
        const wf = obj.workflow || obj;
        if(!wf.nodes || !wf.edges) throw new Error("Missing workflow.nodes/edges");
        wf.id = uid();
        wf.name = wf.name || "Imported Workflow";
        // ensure ids unique-ish
        const nidMap = new Map();
        wf.nodes.forEach(n=>{ const old=n.id; n.id = uid(); nidMap.set(old,n.id); });
        wf.edges.forEach(e=>{ e.id = uid(); e.from = nidMap.get(e.from)||e.from; e.to = nidMap.get(e.to)||e.to; });
        state.workflows.push(wf);
        state.currentId = wf.id;
        setDirty(true);
        hideModal();
        render();
        fitView();
        toast("Imported", wf.name, "ok", 2200);
      }catch(e){
        toast("Import failed", String(e?.message||e), "bad", 7000);
      }
    };
  };

  $("#btnHelp").onclick = ()=>{
    showModal("Help", `
      <div class="grid2">
        <div>
          <div class="field">
            <label>Basics</label>
            <div class="muted">
              • Click node types to add them<br/>
              • Drag nodes to move<br/>
              • Drag from a node’s right port to another node’s left port to connect<br/>
              • Double‑click a node for JSON config editor<br/>
              • Double‑click an edge to delete it<br/>
              • Hold <span class="kbd">Alt</span> and drag to pan<br/>
              • Mouse wheel to zoom<br/>
            </div>
          </div>
          <div class="field">
            <label>Templating</label>
            <div class="codebox">Hello {{user.name}} — id={{http.data.id}}</div>
          </div>
        </div>
        <div>
          <div class="field">
            <label>Keyboard</label>
            <div class="muted">
              • <span class="kbd">/</span> focus search<br/>
              • <span class="kbd">Del</span> delete selected node/edge<br/>
              • <span class="kbd">Ctrl/⌘ + Enter</span> run workflow<br/>
              • <span class="kbd">Esc</span> clear selection / close modal<br/>
            </div>
          </div>
          <div class="field">
            <label>Security note</label>
            <div class="muted">
              The Code/Expression nodes execute JavaScript in your browser context. Treat workflows like code.
            </div>
          </div>
        </div>
      </div>
    `);
  };

  // Secrets
  function updateSecretsStatus(){
    const ok = (secrets.baseUrl || secrets.apiKey) ? true : false;
    const pill = $("#secretsStatus");
    pill.textContent = ok ? "set" : "not set";
    pill.className = "pill " + (ok ? "ok" : "");
  }
  $("#btnSaveSecrets").onclick = ()=>{
    secrets.baseUrl = $("#cfgBaseUrl").value.trim();
    secrets.apiKey = $("#cfgApiKey").value;
    storage.set(LS_SECRETS, secrets);
    updateSecretsStatus();
    toast("Saved integrations", "Stored locally", "ok", 1800);
  };
  $("#btnClearSecrets").onclick = ()=>{
    secrets.baseUrl = ""; secrets.apiKey = "";
    $("#cfgBaseUrl").value = "";
    $("#cfgApiKey").value = "";
    storage.set(LS_SECRETS, secrets);
    updateSecretsStatus();
    toast("Cleared integrations", "", "warn", 1800);
  };

  // Workflow selection & fields
  $("#wfSelect").addEventListener("change", ()=>{
    state.currentId = $("#wfSelect").value;
    state.selectedNodeId = null;
    state.selectedEdgeId = null;
    state.lastRunGraph = null;
    stopScheduler();
    render();
    fitView();
  });
  $("#wfName").addEventListener("input", ()=>{
    const wf = currentWF();
    wf.name = $("#wfName").value;
    setDirty(true);
    renderWorkflowSelect();
  });
  $("#wfMode").addEventListener("change", ()=>{
    const wf = currentWF();
    wf.mode = $("#wfMode").value;
    setDirty(true);
    stopScheduler();
    updateSchedulerUI();
  });
  $("#wfInterval").addEventListener("input", ()=>{
    const wf = currentWF();
    wf.intervalSec = Math.max(1, Number($("#wfInterval").value||60));
    setDirty(true);
    updateSchedulerUI();
    if(state.scheduler.on){
      startScheduler();
    }
  });

  // Search
  $("#nodeSearch").addEventListener("input", ()=>renderNodeLibrary($("#nodeSearch").value));
  window.addEventListener("keydown",(ev)=>{
    if(ev.key === "/" && !ev.ctrlKey && !ev.metaKey && !ev.altKey){
      ev.preventDefault();
      $("#nodeSearch").focus();
    }
    if((ev.ctrlKey || ev.metaKey) && ev.key === "Enter"){
      ev.preventDefault();
      runWorkflow();
    }
    if(ev.key === "Escape"){
      if(modal.style.display==="flex"){ hideModal(); return; }
      state.connecting = null;
      clearSelection();
    }
    if(ev.key === "Delete" || ev.key === "Backspace"){
      if(ev.target && ["INPUT","TEXTAREA","SELECT"].includes(ev.target.tagName)) return;
      if(state.selectedNodeId) removeNode(state.selectedNodeId);
      else if(state.selectedEdgeId) removeEdge(state.selectedEdgeId);
    }
  });

  // Stop auto-save prompts
  window.addEventListener("beforeunload",(ev)=>{
    if(state.dirty){
      ev.preventDefault();
      ev.returnValue = "";
    }
  });

  // -------- Init --------
  load();
  renderNodeLibrary();
  render();
  fitView();
  updateSchedulerUI();

  // autosave debounce
  let saveTimer = null;
  function autosaveSoon(){
    clearTimeout(saveTimer);
    saveTimer = setTimeout(()=>persist(), 650);
  }
  // mark dirty triggers autosave
  const oldSetDirty = setDirty;
  setDirty = function(v){
    oldSetDirty(v);
    if(v) autosaveSoon();
  };

})();
</script>
</body>
</html>