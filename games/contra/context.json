{
  "messages": [
    {
      "role": "user",
      "content": "write a small side-scrolling pixel shoot'em'up similar to contra\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Mini Contra-like Shoot'em'up</title>\n<style>\n  * {\n    margin: 0; padding: 0; box-sizing: border-box;\n  }\n  body, html {\n    background: #111;\n    overflow: hidden;\n    height: 100vh;\n    width: 100vw;\n    user-select: none;\n  }\n  canvas {\n    display: block;\n    margin: 0 auto;\n    background: linear-gradient(to top, #264026 0%, #87ceeb 100%);\n    image-rendering: pixelated;\n    border: 3px solid #555;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"game\" width=\"480\" height=\"270\"></canvas>\n<script>\n(() => {\n  /*\n  Mini pixel shoot'em'up side scrolling game inspired by CONTRA.\n  Controls:\n    - Arrow Left/Right: Move left/right\n    - Arrow Up: Jump\n    - Z / Ctrl / X: Shoot\n  */\n\n  const canvas = document.getElementById('game');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width;\n  const H = canvas.height;\n\n  // Pixel art scale so rendering looks crisp on HD screens\n  const SCALE = 2;\n\n  // Game constants\n  const GRAVITY = 0.6;\n  const FRICTION = 0.75;\n  const MAX_ENEMIES = 6;\n  const ENEMY_SPAWN_INTERVAL = 2000;\n  const LEVEL_LENGTH = 4000; // px\n\n  // Input keys pressed\n  const keys = {};\n  window.addEventListener('keydown', e => {\n    keys[e.code] = true;\n    // prevent scrolling on arrow keys\n    if(['ArrowLeft','ArrowRight','ArrowUp','Space'].includes(e.code)) e.preventDefault();\n  });\n  window.addEventListener('keyup', e => {\n    keys[e.code] = false;\n  });\n\n  // Helper pixel function to draw rects scaled with pixel-art style\n  function pfill(x,y,w,h,color){\n    ctx.fillStyle = color;\n    ctx.fillRect(x|0, y|0, w, h);\n  }\n  // Helper to draw pixel \"sprite\" from pattern array\n  // pattern: array of strings, eg: ['..X..','XXX..'] where X = pixel\n  // color: fill color of pixel\n  // px: pixel size\n  function drawPattern(x,y,pattern,color,px=2){\n    ctx.fillStyle = color;\n    pattern.forEach((row,iy) => {\n      [...row].forEach((ch,ix) => {\n        if(ch !== '.' && ch !== ' ') {\n          ctx.fillRect(x + ix*px, y + iy*px, px, px);\n        }\n      });\n    });\n  }\n\n  // Classes\n\n  class Entity {\n    constructor(x,y,w,h){\n      this.x = x;\n      this.y = y;\n      this.w = w;\n      this.h = h;\n      this.vx = 0;\n      this.vy = 0;\n      this.dead = false;\n      this.hp = 1;\n    }\n    get left(){return this.x;}\n    get right(){return this.x+this.w;}\n    get top(){return this.y;}\n    get bottom(){return this.y+this.h;}\n    intersects(other){\n      return !(this.left > other.right || this.right < other.left ||\n               this.top > other.bottom || this.bottom < other.top);\n    }\n  }\n\n  // Player class\n  class Player extends Entity {\n    constructor(x,y){\n      super(x,y,14,16);\n      this.speed = 2.6;\n      this.jumpPower = -10.5;\n      this.canJump = false;\n      this.color = '#0f0';\n      this.shootCooldown = 0;\n      this.direction = 1; // 1 = right, -1 = left\n      this.dead = false;\n      this.hp = 3;\n      this.invulnTimer = 0;\n    }\n    update(){\n      if(this.dead) return;\n\n      // Horizontal movement\n      if(keys['ArrowLeft']){\n        this.vx = -this.speed;\n        this.direction = -1;\n      }\n      else if(keys['ArrowRight']){\n        this.vx = this.speed;\n        this.direction = 1;\n      } else {\n        this.vx *= FRICTION;\n        if(Math.abs(this.vx)<0.15) this.vx=0;\n      }\n\n      // Jump\n      if(keys['ArrowUp'] && this.canJump){\n        this.vy = this.jumpPower;\n        this.canJump = false;\n      }\n\n      // Gravity\n      this.vy += GRAVITY;\n\n      // Move\n      this.x += this.vx;\n      this.y += this.vy;\n\n      // Collision with floor\n      if(this.y + this.h > groundLevel){\n        this.y = groundLevel - this.h;\n        this.vy = 0;\n        this.canJump = true;\n      }\n\n      // Keep inside screen horizontally (camera will move but player somewhat limited)\n      if(this.x < cameraX) this.x = cameraX;\n      if(this.x + this.w > cameraX + W) this.x = cameraX + W - this.w;\n\n      // Shoot\n      if(this.shootCooldown > 0) this.shootCooldown--;\n      if((keys['KeyZ'] || keys['ControlLeft'] || keys['KeyX']) && this.shootCooldown <= 0){\n        shootBullet(this.x + this.w/2, this.y+6, this.direction);\n        this.shootCooldown = 15; // cooldown frames\n      }\n\n      if(this.invulnTimer > 0) this.invulnTimer--;\n\n      if(this.hp <= 0 && !this.dead){\n        gameOver();\n        this.dead = true;\n      }\n    }\n    draw(){\n      if(this.dead) {\n        // Draw dead player as red block flicker\n        if((performance.now()/100)%500 < 250){\n          pfill(this.x - cameraX, this.y, this.w, this.h, '#f00');\n        }\n        return;\n      }\n      // Simple player pixel figure facing direction\n      const px = 2;\n      const x = this.x - cameraX;\n      const y = this.y;\n\n      // Flicker if invulnerable\n      if(this.invulnTimer > 0 && Math.floor(this.invulnTimer/5) % 2 === 0) return;\n\n      // Basic sprite: head, body, legs\n      // Head\n      drawPattern(x+4,y, [\n        \"..XX..\",\n        \".XXXX.\",\n        \"XXXXXX\",\n        \"XX..XX\",\n      ], '#0f0', px);\n\n      // Body with arm (directional)\n      const bodyPatternRight = [\n        \"..XX..\",\n        \"..XX..\",\n        \"..XX..\",\n        \"..XX..\",\n      ];\n      const armX = x + (this.direction === 1 ? 10 : 0);\n      const armY = y + 8;\n\n      drawPattern(x+4,y+8, bodyPatternRight, '#0a0', px);\n      // Arm\n      pfill(armX, armY, px*2, px*3, '#0a0');\n\n      // Legs\n      drawPattern(x+4,y+14, [\n        \".X..X.\",\n        \"X....X\",\n      ], '#070', px);\n    }\n  }\n\n  // Bullet class fired by player or enemy\n  class Bullet extends Entity {\n    constructor(x,y,direction,speed=7,color='#ff0',fromEnemy=false){\n      super(x,y,4,2);\n      this.vx = speed*direction;\n      this.color = color;\n      this.fromEnemy = fromEnemy;\n      this.life = 70;\n    }\n    update(){\n      this.x += this.vx;\n      this.life--;\n      if(this.life<=0) this.dead=true;\n      // Remove if out of level bounds\n      if(this.x < 0 || this.x > LEVEL_LENGTH) this.dead=true;\n    }\n    draw(){\n      pfill(this.x - cameraX, this.y, this.w, this.h, this.color);\n    }\n  }\n\n  // Enemy class - simple soldier type\n  class Enemy extends Entity {\n    constructor(x,y){\n      super(x,y,14,16);\n      this.speed = 1;\n      this.direction = -1;\n      this.color = '#f00';\n      this.shootCooldown = 0;\n      this.hp = 2;\n      this.dead = false;\n      this.vy = 0;\n      this.canJump = false;\n    }\n    update(){\n      // Simple AI: move back and forth in a range of 60px\n      if(this.dead) return;\n\n      // Gravity\n      this.vy += GRAVITY;\n      this.y += this.vy;\n      if(this.y + this.h > groundLevel){\n        this.y = groundLevel - this.h;\n        this.vy = 0;\n        this.canJump = true;\n      }\n\n      this.x += this.speed*this.direction;\n\n      if(this.x < this.spawnX - 30){\n        this.direction = 1;\n      } else if(this.x > this.spawnX + 30){\n        this.direction = -1;\n      }\n\n      // Shoot at player if on screen and cooldown over, shooting towards player\n      if(this.shootCooldown > 0) this.shootCooldown--;\n      if(this.shootCooldown <= 0 && this.x > cameraX && this.x < cameraX+W){\n        const px = player.x + player.w/2;\n        const py = player.y + player.h/2;\n        const ex = this.x + this.w/2;\n        const ey = this.y + this.h/2;\n\n        if(Math.abs(py - ey) < 40){ \n          let dir = px > ex ? 1 : -1;\n          enemyShoot(this.x + this.w/2, this.y+6, dir);\n          this.shootCooldown = 90;\n        }\n      }\n\n      // Keep in bounds of level\n      if(this.x < 0) this.x = 0;\n      if(this.x + this.w > LEVEL_LENGTH) this.x = LEVEL_LENGTH - this.w;\n\n      if(this.hp <=0){\n        this.dead = true;\n        score += 100;\n      }\n    }\n    draw(){\n      if(this.dead) return;\n      const px = 2;\n      const x = this.x - cameraX;\n      const y = this.y;\n\n      // Basic enemy sprite (red soldier)\n      drawPattern(x+4,y, [\n        \"..XX..\",\n        \".XXXX.\",\n        \"XXXXXX\",\n        \"XX..XX\",\n      ], '#f00', px);\n\n      drawPattern(x+4,y+8, [\n        \"..XX..\",\n        \"..XX..\",\n        \"..XX..\",\n        \"..XX..\",\n      ], '#a00', px);\n\n      pfill(x + (this.direction === 1 ? 10 : 0), y + 8, px*2, px*3, '#a00');\n\n      drawPattern(x+4,y+14, [\n        \".X..X.\",\n        \"X....X\",\n      ], '#700', px);\n    }\n  }\n\n  // Platforms/ground simple line\n  const groundLevel = 230;\n\n  // Game state\n  const player = new Player(20, groundLevel - 16);\n  let bullets = [];\n  let enemies = [];\n  let enemyBullets = [];\n  let cameraX = 0;\n  let score = 0;\n  let gameRunning = true;\n  let gameEnded = false;\n  let levelEnd = LEVEL_LENGTH - W - 50;\n\n  // Spawn some enemies upfront\n  function spawnEnemies(){\n    enemies = [];\n    for(let i=0; i<MAX_ENEMIES; i++){\n      let ex = 300 + i*250 + Math.random()*50;\n      let enemy = new Enemy(ex, groundLevel - 16);\n      enemy.spawnX = ex;\n      enemies.push(enemy);\n    }\n  }\n  spawnEnemies();\n\n  // Shoot bullet from player\n  function shootBullet(x,y,direction){\n    const b = new Bullet(x,y,direction,9,'#ff0',false);\n    bullets.push(b);\n  }\n\n  // Enemy shoots bullets\n  function enemyShoot(x,y,direction){\n    const b = new Bullet(x,y,direction,5,'#f80',true);\n    enemyBullets.push(b);\n  }\n\n  // Handle collisions\n  function handleCollisions(){\n    // Player bullets hit enemies\n    bullets.forEach(b => {\n      enemies.forEach(e => {\n        if(!b.dead && !e.dead && b.intersects(e)){\n          e.hp--;\n          b.dead = true;\n        }\n      });\n    });\n\n    // Enemy bullets hit player\n    enemyBullets.forEach(b => {\n      if(!b.dead && !player.dead && b.intersects(player) && player.invulnTimer<=0){\n        player.hp--;\n        player.invulnTimer = 60;\n        b.dead = true;\n      }\n    });\n\n    // Enemies touching player hurts player\n    enemies.forEach(e => {\n      if(!e.dead && !player.dead && e.intersects(player) && player.invulnTimer<=0){\n        player.hp--;\n        player.invulnTimer = 60;\n        // Knockback player a bit\n        player.vx = e.direction * -4;\n        player.vy = -6;\n      }\n    });\n  }\n\n  // Game over\n  function gameOver(){\n    gameRunning = false;\n    gameEnded = true;\n  }\n\n  // Restart game\n  function restartGame(){\n    player.x = 20;\n    player.y = groundLevel - player.h;\n    player.hp = 3;\n    player.dead = false;\n    player.invulnTimer = 0;\n    bullets = [];\n    enemyBullets = [];\n    cameraX = 0;\n    score = 0;\n    spawnEnemies();\n    gameRunning = true;\n    gameEnded = false;\n  }\n\n  // Draw HUD\n  function drawHUD(){\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px monospace';\n    ctx.fillText(`HP: ${player.hp}`, 5, 15);\n    ctx.fillText(`Score: ${score}`, 5, 30);\n\n    if(gameEnded){\n      ctx.fillStyle = '#000a';\n      ctx.fillRect(0, 0, W, H);\n      ctx.fillStyle = '#f00';\n      ctx.font = '30px monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText('GAME OVER', W/2, H/2 - 20);\n      ctx.fillStyle = '#fff';\n      ctx.font = '18px monospace';\n      ctx.fillText('Press R to Restart', W/2, H/2 + 20);\n      ctx.textAlign = 'left';\n    }\n  }\n\n  // Main game loop\n  function loop(){\n    ctx.clearRect(0,0,W,H);\n\n    if(gameRunning){\n\n      // Update player\n      player.update();\n\n      // Update bullets\n      bullets.forEach(b => b.update());\n      bullets = bullets.filter(b => !b.dead);\n\n      enemyBullets.forEach(b => b.update());\n      enemyBullets = enemyBullets.filter(b => !b.dead);\n\n      // Update enemies\n      enemies.forEach(e => e.update());\n\n      // Collisions\n      handleCollisions();\n\n      // Camera follows player horizontally with margin\n      let cameraTargetX = player.x - W/3;\n      cameraTargetX = Math.max(0, Math.min(LEVEL_LENGTH - W, cameraTargetX));\n      cameraX += (cameraTargetX - cameraX) * 0.1;\n\n      // Draw ground (simple green strip)\n      pfill(0, groundLevel, W, H - groundLevel, '#145214');\n\n      // Draw some simple background hills (parallax)\n      let hillsOffset = cameraX * 0.3;\n      for(let i=-1;i<10;i++){\n        let hx = (i*250 - hillsOffset) % 480;\n        ctx.beginPath();\n        ctx.moveTo(hx, groundLevel);\n        ctx.lineTo(hx+120, groundLevel);\n        ctx.lineTo(hx+60, groundLevel - 40);\n        ctx.closePath();\n        ctx.fillStyle = '#356935';\n        ctx.fill();\n      }\n\n      // Draw player bullets\n      bullets.forEach(b => b.draw());\n\n      // Draw enemy bullets\n      enemyBullets.forEach(b => b.draw());\n\n      // Draw enemies\n      enemies.forEach(e => e.draw());\n\n      // Draw player\n      player.draw();\n\n      // Draw HUD\n      drawHUD();\n\n      // Win condition: reach near level end\n      if(player.x >= levelEnd){\n        gameRunning = false;\n      }\n    } else {\n      // Show win or prompt\n      pfill(0, 0, W, H, '#000a');\n      ctx.fillStyle = '#fff';\n      ctx.font = '20px monospace';\n      ctx.textAlign = 'center';\n      if(gameEnded){\n        // game over shown in HUD already\n      } else {\n        ctx.fillText('Level Complete!', W/2, H/2 - 10);\n        ctx.fillText(`Score: ${score}`, W/2, H/2 + 15);\n        ctx.fillText('Press R to Restart', W/2, H/2 + 45);\n      }\n      ctx.textAlign = 'left';\n    }\n\n    // Restart if R pressed\n    if(gameEnded || !gameRunning){\n      if(keys['KeyR']){\n        restartGame();\n      }\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n\n  loop();\n\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}