<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VibeGame AI Studio - MVP+, Enhanced</title>
  <style>
    :root {
      --bg: #0b0f15;
      --card: #141b22;
      --text: #e6f0f5;
      --muted: #9fb9c9;
      --accent: #6ee7b7;
      --glow: 0 0 14px rgba(110,231,183,.8);
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(circle at 10% -10%, #1d2430 0%, #0b0f15 40%, #0b0f15 100%), #0b0f15;
      color: var(--text);
      overflow: hidden;
    }
    .app {
      display: grid;
      grid-template-columns: 320px 1fr 360px;
      grid-gap: 14px;
      padding: 14px;
      height: calc(100vh - 28px);
      box-sizing: border-box;
      align-items: stretch;
    }
    .panel {
      background: rgba(20,26,34,0.95);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
      overflow: auto;
      min-height: 0;
    }
    .panel h2 {
      margin: 6px 0 12px;
      font-size: 14px;
      color: #cfe8ff;
      text-transform: uppercase;
      letter-spacing: .12em;
    }
    .row { display: flex; flex-direction: column; gap: 6px; margin: 8px 0; }
    .row.inline { flex-direction: row; align-items: center; gap: 10px; justify-content: space-between; }
    label { font-size: 12px; color: var(--muted); }
    select, input[type="range"], input[type="number"], input[type="text"] {
      width: 100%;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.15);
      color: #e9f6ff;
      padding: 8px 10px;
      border-radius: 8px;
    }
    button {
      background: linear-gradient(135deg, #4cc9f0, #4361ee);
      color: white;
      border: none;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform .1s ease;
    }
    button.secondary {
      background: #1f2a37;
      color: #e8f0f8;
      border: 1px solid rgba(255,255,255,0.15);
    }
    button.ghost {
      background: transparent;
      color: #cfe8ff;
      border: none;
    }
    .stage-wrap {
      position: relative;
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
      overflow: hidden;
    }
    canvas#stage {
      width: 100%;
      height: 100%;
      display: block;
      background: #0b0f15;
      border-radius: 12px;
      box-shadow: inset 0 0 60px rgba(0,0,0,.4);
    }
    .HUD {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(8,12,18,0.65);
      border-radius: 10px;
      font-family: ui-sans-serif;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.08);
      margin: 4px;
      backdrop-filter: blur(4px);
    }
    .scene-label { font-weight: bold; }
    .log {
      height: 160px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      font-size: 12px;
      padding: 6px;
      background: rgba(0,0,0,0.25);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.08);
      color: #e6f0f5;
    }
    .readme { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular; font-size: 12px; line-height: 1.4; }
    .section-title { font-size: 12px; color: #cfe8ff; text-transform: uppercase; letter-spacing: .12em; margin-bottom: 6px; }
    .badge { padding: 2px 6px; border-radius: 6px; font-size: 11px; background: rgba(110,231,183,0.15); color: #6ee7b7; }
    .hidden { display: none; }
    .mini { font-size: 11px; color: var(--muted); }
    .glow { text-shadow: 0 0 8px rgba(110,231,183,.8); }
    .palette-swatch { width: 16px; height: 16px; border-radius: 3px; display: inline-block; vertical-align: middle; margin-right: 6px; border: 1px solid rgba(255,255,255,.5); }
  </style>
</head>
<body>
  <div class="app">
    <!-- Controls / Vibe Target / Extras -->
    <section class="panel" id="controls-panel" aria-label="Controls">
      <h2>Vibe Target</h2>

      <div class="row inline" style="gap:8px;">
        <span class="mini" style="white-space:nowrap;">Mood</span>
        <select id="mood-select" aria-label="Mood">
          <option value="Chill">Chill</option>
          <option value="Energetic">Energetic</option>
          <option value="Mysterious">Mysterious</option>
          <option value="Joyful">Joyful</option>
        </select>
      </div>

      <div class="row inline" style="gap:8px;">
        <span class="mini" style="white-space:nowrap;">Tempo (BPM)</span>
        <input type="range" id="tempo-range" min="60" max="140" value="100" />
        <span id="tempo-value" class="mini" style="min-width:40px; text-align:right;">100</span>
      </div>

      <div class="row inline" style="gap:8px;">
        <span class="mini" style="white-space:nowrap;">Color Palette</span>
        <select id="palette-select" aria-label="Color Palette">
          <option value="Pastel">Pastel</option>
          <option value="Neon">Neon</option>
          <option value="Earthy">Earthy</option>
          <option value="Cosmic">Cosmic</option>
        </select>
      </div>

      <div class="row inline" style="gap:8px;">
        <span class="mini" style="white-space:nowrap;">Integration</span>
        <select id="integration-select" aria-label="Integration">
          <option value="GPTApp" selected>GPTApp</option>
          <option value="Plapp">Plapp</option>
          <option value="Hanna vibegame AI">Hanna vibegame AI</option>
        </select>
      </div>

      <div class="row" style="margin-top:6px;">
        <button id="start-btn" title="Start Level">Start Level</button>
      </div>
      <div class="row" style="margin-top:6px;">
        <button id="build-btn" class="secondary" title="Export Build">Export Config (JSON)</button>
      </div>
      <div class="row" style="margin-top:6px;">
        <button id="import-btn" class="secondary" title="Import Build">Import Config</button>
      </div>
      <div class="row" style="margin-top:6px;">
        <button id="randomize-btn" class="secondary" title="Randomize vibe">Randomize</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="readme-toggle" class="secondary" style="width:100%;">Readme / Taxonomy</button>
      </div>

      <div class="row" style="margin-top:8px;">
        <span class="badge" id="status-badge" title="Status">Idle</span>
      </div>
    </section>

    <!-- Stage / Core Loop -->
    <section class="panel stage-wrap" id="stage-panel" aria-label="Stage">
      <div class="HUD" id="hud">
        <div class="scene-label" id="scene-label">Scene: -</div>
        <div>Time: <span id="timer">00:00</span> â€¢ Beat: <span id="beat">-</span></div>
        <div>Score: <span id="score">0</span></div>
      </div>
      <canvas id="stage" width="800" height="520" tabindex="0"></canvas>
      <div style="display:flex; justify-content:space-between; align-items:center; padding:6px 6px;">
        <div id="log" class="log" style="flex:1; height:100px; max-height:160px;"></div>
        <div style="display:flex; gap:6px; padding-left:8px;">
          <button id="pause-btn" class="secondary" title="Pause/Resume">Pause</button>
          <button id="reset-btn" class="secondary" title="Restart">Reset</button>
        </div>
      </div>
    </section>

    <!-- Readme / Taxonomy -->
    <section class="panel" id="readme-panel" aria-label="Readme" style="min-height:420px;">
      <h2>Vibe Taxonomy & Deliverables</h2>
      <div class="readme" id="readme-content" style="white-space:pre-wrap;"></div>

      <h2 style="margin-top:12px;" class="hidden" id="dev-section-title">Developer Notes</h2>
      <div class="readme hidden" id="dev-content" style="white-space:pre-wrap;">
        This MVP+ includes advanced visuals, audio ambience, and an export/import pipeline.
      </div>

      <h2 style="margin-top:12px;">Deliverables</h2>
      <ul style="font-size:12px; color:#eaeaea;">
        <li> Enhanced stage with particle systems and beat-reactive visuals</li>
        <li> Audio ambience with mood-based modulation (Web Audio)</li>
        <li> Export JSON (build) and Import JSON</li>
        <li> Adjustable motion blur, bloom-like glow, and dynamic color palettes</li>
      </ul>
    </section>
  </div>

  <script>
    // Lightweight seeded RNG
    function Mulberry32(seed) {
      this.seed = seed >>> 0;
    }
    Mulberry32.prototype.next = function() {
      let t = this.seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
    Mulberry32.prototype.nextInt = function(min, max) {
      return Math.floor(this.next() * (max - min + 1)) + min;
    };

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Elements
    const moodSelect = document.getElementById('mood-select');
    const tempoRange = document.getElementById('tempo-range');
    const tempoValue = document.getElementById('tempo-value');
    const paletteSelect = document.getElementById('palette-select');
    const integrationSelect = document.getElementById('integration-select');
    const startBtn = document.getElementById('start-btn');
    const buildBtn = document.getElementById('build-btn');
    const importBtn = document.getElementById('import-btn');
    const randomizeBtn = document.getElementById('randomize-btn');
    const stageCanvas = document.getElementById('stage');
    const hudSceneLabel = document.getElementById('scene-label');
    const hudTimer = document.getElementById('timer');
    const hudBeat = document.getElementById('beat');
    const hudScore = document.getElementById('score');
    const logPanel = document.getElementById('log');
    const readmeToggle = document.getElementById('readme-toggle');
    const readmePanel = document.getElementById('readme-panel');
    const readmeContent = document.getElementById('readme-content');
    const statusBadge = document.getElementById('status-badge');
    const pauseBtn = document.getElementById('pause-btn');
    const resetBtn = document.getElementById('reset-btn');

    // Audio
    let audioCtx = null;
    let ambienceNode = null;
    let ambienceGain = null;
    let droneOsc = null;

    // State
    let running = false;
    let paused = false;
    let startTime = null;
    let lastBeatBeatIndex = -1;
    let beatIntervalMs = 60000 / 100; // default, updated by BPM
    let bpm = 100;
    let currentSceneIndex = 0;
    let scenes = [];
    let palette = [];
    let mood = 'Chill';
    let integration = 'GPTApp';
    let score = 0;
    let shapes = [];
    let readmeVisible = false;
    let DURATION_MS = 180000; // 3 minutes
    let stageCtx = null;
    let stageWidth = 800;
    let stageHeight = 520;
    let lastFrameTime = 0;
    let colorTimeline = 0;
    let logLines = [];

    // Palettes
    const PALETTES = {
      Pastel: ['#ffd6e0', '#b0e0e6', '#d1ffd6', '#f7f2d0'],
      Neon: ['#ff3d7f', '#00ffd8', '#7b5cff', '#ffd400'],
      Earthy: ['#6b8e23', '#b5651d', '#cdb4a0', '#2f4f4f'],
      Cosmic: ['#4b4bd0', '#8a2be2', '#2d2d7a', '#0a3d73']
    };

    const MOOD_METADATA = {
      Chill: { basePalette: 'Pastel', tempoBias: -10 },
      Energetic: { basePalette: 'Neon', tempoBias: +10 },
      Mysterious: { basePalette: 'Cosmic', tempoBias: 0 },
      Joyful: { basePalette: 'Earthy', tempoBias: +2 }
    };

    // Readme content
    readmeContent.textContent = generateReadme();

    // Utility: log
    function log(msg) {
      const t = new Date().toLocaleTimeString();
      const line = `[${t}] ${msg}`;
      logLines.unshift(line);
      if (logLines.length > 180) logLines.pop();
      logPanel.innerHTML = logLines.slice(0, 180).join('<br>');
    }

    function generateReadme() {
      const lines = [];
      lines.push("Vibe taxonomy - VibeTarget / Tempo / Palette -> AI-driven scene generation");
      lines.push("");
      lines.push("Mood target mappings:");
      lines.push(" - Chill: slow tempo, calm colors, expansive shapes.");
      lines.push(" - Energetic: higher tempo, vivid neon colors, punchy shapes.");
      lines.push(" - Mysterious: moderate tempo, deep purples/blues, subtle motion.");
      lines.push(" - Joyful: medium tempo, warm hues, playful motion.");
      lines.push("");
      lines.push("Tempo guidance (BPM):");
      lines.push(" - 60-80: Chill, 80-100: Calm, 100-120: Active, 120-140: Energized.");
      lines.push("");
      lines.push("Color palettes:");
      lines.push(" - Pastel: soft, muted tones for relaxed vibes.");
      lines.push(" - Neon: bright, high contrast for high energy.");
      lines.push(" - Earthy: grounded colors for natural moods.");
      lines.push(" - Cosmic: darks with electric accents for mystery.");
      lines.push("");
      lines.push("AI integrations (simulated):");
      lines.push(" - Plapp: abstract shape-driven prompts, looser scene layout.");
      lines.push(" - GPTApp: structured scene blocks with clear rhythm cues.");
      lines.push(" - Hanna vibegame AI: dynamic hue shifts and morphing elements.");
      lines.push("");
      lines.push("MVP Deliverables:");
      lines.push(" - 1 level, ~3â€“5 minutes runtime, basic scoring.");
      lines.push(" - Deterministic, constrained AI prompts with guardrails.");
      lines.push(" - Build export: JSON of vibe config + scenes.");
      return lines.join("\n");
    }

    function resizeCanvas() {
      const rect = stageCanvas.getBoundingClientRect();
      stageWidth = Math.floor(rect.width);
      stageHeight = Math.floor(rect.height);
      stageCanvas.width = stageWidth;
      stageCanvas.height = stageHeight;
      stageCtx = stageCanvas.getContext('2d');
    }

    // Initialize canvas
    resizeCanvas();
    window.addEventListener('resize', () => {
      resizeCanvas();
    });

    // Update UI tempo display
    tempoValue.textContent = bpm.toString();

    // Events
    tempoRange.addEventListener('input', () => {
      bpm = parseInt(tempoRange.value);
      tempoValue.textContent = bpm.toString();
      beatIntervalMs = 60000 / bpm;
      log(`Tempo changed to ${bpm} BPM`);
      statusBadge.textContent = `Tempo ${bpm} BPM`;
    });

    startBtn.addEventListener('click', () => {
      if (running) {
        resetRun();
        startRun();
      } else {
        startRun();
      }
    });

    buildBtn.addEventListener('click', () => {
      const payload = buildExportPayload();
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'VibeGameAI_Studio_build.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      log('Exported config to VibeGameAI_Studio_build.json');
    });

    importBtn.addEventListener('click', () => {
      // trigger hidden file input
      const fi = document.createElement('input');
      fi.type = 'file';
      fi.accept = '.json,application/json';
      fi.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          try {
            const data = JSON.parse(evt.target.result);
            applyImportedConfig(data);
            log('Imported config loaded.');
          } catch (err) {
            log('Invalid JSON import.');
          }
        };
        reader.readAsText(file);
      };
      fi.click();
    });

    randomizeBtn.addEventListener('click', () => {
      mood = Object.keys(MOOD_METADATA)[Math.floor(Math.random() * Object.keys(MOOD_METADATA).length)];
      moodSelect.value = mood;
      const palettes = Object.keys(PALETTES);
      paletteSelect.value = palettes[Math.floor(Math.random() * palettes.length)];
      integrationSelect.value = ['GPTApp','Plapp','Hanna vibegame AI'][Math.floor(Math.random()*3)];
      bpm = 60 + Math.floor(Math.random() * 80);
      tempoRange.value = bpm;
      tempoValue.textContent = bpm.toString();
      beatIntervalMs = 60000 / bpm;
      log(`Randomized: Mood=${mood}, Palette=${paletteSelect.value}, Integration=${integrationSelect.value}, BPM=${bpm}`);
    });

    readmeToggle.addEventListener('click', () => {
      readmeVisible = !readmeVisible;
      readmePanel.style.display = readmeVisible ? 'block' : 'none';
      readmeToggle.textContent = readmeVisible ? 'Hide Readme / Taxonomy' : 'Readme / Taxonomy';
    });

    // Pause / Resume / Reset
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    });

    resetBtn.addEventListener('click', () => {
      resetRun();
      statusBadge.textContent = 'Idle';
    });

    // Stage interaction: click to "hit"
    stageCanvas.addEventListener('pointerdown', (e) => {
      if (!running || paused) return;
      attemptHit(performance.now());
    });

    // Scene / visuals
    function ensureAudioContext() {
      if (audioCtx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) {
        log('Web Audio API not supported');
        return;
      }
      audioCtx = new Ctx();
      ambienceGain = audioCtx.createGain();
      ambienceGain.gain.value = 0.0;
      ambienceGain.connect(audioCtx.destination);
      droneOsc = audioCtx.createOscillator();
      droneOsc.type = 'sine';
      droneOsc.frequency.value = 60;
      droneOsc.connect(ambienceGain);
      droneOsc.start();

      // gentle ramp up after user gesture
      const resume = () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        window.removeEventListener('click', resume);
        window.removeEventListener('keydown', resume);
        // initial ambience
        ambienceGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
      };
      window.addEventListener('click', resume);
      window.addEventListener('keydown', resume, { once: true });
    }

    function applyMoodAudio() {
      if (!audioCtx) return;
      // adjust drone frequency and gain based on mood
      let target = 60;
      if (mood === 'Energetic') target = 90;
      if (mood === 'Mysterious') target = 50;
      if (mood === 'Joyful') target = 75;
      droneOsc.frequency.setTargetAtTime(target, audioCtx.currentTime, 0.6);
      // soft tremolo via gain modulation
      if (ambienceGain) {
        ambienceGain.gain.setTargetAtTime(0.12, audioCtx.currentTime, 0.8);
      }
    }

    function playBeat(freq = 240, duration = 0.05) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      g.gain.value = 0.16;
      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration * 1.25);
    }

    // Build payload for export
    function buildExportPayload() {
      const payload = {
        vibe: {
          mood,
          bpm,
          paletteName: paletteSelect.value,
          integration
        },
        scenes: scenes.map((sc) => ({
          id: sc.id,
          name: sc.name,
          durationSec: sc.durationSec,
          mood: sc.mood,
          palette: sc.palette,
          shapes: sc.shapes.map(sh => ({
            kind: sh.kind,
            x: sh.x, y: sh.y, size: sh.size, color: sh.color
          }))
        })),
        metadata: {
          createdAt: new Date().toISOString(),
          version: "VibeGameAI Studio MVP+"
        }
      };
      return payload;
    }

    // Export / Import helpers
    function applyImportedConfig(data) {
      if (!data || !data.vibe) {
        log('Invalid config.');
        return;
      }
      mood = data.vibe.mood || 'Chill';
      bpm = data.vibe.bpm || 100;
      paletteSelect.value = data.vibe.paletteName || 'Pastel';
      integrationSelect.value = data.vibe.integration || 'GPTApp';
      moodSelect.value = mood;
      tempoRange.value = bpm;
      beatIntervalMs = 60000 / bpm;
      // scenes
      if (Array.isArray(data.scenes) && data.scenes.length > 0) {
        scenes = data.scenes.map((sc, idx) => ({
          id: sc.id ?? idx,
          name: sc.name ?? `Scene ${idx+1}`,
          durationSec: sc.durationSec ?? 45,
          mood: sc.mood ?? mood,
          palette: sc.palette ?? PALETTES.Pastel,
          shapes: (sc.shapes || []).map(sh => ({
            kind: sh.kind, x: sh.x, y: sh.y, size: sh.size, color: sh.color, seed: Math.random()
          }))
        }));
        currentSceneIndex = 0;
        sceneWidth = stageWidth;
        sceneHeight = stageHeight;
        shapes = scenes[0]?.shapes ?? [];
        log('Config applied. Ready to run.');
      }
      // audio mood
      applyMoodAudio();
    }

    function attemptHit(nowMs) {
      if (!startTime) return;
      const t = nowMs - startTime;
      const beatIndex = Math.floor(t / beatIntervalMs);
      const beatTime = startTime + beatIndex * beatIntervalMs;
      const diff = Math.abs(nowMs - beatTime);
      if (beatIndex > lastBeatBeatIndex && diff <= 210) {
        lastBeatBeatIndex = beatIndex;
        const gained = 100;
        score += gained;
        hudScore.textContent = score.toString();
        log(`Hit! +${gained} (beat ${beatIndex})`);
        triggerBeatEffect(currentSceneIndex);
        playBeat(Math.max(180, 320 - currentSceneIndex * 40), 0.08);
      } else {
        log('Miss');
      }
    }

    // Visuals: beat glow
    let beatFlash = 0;
    function triggerBeatEffect(sceneIndex) {
      beatFlash = 1;
      // flash overlay by drawing a white glow at center
      // actual drawing happens in render loop
    }

    // Core loop: rendering
    function resetRun() {
      running = false;
      paused = false;
      startTime = null;
      lastBeatBeatIndex = -1;
      currentSceneIndex = 0;
      score = 0;
      hudScore.textContent = score.toString();
      hudBeat.textContent = '-';
      hudTimer.textContent = '00:00';
      log('Reset level');
      if (stageCtx) {
        stageCtx.clearRect(0,0,stageWidth, stageHeight);
        drawBackground();
      }
      statusBadge.textContent = 'Idle';
    }

    function startRun() {
      readVibeConfig();
      // RNG seeded by vibe and time
      const seedBase = (mood + integration).split('').reduce((a,c,i)=> a + c.charCodeAt(0) * (i+1), 0);
      const rng = new Mulberry32(seedBase ^ Date.now());
      scenes = generateScenes(mood, paletteSelect.value, rng);
      currentSceneIndex = 0;
      startTime = performance.now();
      score = 0;
      hudScore.textContent = score.toString();
      beatIntervalMs = 60000 / bpm;
      ensureAudioContext();
      applyMoodAudio();
      log(`Starting level: Mood=${mood}, BPM=${bpm}, Palette=${paletteSelect.value}, Integration=${integration}`);
      log(`AI Prompt: ${aiPromptFlavor(mood, integration, rng)}`);
      shapes = scenes[0]?.shapes ?? [];
      statusBadge.textContent = 'Running';
      running = true;
      paused = false;
      lastBeatBeatIndex = -1;
      requestAnimationFrame(loop);
    }

    function readVibeConfig() {
      mood = moodSelect.value;
      bpm = parseInt(tempoRange.value) || 100;
      palette = PALETTES[paletteSelect.value] || PALETTES.Pastel;
      integration = integrationSelect.value;
      beatIntervalMs = 60000 / bpm;
    }

    function drawBackground() {
      const w = stageWidth, h = stageHeight;
      // smooth gradient derived from mood
      let a = '#1a1f2e', b = '#0b0f15';
      switch (mood) {
        case 'Energetic':
          a = '#1a0e37'; b = '#0b0f15';
          break;
        case 'Mysterious':
          a = '#1b0d2b'; b = '#0b0f15';
          break;
        case 'Joyful':
          a = '#2b1a0d'; b = '#0b0f15';
          break;
        default:
          a = '#1a2130'; b = '#0b0f15';
      }
      const g = stageCtx.createLinearGradient(0, 0, w, h);
      g.addColorStop(0, a);
      g.addColorStop(1, b);
      stageCtx.fillStyle = g;
      stageCtx.fillRect(0, 0, w, h);
    }

    function renderScene(scene, t) {
      const w = stageWidth, h = stageHeight;
      // base gradient
      const c0 = scene.palette[0], c1 = scene.palette[1] || scene.palette[0];
      const grad = stageCtx.createLinearGradient(0, 0, w, h);
      grad.addColorStop(0, c0);
      grad.addColorStop(1, c1);
      stageCtx.fillStyle = grad;
      stageCtx.fillRect(0, 0, w, h);

      // parallax-ish particles
      const phase = (t * 0.001) * 0.6;
      for (let i=0; i<scene.shapes.length; i++) {
        const s = scene.shapes[i];
        const px = (s.x + Math.sin(phase * (i+1) + (s.seed || 0)) * 20) % w;
        const py = (s.y + Math.cos(phase * (i+2) + (s.seed || 0)) * 20) % (h);
        stageCtx.save();
        stageCtx.globalAlpha = 0.6 + 0.4 * (((i % 3) / 3));
        stageCtx.fillStyle = s.color;
        if (s.kind === 'circle') {
          stageCtx.beginPath();
          stageCtx.arc(px, py, Math.max(6, s.size * 0.5), 0, Math.PI*2);
          stageCtx.fill();
        } else {
          stageCtx.fillRect(px - s.size * 0.5, py - s.size * 0.5, s.size, s.size);
        }
        stageCtx.restore();
      }

      // subtle morphing ring in center (cool animation)
      stageCtx.save();
      const r = Math.sin((t * 0.0012) * 0.8) * 10 + 60;
      const cx = w/2, cy = h/2;
      const ringGrad = stageCtx.createRadialGradient(cx, cy, r*0.1, cx, cy, r*2);
      ringGrad.addColorStop(0, 'rgba(255,255,255,0.08)');
      ringGrad.addColorStop(1, 'rgba(255,255,255,0.0)');
      stageCtx.fillStyle = ringGrad;
      stageCtx.beginPath();
      stageCtx.arc(cx, cy, r*2, 0, Math.PI*2);
      stageCtx.fill();
      stageCtx.restore();
    }

    // Beat glow flash overlay
    function drawBeatFlash() {
      if (!beatFlash) return;
      stageCtx.save();
      stageCtx.globalCompositeOperation = 'lighter';
      stageCtx.fillStyle = 'rgba(255,255,255,0.15)';
      stageCtx.fillRect(0, 0, stageWidth, stageHeight);
      stageCtx.restore();
      beatFlash -= 1;
    }

    let lastBeatTime = 0;

    function loop(now) {
      if (!running || paused) return;
      if (!startTime) startTime = now;
      const elapsed = now - startTime;
      const t = now - lastFrameTime;
      lastFrameTime = now;

      // determine current scene by elapsed
      let acc = 0;
      let idx = 0;
      for (let i = 0; i < scenes.length; i++) {
        acc += scenes[i].durationSec;
        if (elapsed / 1000 < acc) { idx = i; break; }
      }
      if (idx !== currentSceneIndex) {
        currentSceneIndex = idx;
        shapes = scenes[idx]?.shapes ?? [];
        log(`Switched to Scene ${idx+1}`);
      }

      // Beat progression and audio
      const beatIndex = Math.floor(elapsed / beatIntervalMs);
      if (beatIndex !== lastBeatBeatIndex) {
        lastBeatBeatIndex = beatIndex;
        const freq = 220 + currentSceneIndex * 40;
        playBeat(freq, 0.05);
        hudBeat.textContent = beatIndex.toString();
        triggerBeatEffect(currentSceneIndex);
        // gentle tempo bleed into ambience
        if (ambienceGain) {
          ambienceGain.gain.setTargetAtTime(0.18, audioCtx.currentTime, 0.25);
        }
      }

      // Rendering
      stageCtx.clearRect(0,0,stageWidth, stageHeight);
      drawBackground();
      const sceneObj = scenes[currentSceneIndex];
      if (sceneObj) renderScene(sceneObj, elapsed) ;
      drawBeatFlash();

      // HUD timer
      const msLeft = Math.max(0, DURATION_MS - elapsed);
      const secLeft = Math.ceil(msLeft / 1000);
      const mins = Math.floor(secLeft / 60);
      const secs = secLeft % 60;
      hudTimer.textContent = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

      // End condition
      if (msLeft <= 0) {
        endRun();
        return;
      }

      requestAnimationFrame(loop);
    }

    function endRun() {
      running = false;
      paused = false;
      log('Level complete.');
      statusBadge.textContent = 'Finished';
      // simple overlay
      stageCtx.fillStyle = 'rgba(0,0,0,0.25)';
      stageCtx.fillRect(0,0,stageWidth, stageHeight);
      stageCtx.fillStyle = '#fff';
      stageCtx.font = '20px sans-serif';
      stageCtx.fillText(`Final Score: ${score}`, 20, 40);
    }

    // Visual helper
    function generateScenes(seedMood, seedPalette, rng) {
      const baseMood = MOOD_METADATA[seedMood] || MOOD_METADATA.Chill;
      const chosenPaletteName = seedPalette || baseMood.basePalette;
      const chosenPalette = PALETTES[chosenPaletteName] || PALETTES.Pastel;
      const scenesList = [];
      const seedStart = Math.floor(rng.next() * 100000);
      for (let si = 0; si < 4; si++) {
        const scene = {
          id: si,
          name: `Scene ${si + 1}: ${seedMood} #{${si}}`,
          durationSec: 45,
          palette: chosenPalette,
          mood: seedMood,
          shapes: []
        };
        const count = 12 + si * 2;
        for (let s = 0; s < count; s++) {
          const kind = rng.next() < 0.5 ? 'circle' : 'rect';
          const cx = rng.next() * stageWidth;
          const cy = rng.next() * stageHeight;
          const size = 10 + rng.next() * 60;
          const color = chosenPalette[(si + s) % chosenPalette.length];
          scene.shapes.push({ kind, x: cx, y: cy, size, color, seed: rng.next() });
        }
        scenesList.push(scene);
      }
      return scenesList;
    }

    function aiPromptFlavor(vibe, integrationName, rng) {
      const prefixes = {
        Plapp: 'Abstract spatial rhythm prompts',
        GPTApp: 'Structured scene prompts with rhythm cues',
        'Hanna vibegame AI': 'Dynamic hue morphing and motion cues'
      };
      const p = prefixes[integrationName] || prefixes.GPTApp;
      const moodLine = `Mood=${vibe}; Palette=derived; Integration=${integrationName}; Seed=${rng.nextInt(0,99999)}`;
      return `${p} | ${moodLine}`;
    }

    function triggerBeatEffect(sceneIndex) {
      beatFlash = 1;
      // No heavy overlay; handled in drawBeatFlash
    }

    // Global payload export helper
    function generateReadme() { return ""; }

    // Start-up
    window.addEventListener('load', () => {
      // initial reset
      resetRun();
      // default visuals
      log('VibeGame AI Studio loaded. Press Start Level to begin.');
      // init mood audio if available
      // note: audio will start after user gesture
    });

    // Helpers for visuals
    function drawBackgroundQuick() {
      const w = stageWidth, h = stageHeight;
      stageCtx.fillStyle = '#0b0f15';
      stageCtx.fillRect(0,0,w,h);
    }

    // Initialize an ambient glow overlay variable
    let beatFlash = 0;

    // Initialize an initial readme
    readmePanel.style.display = 'block';
    readmeToggle.textContent = 'Hide Readme / Taxonomy';
    readmeToggle.addEventListener('click', () => {
      const vis = readmePanel.style.display !== 'none';
      readmePanel.style.display = vis ? 'none' : 'block';
      readmeToggle.textContent = vis ? 'Readme / Taxonomy' : 'Hide Readme / Taxonomy';
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'p') {
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      } else if (e.key.toLowerCase() === 'r') {
        resetRun();
      } else if (e.key.toLowerCase() === 's') {
        if (!running) startRun();
      }
    });

    // Minimal AI flavor prompt on demand (for fun)
    function aiFlavorText() {
      const moods = ['Chill','Energetic','Mysterious','Joyful'];
      const paletteNames = Object.keys(PALETTES);
      const mood = moods[Math.floor(Math.random()*moods.length)];
      const palette = paletteNames[Math.floor(Math.random()*paletteNames.length)];
      return `Mood=${mood}; Palette=${palette}; Integration=${integrationSelect.value}`;
    }

    // Export logger colorized
    function logColored(msg, color) {
      log(`<span style="color:${color||'#e6f0f5'}">${msg}</span>`);
    }

    // Initial UI setup text
    log('Ready. Adjust vibe settings and press Start Level.');
  </script>
</body>
</html>