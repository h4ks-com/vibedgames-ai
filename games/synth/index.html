<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D SYNTH STATION</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
        }
        p { margin: 5px 0; opacity: 0.7; font-size: 14px; }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.85);
            padding: 20px;
            border: 1px solid #0ff;
            border-radius: 10px;
            display: flex;
            gap: 20px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        label {
            color: #0ff;
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 4px;
            background: #333;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0ff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px #0ff;
        }
        select {
            background: #000;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 5px;
            font-family: inherit;
            cursor: pointer;
        }
        
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
            cursor: pointer;
        }
        #start-btn {
            border: 2px solid #0ff;
            color: #0ff;
            padding: 20px 40px;
            font-size: 24px;
            background: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            transition: 0.2s;
        }
        #start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
        }
        .midi-status {
            font-size: 10px;
            color: #f00;
            margin-top: 5px;
        }
        .midi-status.active {
            color: #0f0;
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <div id="start-btn">CLICK TO START</div>
        <p style="color:#aaa; margin-top:10px;">Use Keyboard, Mouse, or MIDI Controller</p>
    </div>

    <div id="ui-layer">
        <h1>NEON SYNTH 3D</h1>
        <p>Interactive Audio-Visual Experience</p>
        <div id="midi-indicator" class="midi-status">MIDI: Disconnected</div>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Waveform</label>
            <select id="waveform">
                <option value="sawtooth">Sawtooth</option>
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="sine">Sine</option>
            </select>
        </div>
        <div class="control-group">
            <label>Cutoff</label>
            <input type="range" id="cutoff" min="100" max="10000" value="2000">
        </div>
        <div class="control-group">
            <label>Resonance</label>
            <input type="range" id="resonance" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>Attack</label>
            <input type="range" id="attack" min="0.01" max="1" step="0.01" value="0.05">
        </div>
        <div class="control-group">
            <label>Release</label>
            <input type="range" id="release" min="0.1" max="3" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label>Reverb Mix</label>
            <input type="range" id="reverb" min="0" max="1" step="0.1" value="0.3">
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256;
                this.masterGain.connect(this.analyser);

                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.connect(this.masterGain);

                // Reverb (Convolver)
                this.reverbNode = this.ctx.createConvolver();
                this.reverbGain = this.ctx.createGain();
                this.dryGain = this.ctx.createGain();
                this.reverbGain.connect(this.masterGain);
                this.dryGain.connect(this.masterGain);
                
                // Generate Impulse Response for Reverb
                this.generateReverbImpulse();
                
                // Params
                this.params = {
                    waveform: 'sawtooth',
                    cutoff: 2000,
                    resonance: 5,
                    attack: 0.05,
                    release: 0.5,
                    reverbMix: 0.3
                };

                this.activeVoices = {};
            }

            async init() {
                if (this.ctx.state === 'suspended') {
                    await this.ctx.resume();
                }
            }

            generateReverbImpulse() {
                const rate = this.ctx.sampleRate;
                const length = rate * 2; // 2 seconds
                const impulse = this.ctx.createBuffer(2, length, rate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    const decay = Math.exp(-3 * i / length);
                    left[i] = (Math.random() * 2 - 1) * decay;
                    right[i] = (Math.random() * 2 - 1) * decay;
                }
                this.reverbNode.buffer = impulse;
            }

            playNote(note, frequency) {
                if (this.activeVoices[note]) return; // Already playing

                const voice = {};
                const now = this.ctx.currentTime;

                // Oscillator
                voice.osc = this.ctx.createOscillator();
                voice.osc.type = this.params.waveform;
                voice.osc.frequency.setValueAtTime(frequency, now);

                // Filter
                voice.filter = this.ctx.createBiquadFilter();
                voice.filter.type = 'lowpass';
                voice.filter.frequency.setValueAtTime(this.params.cutoff, now);
                voice.filter.Q.setValueAtTime(this.params.resonance, now);

                // Amp Envelope
                voice.amp = this.ctx.createGain();
                voice.amp.gain.setValueAtTime(0, now);
                voice.amp.gain.linearRampToValueAtTime(0.5, now + this.params.attack);

                // Routing
                voice.osc.connect(voice.filter);
                voice.filter.connect(voice.amp);
                
                // Dry/Wet
                voice.amp.connect(this.dryGain);
                voice.amp.connect(this.reverbNode);

                voice.osc.start(now);
                
                // Update params immediately for real-time tweaking
                voice.updateParams = () => {
                    voice.filter.frequency.setTargetAtTime(this.params.cutoff, this.ctx.currentTime, 0.1);
                    voice.filter.Q.setTargetAtTime(this.params.resonance, this.ctx.currentTime, 0.1);
                    if(voice.osc.type !== this.params.waveform) voice.osc.type = this.params.waveform;
                };
                
                this.dryGain.gain.value = 1 - this.params.reverbMix;
                this.reverbGain.gain.value = this.params.reverbMix;

                this.activeVoices[note] = voice;
            }

            stopNote(note) {
                const voice = this.activeVoices[note];
                if (!voice) return;

                const now = this.ctx.currentTime;
                voice.amp.gain.cancelScheduledValues(now);
                voice.amp.gain.setValueAtTime(voice.amp.gain.value, now);
                voice.amp.gain.exponentialRampToValueAtTime(0.001, now + this.params.release);
                
                voice.osc.stop(now + this.params.release + 0.1);
                delete this.activeVoices[note];
            }

            updateParams(key, value) {
                this.params[key] = value;
                // Realtime update for active voices
                if (key === 'cutoff' || key === 'resonance' || key === 'waveform') {
                    Object.values(this.activeVoices).forEach(v => v.updateParams());
                }
                if (key === 'reverbMix') {
                    this.dryGain.gain.setTargetAtTime(1 - value, this.ctx.currentTime, 0.1);
                    this.reverbGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.1);
                }
            }
        }

        // --- VISUAL ENGINE ---
        class VisualEngine {
            constructor(audio) {
                this.audio = audio;
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 5, 12);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.container.appendChild(this.renderer.domElement);

                this.keys = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isMouseDown = false;
                this.pressedKeyIndex = -1;

                this.initScene();
                this.initEvents();
            }

            initScene() {
                // Lights
                const amb = new THREE.AmbientLight(0x222222);
                this.scene.add(amb);
                
                const pointLight = new THREE.PointLight(0x00ffff, 1, 50);
                pointLight.position.set(0, 10, 5);
                pointLight.castShadow = true;
                this.scene.add(pointLight);

                const spotLight = new THREE.SpotLight(0xff00ff, 2);
                spotLight.position.set(-10, 10, -5);
                spotLight.lookAt(0, 0, 0);
                this.scene.add(spotLight);

                // Grid Floor
                const grid = new THREE.GridHelper(100, 50, 0x111111, 0x050505);
                this.scene.add(grid);

                // Spectrum Visualizer (Bars at the back)
                this.bars = [];
                const barGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
                const barMat = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff, 
                    emissive: 0x004444,
                    transparent: true,
                    opacity: 0.8 
                });
                
                for(let i=0; i<32; i++) {
                    const bar = new THREE.Mesh(barGeo, barMat.clone());
                    bar.position.set((i-16)*1, 1, -8);
                    this.scene.add(bar);
                    this.bars.push(bar);
                }

                // Generate Keyboard
                this.createKeyboard();
            }

            createKeyboard() {
                const startNote = 48; // C3
                const numOctaves = 2;
                const whiteKeyGeo = new THREE.BoxGeometry(1.8, 0.5, 6);
                const blackKeyGeo = new THREE.BoxGeometry(1, 0.6, 4);
                
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 });

                const notes = [0, 2, 4, 5, 7, 9, 11]; // White keys offsets
                const blackNotes = [1, 3, 6, 8, 10]; // Black keys offsets

                let xPos = -((numOctaves * 7) * 1.9) / 2;

                for (let i = 0; i < numOctaves * 12; i++) {
                    const noteIndex = startNote + i;
                    const octave = Math.floor(i / 12);
                    const step = i % 12;
                    
                    const freq = 440 * Math.pow(2, (noteIndex - 69) / 12);

                    // Determine key type
                    const isBlack = blackNotes.includes(step);
                    
                    // White Keys
                    if (!isBlack) {
                        const mesh = new THREE.Mesh(whiteKeyGeo, whiteMat.clone());
                        mesh.position.set(xPos, 0, 0);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        this.scene.add(mesh);
                        this.keys.push({ mesh, note: noteIndex, freq, type: 'white' });
                        xPos += 1.9;
                    } 
                }

                // Reset X for black keys (they sit on top)
                xPos = -((numOctaves * 7) * 1.9) / 2;
                xPos += 1.9 / 2;

                for (let i = 0; i < numOctaves * 12; i++) {
                    const noteIndex = startNote + i;
                    const step = i % 12;
                    
                    const freq = 440 * Math.pow(2, (noteIndex - 69) / 12);
                    const isBlack = blackNotes.includes(step);

                    if (isBlack) {
                        const mesh = new THREE.Mesh(blackKeyGeo, blackMat.clone());
                        mesh.position.set(xPos, 0.3, -1); // Offset forward and up
                        mesh.castShadow = true;
                        this.scene.add(mesh);
                        this.keys.push({ mesh, note: noteIndex, freq, type: 'black' });
                    } else {
                        xPos += 1.9;
                    }
                }
            }

            initEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    if (this.isMouseDown) this.checkIntersection();
                });

                window.addEventListener('mousedown', () => {
                    this.isMouseDown = true;
                    this.checkIntersection();
                });

                window.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                    if (this.pressedKeyIndex !== -1) {
                        this.audio.stopNote(this.keys[this.pressedKeyIndex].note);
                        this.resetKey(this.pressedKeyIndex);
                        this.pressedKeyIndex = -1;
                    }
                });
            }

            checkIntersection() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.keys.map(k => k.mesh));

                if (intersects.length > 0) {
                    const hitMesh = intersects[0].object;
                    const keyObj = this.keys.find(k => k.mesh === hitMesh);
                    
                    if (keyObj && this.pressedKeyIndex !== this.keys.indexOf(keyObj)) {
                        // Release previous if holding
                        if (this.pressedKeyIndex !== -1) {
                            this.audio.stopNote(this.keys[this.pressedKeyIndex].note);
                            this.resetKey(this.pressedKeyIndex);
                        }

                        this.pressedKeyIndex = this.keys.indexOf(keyObj);
                        this.pressKey(this.pressedKeyIndex);
                        this.audio.playNote(keyObj.note, keyObj.freq);
                    }
                } else {
                     if (this.pressedKeyIndex !== -1 && this.isMouseDown === false) {
                         this.audio.stopNote(this.keys[this.pressedKeyIndex].note);
                         this.resetKey(this.pressedKeyIndex);
                         this.pressedKeyIndex = -1;
                     }
                }
            }

            pressKey(index) {
                const k = this.keys[index];
                k.mesh.position.y -= 0.2;
                k.mesh.material.emissive.setHex(0x00ffff);
                k.mesh.material.emissiveIntensity = 0.5;
                
                // Particle Burst
                const pCount = 10;
                for(let i=0; i<pCount; i++) {
                    const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(k.mesh.position);
                    mesh.position.y += 0.5;
                    
                    const vel = new THREE.Vector3(
                        (Math.random()-0.5)*0.2,
                        Math.random()*0.3,
                        (Math.random()-0.5)*0.2
                    );
                    this.scene.add(mesh);
                    this.particles = this.particles || [];
                    this.particles.push({ mesh, vel, life: 1.0 });
                }
            }

            resetKey(index) {
                const k = this.keys[index];
                k.mesh.position.y += 0.2;
                k.mesh.material.emissive.setHex(0x000000);
                k.mesh.material.emissiveIntensity = 0;
            }

            triggerVisual(note) {
                // Find key by note
                const keyIndex = this.keys.findIndex(k => k.note === note);
                if (keyIndex !== -1) {
                    // If not currently pressed by mouse, flash it
                    if (this.pressedKeyIndex !== keyIndex) {
                        const k = this.keys[keyIndex];
                        k.mesh.material.emissive.setHex(0xff00ff);
                        setTimeout(() => {
                            if (k.mesh.material.emissive.getHex() === 0xff00ff) {
                                k.mesh.material.emissive.setHex(0x000000);
                            }
                        }, 200);
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update Audio Visualizer (Bars)
                const dataArray = new Uint8Array(this.audio.analyser.frequencyBinCount);
                this.audio.analyser.getByteFrequencyData(dataArray);

                for (let i = 0; i < this.bars.length; i++) {
                    const value = dataArray[i * 2] || 0;
                    const targetScale = 1 + (value / 256) * 10;
                    this.bars[i].scale.y += (targetScale - this.bars[i].scale.y) * 0.2;
                    this.bars[i].position.y = this.bars[i].scale.y / 2;
                    this.bars[i].material.color.setHSL(i/32, 1, 0.5);
                    this.bars[i].material.emissive.setHSL(i/32, 1, 0.2);
                }

                // Update Particles
                if (this.particles) {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.life -= 0.03;
                        p.mesh.position.add(p.vel);
                        p.mesh.rotation.x += 0.1;
                        p.mesh.scale.setScalar(p.life);
                        if (p.life <= 0) {
                            this.scene.remove(p.mesh);
                            this.particles.splice(i, 1);
                        }
                    }
                }

                // Subtle camera sway
                const time = Date.now() * 0.0005;
                this.camera.position.x = Math.sin(time) * 2;
                this.camera.lookAt(0, 0, 0);

                this.renderer.render(this.scene, this.camera);
            }
        }

        // --- MAIN INIT ---
        const audio = new AudioEngine();
        const visuals = new VisualEngine(audio);
        visuals.animate();

        // UI Connections
        document.getElementById('start-btn').addEventListener('click', async () => {
            await audio.init();
            document.getElementById('start-overlay').style.display = 'none';
        });

        const bindInput = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                audio.updateParams(key, val);
            });
        };

        bindInput('waveform', 'waveform');
        bindInput('cutoff', 'cutoff');
        bindInput('resonance', 'resonance');
        bindInput('attack', 'attack');
        bindInput('release', 'release');
        bindInput('reverb', 'reverbMix');

        // Keyboard Input
        const keyMap = {
            'a': 48, 'w': 49, 's': 50, 'e': 51, 'd': 52, 'f': 53, 't': 54,
            'g': 55, 'y': 56, 'h': 57, 'u': 58, 'j': 59, 'k': 60, // C3 to C4
            'o': 61, 'l': 62, 'p': 63, ';': 64, "'": 65 // Cont
        };
        const activeKeys = {};

        window.addEventListener('keydown', (e) => {
            const note = keyMap[e.key.toLowerCase()];
            if (note && !activeKeys[note]) {
                activeKeys[note] = true;
                const freq = 440 * Math.pow(2, (note - 69) / 12);
                audio.playNote(note, freq);
                visuals.triggerVisual(note);
            }
        });

        window.addEventListener('keyup', (e) => {
            const note = keyMap[e.key.toLowerCase()];
            if (note) {
                activeKeys[note] = false;
                audio.stopNote(note);
            }
        });

        // MIDI Input
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(onMIDISuccess, () => console.log('MIDI Failed'));
        } else {
            console.log('Web MIDI API not supported');
        }

        function onMIDISuccess(midiAccess) {
            const indicator = document.getElementById('midi-indicator');
            indicator.classList.add('active');
            indicator.innerText = "MIDI: Connected";
            
            for (const input of midiAccess.inputs.values()) {
                input.onmidimessage = getMIDIMessage;
            }
        }

        function getMIDIMessage(message) {
            const command = message.data[0];
            const note = message.data[1];
            const velocity = (message.data.length > 2) ? message.data[2] : 0;

            // Note On (usually 144, but sometimes 128 if release velocity)
            if (command === 144 && velocity > 0) {
                const freq = 440 * Math.pow(2, (note - 69) / 12);
                audio.playNote(note, freq);
                visuals.triggerVisual(note);
            }
            // Note Off (128 or 144 with 0 velocity)
            if (command === 128 || (command === 144 && velocity === 0)) {
                audio.stopNote(note);
            }
        }
    </script>
</body>
</html>