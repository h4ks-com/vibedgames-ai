{
  "messages": [
    {
      "role": "user",
      "content": "make a pink and green fully-working game of tetris\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Pink & Green Tetris</title>\n<style>\n  /* Reset and base */\n  * {\n    box-sizing: border-box;\n  }\n  body {\n    background: #111;\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    min-height: 100vh;\n    margin: 0;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    color: #eee;\n    user-select: none;\n  }\n\n  h1 {\n    margin: 0 0 10px 0;\n    color: #FF69B4; /* hotpink */\n    text-shadow: 0 0 6px #FF69B4;\n  }\n\n  #container {\n    margin-top: 20px;\n    display: flex;\n    gap: 20px;\n  }\n\n  /* Canvas for the tetris grid */\n  #tetris {\n    background: #155214; /* dark green background */\n    box-shadow: 0 0 15px #4ade80;\n    border: 5px solid #4ade80; /* vivid green border */\n    image-rendering: pixelated;\n  }\n\n  /* Next piece preview */\n  #next-container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  #next-container h2 {\n    color: #FF69B4;\n    margin-bottom: 8px;\n  }\n  canvas#next {\n    background: #155214;\n    border: 3px solid #4ade80;\n    image-rendering: pixelated;\n  }\n\n  /* Info panel with score and controls */\n  #info {\n    margin-top: 15px;\n    color: #eee;\n    max-width: 200px;\n    font-size: 14px;\n    line-height: 1.4;\n  }\n  #score {\n    font-size: 1.2rem;\n    margin-bottom: 12px;\n    color: #FF69B4;\n    text-shadow: 0 0 5px #FF69B4;\n  }\n  #controls {\n    user-select: none;\n  }\n  #start-button {\n    display: inline-block;\n    margin-top: 10px;\n    padding: 10px 18px;\n    background: #FF69B4;\n    border: none;\n    border-radius: 4px;\n    color: #111;\n    font-weight: 700;\n    cursor: pointer;\n    transition: background 0.3s ease;\n    box-shadow: 0 0 8px #FF69B4;\n  }\n  #start-button:hover {\n    background: #ff85c1;\n  }\n  #start-button:disabled {\n    background: #cc6699;\n    cursor: default;\n    box-shadow: none;\n  }\n  small {\n    display: block;\n    margin-top: 12px;\n    color: #88cc88;\n  }\n</style>\n</head>\n<body>\n  <div>\n    <h1>Pink &amp; Green Tetris</h1>\n    <div id=\"container\">\n      <canvas id=\"tetris\" width=\"240\" height=\"400\"></canvas>\n      <div id=\"next-container\">\n        <h2>Next</h2>\n        <canvas id=\"next\" width=\"80\" height=\"80\"></canvas>\n        <div id=\"info\">\n          <div id=\"score\">Score: 0</div>\n          <button id=\"start-button\">Start Game</button>\n          <small>Controls:</small>\n          <small>← Move Left</small>\n          <small>→ Move Right</small>\n          <small>↑ Rotate</small>\n          <small>↓ Soft Drop</small>\n          <small>Space Hard Drop</small>\n          <small>P Pause / Resume</small>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('tetris');\n  const context = canvas.getContext('2d');\n  context.scale(20, 20);\n\n  const nextCanvas = document.getElementById('next');\n  const nextCtx = nextCanvas.getContext('2d');\n  nextCtx.scale(20, 20);\n\n  const scoreElement = document.getElementById('score');\n  const startButton = document.getElementById('start-button');\n\n  const ROWS = 20;\n  const COLS = 12;\n\n  // Colors for pieces - pink and green themed\n  // We'll blend pink and green shades for each piece\n  const colors = [\n    null,\n    '#FF66B2', // Pink - I - Cyan usually, but pink here\n    '#33CC66', // Green - S\n    '#FF3399', // Pink - Z\n    '#4ADE80', // Green - L\n    '#FF85C1', // Pink - J\n    '#22AA44', // Green - O\n    '#FF007F'  // Pink - T\n  ];\n\n  // Tetrominoes 4x4 matrices\n  const pieces = {\n    I: [\n      [0,0,0,0,\n       1,1,1,1,\n       0,0,0,0,\n       0,0,0,0],\n      [0,0,1,0,\n       0,0,1,0,\n       0,0,1,0,\n       0,0,1,0],\n    ],\n    J: [\n      [2,0,0,\n       2,2,2,\n       0,0,0],\n      [0,2,2,\n       0,2,0,\n       0,2,0],\n      [0,0,0,\n       2,2,2,\n       0,0,2],\n      [0,2,0,\n       0,2,0,\n       2,2,0],\n    ],\n    L: [\n      [0,0,3,\n       3,3,3,\n       0,0,0],\n      [0,3,0,\n       0,3,0,\n       0,3,3],\n      [0,0,0,\n       3,3,3,\n       3,0,0],\n      [3,3,0,\n       0,3,0,\n       0,3,0],\n    ],\n    O: [\n      [4,4,\n       4,4],\n    ],\n    S: [\n      [0,5,5,\n       5,5,0,\n       0,0,0],\n      [0,5,0,\n       0,5,5,\n       0,0,5],\n    ],\n    T: [\n      [0,6,0,\n       6,6,6,\n       0,0,0],\n      [0,6,0,\n       0,6,6,\n       0,6,0],\n      [0,0,0,\n       6,6,6,\n       0,6,0],\n      [0,6,0,\n       6,6,0,\n       0,6,0],\n    ],\n    Z: [\n      [7,7,0,\n       0,7,7,\n       0,0,0],\n      [0,0,7,\n       0,7,7,\n       0,7,0],\n    ]\n  };\n\n  // We'll keep arrays for each piece with just one rotation expanded into 2D\n  // For rotations, to simplify, we generate the 2D arrays on the fly\n  // but to save effort: store arrays as 2d arrays now\n\n  // Convert the raw arrays of 1D into 2D arrays by size:\n  // For simplicity, do that now for pieces with different rotations.\n\n  function to2D(array, width) {\n    let result = [];\n    for (let y=0; y<array.length/width; y++) {\n      result[y] = array.slice(y*width, y*width+width);\n    }\n    return result;\n  }\n\n  // Will redefine pieces with 2D arrays\n  const PIECES = {\n    I: [\n      to2D([0,0,0,0,\n           1,1,1,1,\n           0,0,0,0,\n           0,0,0,0],4),\n      to2D([0,0,1,0,\n           0,0,1,0,\n           0,0,1,0,\n           0,0,1,0],4),\n    ],\n    J: [\n      to2D([2,0,0,\n           2,2,2,\n           0,0,0],3),\n      to2D([0,2,2,\n           0,2,0,\n           0,2,0],3),\n      to2D([0,0,0,\n           2,2,2,\n           0,0,2],3),\n      to2D([0,2,0,\n           0,2,0,\n           2,2,0],3),\n    ],\n    L: [\n      to2D([0,0,3,\n           3,3,3,\n           0,0,0],3),\n      to2D([0,3,0,\n           0,3,0,\n           0,3,3],3),\n      to2D([0,0,0,\n           3,3,3,\n           3,0,0],3),\n      to2D([3,3,0,\n           0,3,0,\n           0,3,0],3),\n    ],\n    O: [\n      to2D([4,4,\n           4,4],2),\n    ],\n    S: [\n      to2D([0,5,5,\n           5,5,0,\n           0,0,0],3),\n      to2D([0,5,0,\n           0,5,5,\n           0,0,5],3),\n    ],\n    T: [\n      to2D([0,6,0,\n           6,6,6,\n           0,0,0],3),\n      to2D([0,6,0,\n           0,6,6,\n           0,6,0],3),\n      to2D([0,0,0,\n           6,6,6,\n           0,6,0],3),\n      to2D([0,6,0,\n           6,6,0,\n           0,6,0],3),\n    ],\n    Z: [\n      to2D([7,7,0,\n           0,7,7,\n           0,0,0],3),\n      to2D([0,0,7,\n           0,7,7,\n           0,7,0],3),\n    ],\n  };\n\n  // Choose order of pieces in array form for picking randomly\n  const pieceKeys = Object.keys(PIECES);\n\n  // Game Board (field)\n  function createMatrix(w, h) {\n    const matrix = [];\n    for (let i=0; i<h; i++) {\n      matrix.push(new Array(w).fill(0));\n    }\n    return matrix;\n  }\n\n  // Check collision of piece and board\n  function collide(board, piece) {\n    const [matrix, pos] = piece;\n    for (let y=0; y<matrix.length; y++) {\n      for (let x=0; x<matrix[y].length; x++) {\n        if (\n          matrix[y][x] !== 0 &&\n          (board[y + pos.y] && board[y + pos.y][x + pos.x]) !== 0\n        ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // Merge piece into board\n  function merge(board, piece) {\n    const [matrix, pos] = piece;\n    for (let y=0; y<matrix.length; y++) {\n      for (let x=0; x<matrix[y].length; x++) {\n        if (matrix[y][x] !== 0) {\n          board[y + pos.y][x + pos.x] = matrix[y][x];\n        }\n      }\n    }\n  }\n\n  // Clear full lines and return number cleared\n  function sweep() {\n    let rowCount = 0;\n    outer: for (let y = board.length -1; y >= 0; y--) {\n      for (let x = 0; x < board[y].length; x++) {\n        if (board[y][x] === 0) {\n          continue outer;\n        }\n      }\n      // Remove row y\n      const row = board.splice(y,1)[0].fill(0);\n      board.unshift(row);\n      y++;\n      rowCount++;\n    }\n    return rowCount;\n  }\n\n  // Draw a matrix to context at offset\n  function drawMatrix(matrix, offset, ctx= context) {\n    for (let y=0; y<matrix.length; y++) {\n      for (let x=0; x<matrix[y].length; x++) {\n        const val = matrix[y][x];\n        if (val !== 0) {\n          ctx.fillStyle = colors[val];\n          ctx.shadowColor = colors[val];\n          ctx.shadowBlur = 8;\n          ctx.fillRect(x + offset.x, y + offset.y, 1, 1);\n          ctx.shadowBlur = 0;\n        }\n      }\n    }\n  }\n\n  // Clear entire canvas\n  function clearCanvas(ctx, width, height) {\n    ctx.clearRect(0, 0, width, height);\n  }\n\n  // Rotate matrix (clockwise)\n  function rotate(matrix, dir=1) {\n    const N = matrix.length;\n    const result = [];\n    for (let y=0; y<N; y++) {\n      result.push(new Array(N).fill(0));\n    }\n\n    for (let y=0; y<N; y++) {\n      for (let x=0; x<N; x++) {\n        if (dir > 0) {\n          result[x][N-1-y] = matrix[y][x];\n        } else {\n          result[N-1-x][y] = matrix[y][x];\n        }\n      }\n    }\n    return result;\n  }\n\n  // Player Object holds current piece\n  const player = {\n    pos: {x:0,y:0},\n    matrix: null,\n    rotationIndex: 0,\n    pieceKey: null,\n  };\n\n  // Next piece info\n  let nextPieceKey = null;\n  let nextRotationIndex = 0;\n\n  // Board variable\n  let board = createMatrix(COLS, ROWS);\n\n  // Score variable\n  let score = 0;\n\n  // Game state\n  let dropCounter = 0;\n  let dropInterval = 800; // ms - speed increases as levels advance\n  let lastTime = 0;\n  let gameOver = false;\n  let paused = false;\n\n  // Holds the current animation frame ID\n  let animationFrameId = null;\n\n  // Functions to reset and pick piece\n  function resetPlayer() {\n    player.pieceKey = nextPieceKey || pieceKeys[randomPieceIndex()];\n    player.rotationIndex = 0;\n    player.matrix = PIECES[player.pieceKey][player.rotationIndex];\n    player.pos.y = 0;\n    player.pos.x = Math.floor((COLS - player.matrix[0].length) /2);\n    nextPieceKey = pieceKeys[randomPieceIndex()];\n    nextRotationIndex = 0;\n  }\n\n  // Random index helper\n  function randomPieceIndex() {\n    return Math.floor(Math.random() * pieceKeys.length);\n  }\n\n  // Drop piece by 1 or lock it if collides\n  function playerDrop() {\n    player.pos.y++;\n    if (collide(board, [player.matrix, player.pos])) {\n      player.pos.y--;\n      merge(board, [player.matrix, player.pos]);\n      const cleared = sweep();\n      if (cleared > 0) {\n        updateScore(cleared);\n      }\n      resetPlayer();\n      if (collide(board, [player.matrix, player.pos])) {\n        // Game Over\n        endGame();\n      }\n    }\n    dropCounter = 0;\n  }\n\n  // Move piece left or right\n  function playerMove(dir) {\n    player.pos.x += dir;\n    if (collide(board, [player.matrix, player.pos])) {\n      player.pos.x -= dir;\n    }\n  }\n\n  // Rotate piece\n  function playerRotate(dir) {\n    const prevRotation = player.rotationIndex;\n    let newRotation = (player.rotationIndex + dir);\n    const pieceVariants = PIECES[player.pieceKey];\n    if (newRotation < 0) newRotation = pieceVariants.length - 1;\n    else if (newRotation >= pieceVariants.length) newRotation = 0;\n    const rotatedMatrix = pieceVariants[newRotation];\n    const posX = player.pos.x;\n    let offset = 0;\n    player.matrix = rotatedMatrix;\n    player.rotationIndex = newRotation;\n\n    // Wall kick logic - try shifting left/right if collides\n    while (collide(board, [player.matrix, player.pos])) {\n      offset = (offset === 0) ? 1 : -(offset + (offset > 0 ? 1 : -1));\n      player.pos.x += offset;\n      if (Math.abs(offset) > player.matrix[0].length) {\n        // Can't rotate, revert\n        player.pos.x = posX;\n        player.matrix = pieceVariants[prevRotation];\n        player.rotationIndex = prevRotation;\n        return;\n      }\n    }\n  }\n\n  // Hard drop piece instantly\n  function playerHardDrop() {\n    while (!collide(board, [player.matrix, {x: player.pos.x, y: player.pos.y + 1}])) {\n      player.pos.y++;\n    }\n    playerDrop();\n  }\n\n  // Update score according to number of lines cleared\n  // Scoring: single=40, double=100, triple=300, tetris=1200 (classic scoring, multiplied by level)\n  // Level increases every 10 lines cleared\n  let totalLines = 0;\n  let level = 0;\n\n  function updateScore(clearedLines){\n    const lineScores = [0, 40, 100, 300, 1200];\n    score += lineScores[clearedLines]*(level+1);\n    totalLines += clearedLines;\n    const newLevel = Math.floor(totalLines / 10);\n    if (newLevel > level) {\n      level = newLevel;\n      dropInterval = Math.max(100, 800 - level*70);\n    }\n    scoreElement.textContent = `Score: ${score}`;\n  }\n\n  // Draw game state\n  function draw() {\n    clearCanvas(context, canvas.width, canvas.height);\n    drawMatrix(board, {x:0,y:0});\n    drawMatrix(player.matrix, player.pos);\n\n    // Draw next piece preview\n    clearCanvas(nextCtx, nextCanvas.width, nextCanvas.height);\n    if(nextPieceKey){\n      const pieceVariants = PIECES[nextPieceKey];\n      const nextMatrix = pieceVariants[nextRotationIndex];\n      // Offset so next piece centered in next canvas: 4x4 or 3x3 or 2x2\n      let offsetX = 0;\n      let offsetY = 0;\n      if(nextMatrix.length === 4){\n        offsetX = 0;\n        offsetY = 0;\n      } else if(nextMatrix.length === 3){\n        offsetX = 0.5;\n        offsetY = 0.5;\n      } else if(nextMatrix.length ===2){\n        offsetX = 1;\n        offsetY = 1;\n      }\n      drawMatrix(nextMatrix, {x: offsetX, y: offsetY}, nextCtx);\n    }\n  }\n\n  // Game loop\n  function update(time = 0) {\n    if(gameOver || paused){\n      animationFrameId = requestAnimationFrame(update);\n      return;\n    }\n    const deltaTime = time - lastTime;\n    lastTime = time;\n\n    dropCounter += deltaTime;\n    if(dropCounter > dropInterval){\n      playerDrop();\n    }\n\n    draw();\n    animationFrameId = requestAnimationFrame(update);\n  }\n\n  // Reset everything\n  function resetGame() {\n    board = createMatrix(COLS, ROWS);\n    score = 0;\n    level = 0;\n    totalLines = 0;\n    dropInterval = 800;\n    scoreElement.textContent = `Score: ${score}`;\n    gameOver = false;\n    paused = false;\n    nextPieceKey = pieceKeys[randomPieceIndex()];\n    resetPlayer();\n  }\n\n  // End game state\n  function endGame() {\n    gameOver = true;\n    paused = false;\n    alert(`Game Over!\\nYour score: ${score}`);\n    startButton.disabled = false;\n  }\n\n  // Pause toggle\n  function togglePause() {\n    if(gameOver) return;\n    paused = !paused;\n    if(!paused){\n      lastTime = performance.now();\n    }\n  }\n\n  // Event handlers\n\n  document.addEventListener('keydown', event => {\n    if(gameOver || paused) {\n      if(event.key === 'p' || event.key === 'P'){\n        togglePause();\n      }\n      return;\n    }\n    switch(event.key){\n      case 'ArrowLeft':\n        event.preventDefault();\n        playerMove(-1);\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        playerMove(1);\n        break;\n      case 'ArrowDown':\n        event.preventDefault();\n        playerDrop();\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        playerRotate(1);\n        break;\n      case ' ':\n        event.preventDefault();\n        playerHardDrop();\n        break;\n      case 'p':\n      case 'P':\n        event.preventDefault();\n        togglePause();\n        break;\n    }\n    draw();\n  });\n\n  startButton.addEventListener('click', () => {\n    resetGame();\n    startButton.disabled = true;\n    lastTime = performance.now();\n    if(animationFrameId) cancelAnimationFrame(animationFrameId);\n    animationFrameId = requestAnimationFrame(update);\n  });\n\n  // Draw startup screen with instructions\n  function startupScreen() {\n    clearCanvas(context, canvas.width, canvas.height);\n    context.fillStyle = '#4ADE80';\n    context.font = '1rem monospace';\n    context.textAlign = 'center';\n    const lines = [\n      'Pink & Green Tetris',\n      '',\n      'Press \"Start Game\" to play',\n      'Controls:',\n      '← Move Left',\n      '→ Move Right',\n      '↑ Rotate',\n      '↓ Soft Drop',\n      'Space Hard Drop',\n      'P Pause / Resume'\n    ];\n    lines.forEach((line, i) => {\n      context.fillText(line, COLS/2, ROWS/2 - 5 + i * 1.2);\n    });\n  }\n\n  // Init\n  startupScreen();\n\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}