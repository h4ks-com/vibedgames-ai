{
  "messages": [
    {
      "role": "user",
      "content": "a small roguelike game where every move made the the player invokes the function that creates a new game, causing a new game to be created with the following properties: random color background, random subdomain name, mini roguelike where every move made the the player invokes the function that creates a new game, causing a new game to be created with the following properties: random color background, random subdomain name, mini roguelike\nMake sure everything is in a single HTML file with embedded CSS and JS in a single code block to be used as a web app."
    },
    {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Infinite Recursive Mini Roguelike</title>\n<style>\n  html, body {\n    margin: 0; padding: 0; height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-family: monospace, monospace;\n    user-select: none;\n    overflow: hidden;\n    background: #000;\n  }\n  #game {\n    width: 320px;\n    height: 320px;\n    display: grid;\n    grid-template-columns: repeat(16, 1fr);\n    grid-template-rows: repeat(16, 1fr);\n    gap: 1px;\n    box-shadow: 0 0 15px #000 inset;\n    background: #111;\n    border: 3px solid #222;\n    position: relative;\n  }\n  .cell {\n    width: 100%;\n    height: 100%;\n    background: #222;\n  }\n  .floor {\n    background: #444;\n  }\n  .wall {\n    background: #111;\n  }\n  .player {\n    background: limegreen;\n  }\n  .goal {\n    background: gold;\n  }\n  #info {\n    position: absolute;\n    top: 2px;\n    left: 2px;\n    right: 2px;\n    color: white;\n    font-size: 14px;\n    text-align: center;\n    user-select: none;\n    pointer-events: none;\n    line-height: 1.2;\n  }\n  #subdomain {\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n<div id=\"game\" tabindex=\"0\" aria-label=\"Mini roguelike game\" role=\"application\">\n  <div id=\"info\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n</div>\n\n<script>\n(() => {\n  const SIZE = 16;\n  const WALL_CHANCE = 0.2;\n\n  // Random color background function - pastel\n  function randomPastelColor() {\n    const r = 150 + Math.floor(Math.random() * 105);\n    const g = 150 + Math.floor(Math.random() * 105);\n    const b = 150 + Math.floor(Math.random() * 105);\n    return `rgb(${r},${g},${b})`;\n  }\n\n  // Generate a random short subdomain string a-z, len 3-7\n  function randomSubdomain() {\n    const letters = \"abcdefghijklmnopqrstuvwxyz\";\n    const length = 3 + Math.floor(Math.random()*5);\n    let s = \"\";\n    for(let i=0;i<length;i++) s += letters[Math.floor(Math.random()*letters.length)];\n    return s;\n  }\n\n  // Maze generation (simple random walls with guaranteed path)\n  // We'll carve a simple guaranteed path from player to goal\n\n  // Player and goal positions\n  // Player at top-left (0,0)\n  // Goal at bottom-right (SIZE-1, SIZE-1)\n\n  function generateMap() {\n    let map = [];\n    for(let y=0; y<SIZE; y++) {\n      map[y] = [];\n      for(let x=0;x<SIZE;x++) {\n        map[y][x] = Math.random() < WALL_CHANCE ? 1 : 0; // 1=wall,0=floor\n      }\n    }\n    // Clear player and goal spots\n    map[0][0] = 0;\n    map[SIZE-1][SIZE-1] = 0;\n\n    // Carve guaranteed PATH from (0,0) to (SIZE-1,SIZE-1) - diagonal simple path\n    let cx=0, cy=0;\n    while(cx < SIZE-1 || cy < SIZE-1) {\n      map[cy][cx] = 0;\n      if(cx < SIZE-1 && cy < SIZE-1) {\n        if(Math.random()<0.5) cx++; else cy++;\n      } else if(cx < SIZE-1) cx++;\n      else if(cy < SIZE-1) cy++;\n      else break;\n    }\n    map[SIZE-1][SIZE-1] = 0;\n\n    return map;\n  }\n\n  // Each new game instance is defined by:\n  // player pos, map, background color, subdomain\n\n  function createNewGame() {\n    // Generate background color and subdomain\n    const bgColor = randomPastelColor();\n    const subdomain = randomSubdomain();\n\n    // Map\n    const map = generateMap();\n\n    // Player pos\n    const player = {x:0,y:0};\n\n    return { bgColor, subdomain, map, player, moves: 0 };\n  }\n\n  // Render game to DOM\n  function renderGame(game) {\n    const container = document.getElementById(\"game\");\n    container.innerHTML = \"\"; // Clear previous cells and info\n\n    container.style.background = game.bgColor;\n\n    // Placing grid cells:\n    // We'll create SIZE*SIZE divs with classes based on map.\n    // Priority: player cell, goal cell, wall or floor.\n\n    for(let y=0; y<SIZE; y++) {\n      for(let x=0; x<SIZE; x++) {\n        const cell = document.createElement(\"div\");\n        cell.classList.add(\"cell\");\n\n        if(game.player.x === x && game.player.y === y) {\n          cell.classList.add(\"player\");\n          cell.textContent = \"@\";\n          cell.style.color = \"#000\";\n          cell.style.textAlign = \"center\";\n          cell.style.lineHeight = \"20px\";\n          cell.style.fontWeight = \"bold\";\n          cell.style.fontSize = \"18px\";\n          cell.style.userSelect = \"none\";\n        } else if(x===SIZE-1 && y===SIZE-1) {\n          cell.classList.add(\"goal\");\n          cell.textContent = \"X\";\n          cell.style.color = \"#000\";\n          cell.style.textAlign = \"center\";\n          cell.style.lineHeight = \"20px\";\n          cell.style.fontWeight = \"bold\";\n          cell.style.fontSize = \"18px\";\n          cell.style.userSelect = \"none\";\n        } else if(game.map[y][x]===1) {\n          cell.classList.add(\"wall\");\n        } else {\n          cell.classList.add(\"floor\");\n        }\n\n        container.appendChild(cell);\n      }\n    }\n\n    // Info display\n    const info = document.createElement(\"div\");\n    info.id = \"info\";\n    info.innerHTML = `\n      Subdomain: <span id=\"subdomain\">${game.subdomain}</span><br>\n      Moves made: ${game.moves}<br>\n      Use arrow keys or WASD to move.<br>\n      Reach the goal (X) to win.<br>\n      Every move restarts a new game with different background & subdomain.\n    `;\n    container.appendChild(info);\n    container.focus(); // Keep focus for keyboard\n  }\n\n  // Move player if valid\n  function tryMove(game, dx, dy) {\n    const nx = game.player.x + dx;\n    const ny = game.player.y + dy;\n    if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) return false;\n    if(game.map[ny][nx] === 1) return false;\n    game.player.x = nx;\n    game.player.y = ny;\n    game.moves++;\n    return true;\n  }\n\n  // The recursive rule:\n  // \"every move made the player invokes the function that creates a new game,\n  // causing a new game to be created with the following properties...\"\n  //\n  // So on each valid player move, we create a brand new game instance afresh\n  // with new background, subdomain, and fresh map & player pos.\n  //\n  // So effectively after a move, the previous game is replaced with a completely new one.\n  //\n  // This means the player's position is always reset to 0,0 on each new game,\n  // but player can try to move again and get a new game that might have maybe better/worse map.\n\n  // Implementation: on key press,\n  // attempt move on current game (we can imagine a single temporary game state),\n  // then discard old and create a completely new game.\n\n  // The 'movement' will just \"simulate\" a move on current game to decide if move possible,\n  // but then discard old game and start brand new game.\n\n  // However to avoid confusion:\n  // If move invalid, no new game created, stay on current one.\n  // If move valid, create new game.\n\n  // If after move, player position is at goal, display victory for a moment before new move.\n\n  // We'll keep the game instance in closure\n\n  let currentGame = createNewGame();\n\n  function onKey(e) {\n    const KEYMAP = {\n      37: [-1,0], // left\n      38: [0,-1], // up\n      39: [1,0],  // right\n      40: [0,1],  // down\n      65: [-1,0], // a\n      87: [0,-1], // w\n      68: [1,0],  // d\n      83: [0,1],  // s\n    };\n    if (!(e.keyCode in KEYMAP)) return;\n    e.preventDefault();\n    const [dx, dy] = KEYMAP[e.keyCode];\n\n    // Test move: if invalid, do nothing\n    const nx = currentGame.player.x + dx;\n    const ny = currentGame.player.y + dy;\n    if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) return;\n    if(currentGame.map[ny][nx] === 1) return;\n\n    // Move is valid => create new game\n    currentGame = createNewGame();\n\n    // For fun, carry over moves+1 (or reset moves?)\n    // Spec not totally clear. We'll reset moves to 0 always.\n    // Place player where? Always 0,0 as per createNewGame.\n\n    renderGame(currentGame);\n  }\n\n  // Initial render\n  renderGame(currentGame);\n\n  // Listen keys\n  const container = document.getElementById('game');\n  container.addEventListener(\"keydown\", onKey);\n\n  // Ensure focus on click to get keyboard input\n  container.addEventListener(\"click\", () => container.focus());\n})();\n</script>\n</body>\n</html>\n```"
    }
  ]
}