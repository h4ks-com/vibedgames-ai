<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BUBBLER 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        #score-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
        }
        #menu-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            transition: opacity 0.3s;
        }
        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }
        h1 {
            font-size: 60px;
            margin: 0 0 20px 0;
            letter-spacing: 5px;
            background: linear-gradient(to bottom, #fff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #ddd;
        }
        button {
            background: linear-gradient(45deg, #00cccc, #008888);
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.7);
        }
        button:active {
            transform: scale(0.95);
        }
        .controls-hint {
            margin-top: 20px;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="score-hud">Score: 0</div>

        <div id="menu-screen">
            <h1>BUBBLER</h1>
            <p>Pop the small bubbles to grow.<br>Avoid the red spikes.</p>
            <button id="start-btn">PLAY</button>
            <div class="controls-hint">WASD or Arrows to Move</div>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>POP!</h1>
            <p>You hit a spike.</p>
            <p id="final-score">Score: 0</p>
            <button id="restart-btn">TRY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- Audio System (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // --- Music System ---
        let musicInterval;
        let noteIndex = 0;
        let musicGainNode;

        // Simple upbeat melody (Frequencies)
        const melody = [
            261.63, 0, 329.63, 0, 392.00, 0, 523.25, 0, // C E G C
            293.66, 0, 349.23, 0, 440.00, 0, 587.33, 0, // D F A D
            261.63, 0, 329.63, 0, 392.00, 0, 523.25, 0, // C E G C
            349.23, 0, 329.63, 0, 293.66, 0, 261.63, 0  // F E D C
        ];

        function playMusicNote() {
            if (!isGameActive) return;

            const freq = melody[noteIndex];
            noteIndex = (noteIndex + 1) % melody.length;

            if (freq === 0) return; // Rest

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'triangle'; // Softer, funny sound
            osc.frequency.value = freq;

            osc.connect(gain);
            gain.connect(musicGainNode);

            const now = audioCtx.currentTime;
            // Short plucky sound
            gain.gain.setValueAtTime(0.08, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

            osc.start(now);
            osc.stop(now + 0.2);
        }

        function startMusic() {
            if (musicInterval) clearInterval(musicInterval);
            musicGainNode = audioCtx.createGain();
            musicGainNode.gain.value = 0.15; // Low volume
            musicGainNode.connect(audioCtx.destination);
            
            noteIndex = 0;
            // 150ms per note = Fast, bouncy tempo
            musicInterval = setInterval(playMusicNote, 150); 
        }

        function stopMusic() {
            if (musicInterval) clearInterval(musicInterval);
            musicInterval = null;
        }

        function playCollectSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            // Happy major chord arpeggio
            const now = audioCtx.currentTime;
            osc.type = 'sine';
            
            // Note sequence
            osc.frequency.setValueAtTime(523.25, now); // C5
            osc.frequency.setValueAtTime(659.25, now + 0.1); // E5
            osc.frequency.setValueAtTime(783.99, now + 0.2); // G5
            osc.frequency.setValueAtTime(1046.50, now + 0.3); // C6
            
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
            
            osc.start(now);
            osc.stop(now + 0.6);
        }

        function playLoseSound() {
            stopMusic(); // Stop music on death
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            // Sad descending slide
            const now = audioCtx.currentTime;
            osc.type = 'sawtooth';
            
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.linearRampToValueAtTime(50, now + 1.0);
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
            
            osc.start(now);
            osc.stop(now + 1.0);
        }

        // --- Game Config ---
        const CONFIG = {
            arenaSize: 40,
            playerSpeed: 0.15, 
            playerFriction: 0.92,
            bubbleCount: 15,
            needleCount: 25,
            colors: {
                player: 0x00ffff,
                target: 0xff00ff,
                needle: 0xff3333,
                floor: 0x222222
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let player, floor;
        let targets = [];
        let needles = [];
        let particles = [];
        
        let isGameActive = false;
        let score = 0;
        
        // Player Physics
        let velocity = new THREE.Vector3();
        let input = { x: 0, z: 0 };

        // UI Elements
        const uiScore = document.getElementById('score-hud');
        const screenMenu = document.getElementById('menu-screen');
        const screenGameOver = document.getElementById('game-over-screen');
        const finalScoreText = document.getElementById('final-score');
        const btnStart = document.getElementById('start-btn');
        const btnRestart = document.getElementById('restart-btn');

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 20, 60);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -25;
            dirLight.shadow.camera.right = 25;
            dirLight.shadow.camera.top = 25;
            dirLight.shadow.camera.bottom = -25;
            scene.add(dirLight);

            // Floor
            const floorGeo = new THREE.PlaneGeometry(CONFIG.arenaSize * 2, CONFIG.arenaSize * 2);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.floor, 
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid Helper
            const grid = new THREE.GridHelper(CONFIG.arenaSize * 2, 20, 0x444444, 0x222222);
            scene.add(grid);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            btnStart.addEventListener('click', startGame);
            btnRestart.addEventListener('click', startGame);

            // Start Loop
            animate();
        }

        // --- Game Logic ---

        function createPlayer() {
            if (player) scene.remove(player);
            
            // Outer Glass Sphere
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.player,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.6, // Glass-like
                transparent: true,
                opacity: 0.8
            });
            player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.position.y = 1;
            
            // Inner core (makes it look fuller)
            const coreGeo = new THREE.SphereGeometry(0.7, 16, 16);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeo, coreMat);
            player.add(core);

            scene.add(player);
            velocity.set(0, 0, 0);
        }

        function createNeedles(count) {
            // Remove old
            needles.forEach(n => scene.remove(n));
            needles = [];

            const geometry = new THREE.ConeGeometry(0.5, 2, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.needle, 
                roughness: 0.4 
            });

            for (let i = 0; i < count; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random Position within arena
                const x = (Math.random() - 0.5) * CONFIG.arenaSize;
                const z = (Math.random() - 0.5) * CONFIG.arenaSize;
                
                mesh.position.set(x, 1, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Add slight rotation randomness
                mesh.rotation.x = (Math.random() - 0.5) * 0.5;
                mesh.rotation.z = (Math.random() - 0.5) * 0.5;

                scene.add(mesh);
                needles.push(mesh);
            }
        }

        function createTargets(count) {
            targets.forEach(t => scene.remove(t));
            targets = [];

            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.target,
                emissive: 0x440044,
                roughness: 0.2
            });

            for (let i = 0; i < count; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                spawnTarget(mesh);
                scene.add(mesh);
                targets.push(mesh);
            }
        }

        function spawnTarget(mesh) {
            // Ensure target doesn't spawn inside a needle (basic check)
            let safe = false;
            let x, z;
            
            while(!safe) {
                x = (Math.random() - 0.5) * (CONFIG.arenaSize - 2);
                z = (Math.random() - 0.5) * (CONFIG.arenaSize - 2);
                safe = true;

                // Simple distance check against needles
                for(let n of needles) {
                    if (Math.hypot(x - n.position.x, z - n.position.z) < 2) {
                        safe = false;
                        break;
                    }
                }
            }
            
            mesh.position.set(x, 0.8 + Math.random() * 0.5, z);
            mesh.castShadow = true;
            
            // Assign random float offset for animation
            mesh.userData = {
                floatSpeed: 0.02 + Math.random() * 0.03,
                floatOffset: Math.random() * Math.PI * 2,
                initialY: mesh.position.y
            };
        }

        function createExplosion(position, color) {
            const particleCount = 12;
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                
                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5 + 0.3, // Upward bias
                    (Math.random() - 0.5) * 0.5
                );

                scene.add(mesh);
                particles.push({ mesh, vel, life: 1.0 });
            }
        }

        function startGame() {
            // Resume Audio Context on user gesture
            if (audioCtx.state === 'suspended') audioCtx.resume();

            isGameActive = true;
            score = 0;
            uiScore.innerText = `Score: ${score}`;
            
            screenMenu.classList.add('hidden');
            screenGameOver.classList.add('hidden');
            
            createPlayer();
            createNeedles(CONFIG.needleCount);
            createTargets(CONFIG.bubbleCount);
            
            startMusic();
        }

        function gameOver() {
            isGameActive = false;
            playLoseSound();
            finalScoreText.innerText = `Final Score: ${score}`;
            screenGameOver.classList.remove('hidden');
        }

        // --- Input Handling ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': input.z = -1; break;
                case 'ArrowDown':
                case 'KeyS': input.z = 1; break;
                case 'ArrowLeft':
                case 'KeyA': input.x = -1; break;
                case 'ArrowRight':
                case 'KeyD': input.x = 1; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': if (input.z === -1) input.z = 0; break;
                case 'ArrowDown':
                case 'KeyS': if (input.z === 1) input.z = 0; break;
                case 'ArrowLeft':
                case 'KeyA': if (input.x === -1) input.x = 0; break;
                case 'ArrowRight':
                case 'KeyD': if (input.x === 1) input.x = 0; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = 1; // Simplified delta time

            if (isGameActive && player) {
                // 1. Physics Movement
                velocity.x += input.x * CONFIG.playerSpeed * dt;
                velocity.z += input.z * CONFIG.playerSpeed * dt;
                
                // Friction
                velocity.multiplyScalar(CONFIG.playerFriction);
                
                // Apply Velocity
                player.position.add(velocity);
                
                // Rotation (roll effect)
                player.rotation.x -= velocity.z * 0.1;
                player.rotation.z += velocity.x * 0.1;

                // Boundaries
                const limit = CONFIG.arenaSize / 2 - 1;
                player.position.x = THREE.MathUtils.clamp(player.position.x, -limit, limit);
                player.position.z = THREE.MathUtils.clamp(player.position.z, -limit, limit);

                // 2. Camera Follow
                const targetCamPos = new THREE.Vector3(
                    player.position.x, 
                    player.position.y + 12, 
                    player.position.z + 10
                );
                camera.position.lerp(targetCamPos, 0.05);
                camera.lookAt(player.position);

                // 3. Collision: Targets
                for (let i = targets.length - 1; i >= 0; i--) {
                    const t = targets[i];
                    const dist = player.position.distanceTo(t.position);
                    
                    if (dist < 1.6) { // Pop!
                        createExplosion(t.position, CONFIG.colors.target);
                        playCollectSound(); // Audio Trigger
                        spawnTarget(t); // Respawn elsewhere
                        score += 10;
                        uiScore.innerText = `Score: ${score}`;
                    }
                }

                // 4. Collision: Needles
                for (const n of needles) {
                    // Simple bounding box/distance approximation
                    // Needle is height 2, centered at y=1. Top is y=2.
                    // Player is radius 1, centered at y=1.
                    // Check horizontal distance primarily, then height check
                    const dx = player.position.x - n.position.x;
                    const dz = player.position.z - n.position.z;
                    const hDist = Math.sqrt(dx*dx + dz*dz);

                    if (hDist < 1.2) { // Hit base of needle
                        createExplosion(player.position, CONFIG.colors.player);
                        gameOver();
                    }
                }
            }

            // Animate Targets (Floating)
            const time = Date.now() * 0.001;
            targets.forEach(t => {
                t.position.y = t.userData.initialY + Math.sin(time * 2 + t.userData.floatOffset) * 0.2;
                t.rotation.y += 0.02;
            });

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.mesh.scale.setScalar(p.life); // Shrink

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Run
        init();
    </script>
</body>
</html>