<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resident Snail</title>
<style>
body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
canvas { display: block; cursor: crosshair; }
#ui { position: absolute; top: 20px; left: 20px; color: #fff; text-shadow: 2px 2px 0 #000; font-size: 20px; pointer-events: none; z-index: 10; }
#ui .health { color: #e74c3c; margin-bottom: 10px; }
#ui .ammo { color: #f39c12; }
#gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #e74c3c; font-size: 48px; text-align: center; display: none; text-shadow: 3px 3px 0 #000; z-index: 20; }
#instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 14px; text-align: center; text-shadow: 1px 1px 0 #000; }
</style>
</head>
<body>
<div id="ui">
  <div class="health">HEALTH: <span id="healthVal">100</span>%</div>
  <div class="ammo">AMMO: <span id="ammoVal">15</span>/<span id="maxAmmoVal">15</span></div>
  <div style="font-size:12px;color:#666;margin-top:5px">ROOM: <span id="roomVal">1F-MAIN</span></div>
</div>
<div id="gameOver">
  <div>YOU DIED</div>
  <div style="font-size:20px;color:#fff;margin-top:10px">The snails have inherited the earth</div>
  <div style="font-size:16px;color:#888;margin-top:20px">Click to restart</div>
</div>
<div id="instructions">WASD to move • MOUSE to aim • CLICK to shoot • R to reload</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gameOver = false;
let room = { x: 0, y: 0, w: 2000, h: 1500 };
let camera = { x: 0, y: 0 };

const player = {
  x: room.w/2, y: room.h/2,
  radius: 15,
  speed: 3,
  angle: 0,
  health: 100,
  maxHealth: 100,
  ammo: 15,
  maxAmmo: 15,
  reloading: false,
  reloadTime: 0,
  invulnerable: 0
};

const keys = {};
const bullets = [];
const enemies = [];
const particles = [];
const slimeTrails = [];
const walls = [
  { x: 200, y: 200, w: 400, h: 50 },
  { x: 200, y: 200, w: 50, h: 400 },
  { x: 600, y: 800, w: 400, h: 50 },
  { x: 1000, y: 400, w: 50, h: 400 },
  { x: 1400, y: 200, w: 300, h: 50 },
  { x: 1600, y: 800, w: 50, h: 400 },
  { x: 300, y: 1000, w: 600, h: 50 }
];

const ammoPickups = [
  { x: 250, y: 250, amount: 15, taken: false },
  { x: 1500, y: 900, amount: 15, taken: false },
  { x: 1100, y: 600, amount: 10, taken: false }
];

const healthItems = [
  { x: 1800, y: 300, taken: false },
  { x: 400, y: 1200, taken: false }
];

let mouse = { x: 0, y: 0 };
let frame = 0;

function playSound(type) {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  
  if (type === 'shoot') {
    osc.type = 'square';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
    gain.gain.setValueAtTime(0.3, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    osc.start(now); osc.stop(now + 0.1);
  } else if (type === 'hit') {
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
    gain.gain.setValueAtTime(0.2, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
    osc.start(now); osc.stop(now + 0.3);
  } else if (type === 'reload') {
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, now);
    gain.gain.setValueAtTime(0.1, now);
    gain.gain.setValueAtTime(0, now + 0.05);
    gain.gain.setValueAtTime(0.1, now + 0.1);
    gain.gain.setValueAtTime(0, now + 0.15);
    osc.start(now); osc.stop(now + 0.3);
  } else if (type === 'squish') {
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
    gain.gain.setValueAtTime(0.3, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    osc.start(now); osc.stop(now + 0.5);
  }
}

function spawnSnail(x, y) {
  enemies.push({
    x, y,
    radius: 25,
    speed: 0.5 + Math.random() * 0.5,
    health: 30 + Math.random() * 20,
    maxHealth: 50,
    angle: 0,
    attackCooldown: 0,
    frame: Math.random() * 100,
    state: 'chase'
  });
}

// Initial spawns
for (let i = 0; i < 12; i++) {
  let x, y;
  do {
    x = Math.random() * (room.w - 200) + 100;
    y = Math.random() * (room.h - 200) + 100;
  } while (Math.hypot(x - player.x, y - player.y) < 400);
  spawnSnail(x, y);
}

window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase() === 'r' && !player.reloading && player.ammo < player.maxAmmo) {
    player.reloading = true;
    player.reloadTime = 60;
    playSound('reload');
  }
});

window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

window.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

window.addEventListener('mousedown', () => {
  if (gameOver) {
    location.reload();
    return;
  }
  if (player.ammo > 0 && !player.reloading) {
    player.ammo--;
    playSound('shoot');
    const angle = player.angle;
    bullets.push({
      x: player.x + Math.cos(angle) * 20,
      y: player.y + Math.sin(angle) * 20,
      vx: Math.cos(angle) * 12,
      vy: Math.sin(angle) * 12,
      life: 60
    });
    // Shell casing particle
    particles.push({
      x: player.x + Math.cos(angle - Math.PI/2) * 10,
      y: player.y + Math.sin(angle - Math.PI/2) * 10,
      vx: Math.cos(angle - Math.PI/2) * 2 + Math.random(),
      vy: Math.sin(angle - Math.PI/2) * 2 + Math.random(),
      life: 30,
      color: '#d4af37',
      size: 3
    });
  } else if (player.ammo === 0 && !player.reloading) {
    player.reloading = true;
    player.reloadTime = 60;
    playSound('reload');
  }
});

function rectCircleColliding(circle, rect) {
  const distX = Math.abs(circle.x - rect.x - rect.w/2);
  const distY = Math.abs(circle.y - rect.y - rect.h/2);
  if (distX > (rect.w/2 + circle.radius)) return false;
  if (distY > (rect.h/2 + circle.radius)) return false;
  if (distX <= (rect.w/2)) return true;
  if (distY <= (rect.h/2)) return true;
  const dx = distX - rect.w/2;
  const dy = distY - rect.h/2;
  return (dx*dx + dy*dy <= (circle.radius*circle.radius));
}

function update() {
  if (gameOver) return;
  frame++;
  
  // Reload
  if (player.reloading) {
    player.reloadTime--;
    if (player.reloadTime <= 0) {
      player.ammo = player.maxAmmo;
      player.reloading = false;
    }
  }
  
  // Movement
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup']) dy = -1;
  if (keys['s'] || keys['arrowdown']) dy = 1;
  if (keys['a'] || keys['arrowleft']) dx = -1;
  if (keys['d'] || keys['arrowright']) dx = 1;
  
  if (dx !== 0 || dy !== 0) {
    const len = Math.hypot(dx, dy);
    dx /= len; dy /= len;
    player.x += dx * player.speed;
    player.y += dy * player.speed;
  }
  
  // Bounds
  player.x = Math.max(player.radius, Math.min(room.w - player.radius, player.x));
  player.y = Math.max(player.radius, Math.min(room.h - player.radius, player.y));
  
  // Wall collision
  for (let w of walls) {
    if (rectCircleColliding(player, w)) {
      // Push back
      const centerX = w.x + w.w/2;
      const centerY = w.y + w.h/2;
      const angle = Math.atan2(player.y - centerY, player.x - centerX);
      const dist = Math.hypot(player.x - centerX, player.y - centerY);
      const targetDist = Math.hypot(w.w/2, w.h/2) + player.radius + 2;
      player.x = centerX + Math.cos(angle) * targetDist;
      player.y = centerY + Math.sin(angle) * targetDist;
    }
  }
  
  // Aim
  const screenX = player.x - camera.x + canvas.width/2;
  const screenY = player.y - camera.y + canvas.height/2;
  player.angle = Math.atan2(mouse.y - screenY, mouse.x - screenX);
  
  // Camera follow
  camera.x += (player.x - camera.x) * 0.1;
  camera.y += (player.y - camera.y) * 0.1;
  
  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    b.life--;
    
    // Wall collision
    let hit = false;
    for (let w of walls) {
      if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
        hit = true;
        break;
      }
    }
    
    if (b.life <= 0 || hit) {
      bullets.splice(i, 1);
      if (hit) {
        for (let j = 0; j < 3; j++) {
          particles.push({
            x: b.x, y: b.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 20,
            color: '#888',
            size: 2
          });
        }
      }
    }
  }
  
  // Enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.frame++;
    
    const dist = Math.hypot(player.x - e.x, player.y - e.y);
    
    // AI
    if (dist < 600 && !e.stunned) {
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      e.x += Math.cos(angle) * e.speed;
      e.y += Math.sin(angle) * e.speed;
      e.angle = angle;
      
      // Slime trail
      if (frame % 20 === 0) {
        slimeTrails.push({
          x: e.x + (Math.random() - 0.5) * 20,
          y: e.y + (Math.random() - 0.5) * 20,
          size: 8 + Math.random() * 8,
          life: 300,
          alpha: 0.6
        });
      }
    }
    
    // Attack
    if (dist < player.radius + e.radius && player.invulnerable <= 0) {
      player.health -= 15;
      player.invulnerable = 60;
      playSound('squish');
      // Blood effect
      for (let j = 0; j < 10; j++) {
        particles.push({
          x: player.x, y: player.y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 40,
          color: '#c0392b',
          size: 4
        });
      }
    }
    
    // Bullet hit
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.radius) {
        e.health -= 10;
        e.stunned = 10;
        bullets.splice(j, 1);
        playSound('hit');
        
        // Green blood
        for (let k = 0; k < 5; k++) {
          particles.push({
            x: b.x, y: b.y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 30,
            color: '#2ecc71',
            size: 3
          });
        }
        
        if (e.health <= 0) {
          enemies.splice(i, 1);
          playSound('squish');
          // Death particles (shell pieces)
          for (let k = 0; k < 8; k++) {
            particles.push({
              x: e.x, y: e.y,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 60,
              color: '#8e44ad',
              size: 6
            });
          }
          break;
        }
      }
    }
    
    if (e.stunned > 0) e.stunned--;
  }
  
  if (player.invulnerable > 0) player.invulnerable--;
  if (player.health <= 0) gameOver = true;
  
  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  // Slime decay
  for (let i = slimeTrails.length - 1; i >= 0; i--) {
    slimeTrails[i].life--;
    slimeTrails[i].alpha = slimeTrails[i].life / 300 * 0.6;
    if (slimeTrails[i].life <= 0) slimeTrails.splice(i, 1);
  }
  
  // Pickups
  for (let a of ammoPickups) {
    if (!a.taken && Math.hypot(player.x - a.x, player.y - a.y) < 30) {
      a.taken = true;
      player.ammo = Math.min(player.maxAmmo, player.ammo + a.amount);
      playSound('reload');
    }
  }
  
  for (let h of healthItems) {
    if (!h.taken && Math.hypot(player.x - h.x, player.y - h.y) < 30) {
      h.taken = true;
      player.health = Math.min(player.maxHealth, player.health + 50);
      playSound('reload');
    }
  }
  
  // Spawn more snails occasionally
  if (frame % 600 === 0 && enemies.length < 20) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 600;
    spawnSnail(player.x + Math.cos(angle) * dist, player.y + Math.sin(angle) * dist);
  }
  
  // Update UI
  document.getElementById('healthVal').textContent = Math.max(0, player.health);
  document.getElementById('ammoVal').textContent = player.reloading ? '...' : player.ammo;
  document.getElementById('maxAmmoVal').textContent = player.maxAmmo;
  
  if (gameOver) {
    document.getElementById('gameOver').style.display = 'block';
    document.getElementById('instructions').style.display = 'none';
  }
}

function draw() {
  // Background (dark room)
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(-camera.x + canvas.width/2, -camera.y + canvas.height/2);
  
  // Floor grid effect
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  for (let x = 0; x < room.w; x += 100) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, room.h);
    ctx.stroke();
  }
  for (let y = 0; y < room.h; y += 100) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(room.w, y);
    ctx.stroke();
  }
  
  // Room bounds
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 10;
  ctx.strokeRect(0, 0, room.w, room.h);
  
  // Walls
  ctx.fillStyle = '#2c3e50';
  for (let w of walls) {
    ctx.fillRect(w.x, w.y, w.w, w.h);
    // 3D effect top
    ctx.fillStyle = '#34495e';
    ctx.fillRect(w.x, w.y - 10, w.w, 10);
    ctx.fillStyle = '#2c3e50';
  }
  
  // Slime trails (ground)
  for (let s of slimeTrails) {
    const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size);
    grad.addColorStop(0, `rgba(46, 204, 113, ${s.alpha})`);
    grad.addColorStop(1, `rgba(46, 204, 113, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Pickups
  for (let a of ammoPickups) {
    if (!a.taken) {
      ctx.fillStyle = '#f39c12';
      ctx.beginPath();
      ctx.arc(a.x, a.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('AMMO', a.x, a.y + 4);
    }
  }
  
  for (let h of healthItems) {
    if (!h.taken) {
      ctx.fillStyle = '#e74c3c';
      ctx.beginPath();
      ctx.moveTo(h.x, h.y - 12);
      ctx.lineTo(h.x - 10, h.y);
      ctx.lineTo(h.x, h.y + 12);
      ctx.lineTo(h.x + 10, h.y);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('HERB', h.x, h.y + 20);
    }
  }
  
  // Player
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.rotate(player.angle);
  
  // Body
  ctx.fillStyle = player.invulnerable > 0 && Math.floor(frame / 4) % 2 === 0 ? '#666' : '#3498db';
  ctx.beginPath();
  ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
  ctx.fill();
  
  // Gun
  ctx.fillStyle = '#95a5a6';
  ctx.fillRect(10, -3, 20, 6);
  ctx.fillStyle = '#2c3e50';
  ctx.fillRect(25, -5, 8, 10);
  
  ctx.restore();
  
  // Enemies (Snails)
  for (let e of enemies) {
    ctx.save();
    ctx.translate(e.x, e.y);
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(5, 5, e.radius * 0.9, e.radius * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Slime body
    ctx.fillStyle = '#2ecc71';
    const time = e.frame * 0.05;
    const wobble = Math.sin(time) * 2;
    ctx.beginPath();
    ctx.ellipse(-5, wobble, e.radius * 0.8, e.radius * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Shell
    ctx.fillStyle = '#8e44ad';
    ctx.beginPath();
    ctx.arc(5, -5, e.radius * 0.7, 0, Math.PI * 2);
    ctx.fill();
    
    // Shell spiral
    ctx.strokeStyle = '#6c3483';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < 3; i++) {
      const r = (i + 1) * 6;
      ctx.arc(5, -5, r, 0, Math.PI * 1.5);
    }
    ctx.stroke();
    
    // Tentacles/eye stalks
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 4;
    const eyeOffset = Math.sin(time * 2) * 3;
    
    // Left stalk
    ctx.beginPath();
    ctx.moveTo(-10, -5);
    ctx.quadraticCurveTo(-20 + eyeOffset, -25, -15 + eyeOffset * 1.5, -30);
    ctx.stroke();
    
    // Right stalk
    ctx.beginPath();
    ctx.moveTo(-5, -5);
    ctx.quadraticCurveTo(-5 + eyeOffset, -25, 0 + eyeOffset * 1.5, -32);
    ctx.stroke();
    
    // Eyes
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.arc(-15 + eyeOffset * 1.5, -30, 4, 0, Math.PI * 2);
    ctx.arc(0 + eyeOffset * 1.5, -32, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Pupils
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-15 + eyeOffset * 1.5 + 1, -30, 1.5, 0, Math.PI * 2);
    ctx.arc(0 + eyeOffset * 1.5 + 1, -32, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Health bar
    const barW = 40;
    const barH = 4;
    ctx.fillStyle = '#000';
    ctx.fillRect(-barW/2, -e.radius - 15, barW, barH);
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(-barW/2, -e.radius - 15, barW * (e.health/e.maxHealth), barH);
    
    ctx.restore();
  }
  
  // Bullets
  ctx.fillStyle = '#f1c40f';
  for (let b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
    // Trail
    ctx.strokeStyle = 'rgba(241, 196, 15, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(b.x, b.y);
    ctx.lineTo(b.x - b.vx * 3, b.y - b.vy * 3);
    ctx.stroke();
  }
  
  // Particles
  for (let p of particles) {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life / 40;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  ctx.restore();
  
  // Lighting / Fog of war overlay
  const gradient = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, 100,
    canvas.width/2, canvas.height/2, 500
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0)');
  gradient.addColorStop(1, 'rgba(0,0,0,0.85)');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Flashlight cone effect
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate(player.angle);
  
  const coneGrad = ctx.createConicGradient(-0.3, 0, 0);
  coneGrad.addColorStop(0, 'rgba(255,255,200,0)');
  coneGrad.addColorStop(0.15, 'rgba(255,255,200,0.1)');
  coneGrad.addColorStop(0.5, 'rgba(255,255,200,0)');
  
  ctx.fillStyle = coneGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.arc(0, 0, 400, -0.5, 0.5);
  ctx.fill();
  
  ctx.restore();
  
  // Vignette
  const vig = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.height/3, canvas.width/2, canvas.height/2, canvas.height);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.6)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

loop();
</script>
</body>
</html>